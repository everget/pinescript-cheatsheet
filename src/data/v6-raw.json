{
  "keywords": [
    {
      "name": "or",
      "desc": ["Logical OR. Applicable to boolean expressions."],
      "syntax": ["expr1 or expr2"],
      "remarks": [
        "If `expr1` evaluates to [true](#const_true), the `or` operator returns [true](#const_true) without evaluating `expr2`."
      ],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "and",
      "desc": ["Logical AND. Applicable to boolean expressions."],
      "syntax": ["expr1 and expr2"],
      "remarks": [
        "If `expr1` evaluates to [false](#const_false), the `and` operator returns [false](#const_false) without evaluating `expr2`."
      ],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "not",
      "desc": ["Logical negation (NOT). Applicable to boolean expressions."],
      "syntax": ["not expr1"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "if",
      "desc": [
        "If statement defines what block of statements must be executed when conditions of the expression are satisfied.",
        "To have access to and use the if statement, one should specify the version >= 2 of Pine Script® language in the very first line of code, for example: //@version=6",
        "The 4th version of Pine Script® Language allows you to use “else if” syntax.",
        "General code form:"
      ],
      "syntax": [
        "var_declarationX = if condition\n    var_decl_then0\n    var_decl_then1\n    …\n    var_decl_thenN\nelse if [optional block]\n    var_decl_else0\n    var_decl_else1\n    …\n    var_decl_elseN\nelse\n    var_decl_else0\n    var_decl_else1\n    …\n    var_decl_elseN\n    return_expression_else"
      ],
      "detailedDesc": [
        {
          "desc": [
            "where",
            "**var_declarationX** — this variable gets the value of the if statement",
            "**condition** — if the condition is true, the logic from the block 'then' (var_decl_then0, var_decl_then1, etc.) is used.",
            "If the condition is false, the logic from the block 'else' (var_decl_else0, var_decl_else1, etc.) is used.",
            "**return_expression_then**, **return_expression_else** — the last expression from the block then or from the block else will return the final value of the statement. If declaration of the variable is in the end, its value will be the result.",
            "The type of returning value of the if statement depends on return_expression_then and return_expression_else type (their types must match: it is not possible to return an integer value from then, while you have a string value in else block)."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"if\")",
            "// This code compiles",
            "x = if close > open",
            "    close",
            "else",
            "    open",
            "",
            "// This code doesn’t compile",
            "// y = if close > open",
            "//     close",
            "// else",
            "//     \"open\"",
            "plot(x)"
          ]
        },
        {
          "desc": [
            "It is possible to omit the `else` block. In this case if the condition is false, an “empty” value (na, false, or “”) will be assigned to the var_declarationX variable:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"if\")",
            "x = if close > open",
            "    close",
            "// If current close > current open, then x = close.",
            "// Otherwise the x = na.",
            "plot(x)"
          ]
        },
        {
          "desc": [
            "It is possible to use either multiple “else if” blocks or none at all. The blocks “then”, “else if”, “else” are shifted by four spaces:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"if\")",
            "x = if open > close",
            "    5",
            "else if high > low",
            "    close",
            "else",
            "    open",
            "plot(x)"
          ]
        },
        {
          "desc": [
            "It is possible to ignore the resulting value of an `if` statement (“var_declarationX=“ can be omitted). It may be useful if you need the side effect of the expression, for example in strategy trading:"
          ],
          "examples": [
            "//@version=6",
            "strategy(\"if\")",
            "if (ta.crossover(high, low))",
            "    strategy.entry(\"BBandLE\", strategy.long, stop=low, oca_name=\"BollingerBands\", oca_type=strategy.oca.cancel, comment=\"BBandLE\")",
            "else",
            "    strategy.cancel(id=\"BBandLE\")"
          ]
        },
        {
          "desc": ["If statements can include each other:"],
          "examples": [
            "//@version=6",
            "indicator(\"if\")",
            "float x = na",
            "if close > open",
            "    if close > close[1]",
            "        x := close",
            "    else",
            "        x := close[1]",
            "else",
            "    x := open",
            "plot(x)"
          ]
        }
      ]
    },
    {
      "name": "switch",
      "desc": [
        "The switch operator transfers control to one of the several statements, depending on the values of a condition and expressions."
      ],
      "syntax": [
        "[variable_declaration = ] switch expression\n    value1 => local_block\n    value2 => local_block\n    …\n    => default_local_block\n\n[variable_declaration = ] switch\n    condition1 => local_block\n    condition2 => local_block\n    …\n    => default_local_block"
      ],
      "detailedDesc": [
        {
          "desc": ["Switch with an expression:"],
          "examples": [
            "//@version=6",
            "indicator(\"Switch using an expression\")",
            "",
            "string i_maType = input.string(\"EMA\", \"MA type\", options = [\"EMA\", \"SMA\", \"RMA\", \"WMA\"])",
            "",
            "float ma = switch i_maType",
            "\t\"EMA\" => ta.ema(close, 10)",
            "\t\"SMA\" => ta.sma(close, 10)",
            "\t\"RMA\" => ta.rma(close, 10)",
            "\t// Default used when the three first cases do not match.",
            "\t=> ta.wma(close, 10)",
            "",
            "plot(ma)"
          ]
        },
        {
          "desc": ["Switch without an expression:"],
          "examples": [
            "//@version=6",
            "strategy(\"Switch without an expression\", overlay = true)",
            "",
            "bool longCondition  = ta.crossover( ta.sma(close, 14), ta.sma(close, 28))",
            "bool shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))",
            "",
            "switch",
            "\tlongCondition  => strategy.entry(\"Long ID\", strategy.long)",
            "\tshortCondition => strategy.entry(\"Short ID\", strategy.short)"
          ]
        }
      ],
      "returns": [
        "The value of the last expression in the local block of statements that is executed."
      ],
      "remarks": [
        "Only one of the `local_block` instances or the `default_local_block` can be executed. The `default_local_block` is introduced with the `=>` token alone and is only executed when none of the preceding blocks are executed. If the result of the `switch` statement is assigned to a variable and a `default_local_block` is not specified, the statement returns `na` if no `local_block` is executed. When assigning the result of the `switch` statement to a variable, all `local_block` instances must return the same type of value."
      ],
      "seeAlso": ["[if](#kw_if)", "[?:](#op_?:)"]
    },
    {
      "name": "for",
      "desc": ["The 'for' structure allows the repeated execution of a number of statements:"],
      "syntax": [
        "[var_declaration =] for counter = from_num to to_num [by step_num]\n    statements | continue | break\n    return_expression"
      ],
      "detailedDesc": [
        {
          "desc": [
            "**var_declaration** - An optional variable declaration that will be assigned the value of the loop's return_expression.",
            "**counter** - A variable holding the value of the loop's counter, which is incremented/decremented by 1 or by the step_num value on each iteration of the loop.",
            "**from_num** - The starting value of the counter. \"series int/float\" values/expressions are allowed.",
            "**to_num** - The end value of the counter. When the counter becomes greater than to_num (or less than to_num in cases where from_num > to_num) the loop is broken. \"series int/float\" values/expressions are allowed, but they are evaluated only on the loop's first iteration.",
            "**step_num** - The increment/decrement value of the counter. It is optional. The default value is +1 or -1, depending on which of from_num or to_num is the greatest. When a value is used, the counter is also incremented/decremented depending on which of from_num or to_num is the greatest, so the +/- sign of step_num is optional.",
            "**statements | continue | break** - Any number of statements, or the 'continue' or 'break' keywords, indented by 4 spaces or a tab.",
            "**return_expression** - The loop's return value which is assigned to the variable in var_declaration if one is present. If the loop exits because of a 'continue' or 'break' keyword, the loop's return value is that of the last variable assigned a value before the loop's exit.",
            "**continue** - A keyword that can only be used in loops. It causes the next iteration of the loop to be executed.",
            "**break** - A keyword that exits the loop."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"for\")",
            "// Here, we count the quantity of bars in a given 'lookback' length which closed above the current bar's close",
            "qtyOfHigherCloses(lookback) =>",
            "\tint result = 0",
            "\tfor i = 1 to lookback",
            "\t\tif close[i] > close",
            "\t\t\tresult += 1",
            "\tresult",
            "plot(qtyOfHigherCloses(14))"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"`for` loop with a step\")",
            "",
            "a = array.from(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)",
            "sum = 0.0",
            "",
            "for i = 0 to 9 by 5",
            "\t// Because the step is set to 5, we are adding only the first (0) and the sixth (5) value from the array `a`.",
            "\tsum += array.get(a, i)",
            "",
            "plot(sum)"
          ]
        }
      ],
      "seeAlso": ["[for...in](#kw_for...in)", "[while](#kw_while)"]
    },
    {
      "name": "for...in",
      "desc": [
        "The `for...in` structure allows the repeated execution of a number of statements for each element in an array. It can be used with either one argument: `array_element`, or with two: `[index, array_element]`. The second form doesn't affect the functionality of the loop. It tracks the current iteration's index in the tuple's first variable."
      ],
      "syntax": [
        "[var_declaration =] for array_element in array_id\n    statements | continue | break\n    return_expression\n\n[var_declaration =] for [index, array_element] in array_id\n    statements | continue | break\n    return_expression"
      ],
      "detailedDesc": [
        {
          "desc": [
            "**var_declaration** - An optional variable declaration that will be assigned the value of the loop's `return_expression`.",
            "**index** - An optional variable that tracks the current iteration's index. Indexing starts at 0. The variable is immutable in the loop's body. When used, it must be included in a tuple also containing `array_element`.",
            "**array_element** - A variable containing each successive array element to be processed in the loop. The variable is immutable in the loop's body.",
            "**array_id** - The ID of the array over which the loop is iterated.",
            "**statements | continue | break** - Any number of statements, or the 'continue' or 'break' keywords, indented by 4 spaces or a tab.",
            "**return_expression** - The loop's return value assigned to the variable in `var_declaration`, if one is present. If the loop exits because of a 'continue' or 'break' keyword, the loop's return value is that of the last variable assigned a value before the loop's exit.",
            "**continue** - A keyword that can only be used in loops. It causes the next iteration of the loop to be executed.",
            "**break** - A keyword that exits the loop.",
            "Scripts can modify arrays and matrices while iterating over their elements with this structure. However, maps cannot change while looping through their key-value pairs. To modify a map within a `for...in` loop, iterate over the key-value pairs of a copy or over the elements in its [map.keys](#fun_map.keys) array."
          ]
        },
        {
          "desc": [
            "Here, we use the single-argument form of `for...in` to determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' values:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"for...in\")",
            "// Here we determine on each bar how many of the bar's OHLC values are greater than the SMA of 'close' values",
            "float[] ohlcValues = array.from(open, high, low, close)",
            "qtyGreaterThan(value, array) =>",
            "\tint result = 0",
            "\tfor currentElement in array",
            "\t\tif currentElement > value",
            "\t\t\tresult += 1",
            "\t\tresult",
            "plot(qtyGreaterThan(ta.sma(close, 20), ohlcValues))"
          ]
        },
        {
          "desc": [
            "Here, we use the two-argument form of [for...in](#kw_for...in) to set the values of our `isPos` array to `true` when their corresponding value in our `valuesArray` array is positive:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"for...in\")",
            "var valuesArray = array.from(4, -8, 11, 78, -16, 34, 7, 99, 0, 55)",
            "var isPos = array.new_bool(10, false)",
            "",
            "for [index, value] in valuesArray",
            "\tif value > 0",
            "\t\tarray.set(isPos, index, true)",
            "",
            "if barstate.islastconfirmedhistory",
            "\tlabel.new(bar_index, high, str.tostring(isPos))"
          ]
        },
        {
          "desc": ["Iterate through matrix rows as arrays."],
          "examples": [
            "//@version=6",
            "indicator(\"`for ... in` matrix Example\")",
            "",
            "// Create a 2x3 matrix with values `4`.",
            "matrix1 = matrix.new<int>(2, 3, 4)",
            "",
            "sum = 0.0",
            "// Loop through every row of the matrix.",
            "for rowArray in matrix1",
            "\t// Sum values of the every row ",
            "\tsum += array.sum(rowArray)",
            "",
            "plot(sum)"
          ]
        }
      ],
      "seeAlso": [
        "[for](#kw_for)",
        "[while](#kw_while)",
        "[array.sum](#fun_array.sum)",
        "[array.min](#fun_array.min)",
        "[array.max](#fun_array.max)"
      ]
    },
    {
      "name": "while",
      "desc": ["The `while` statement allows the conditional iteration of a local code block."],
      "syntax": [
        "variable_declaration = while condition\n    …\n    continue\n    …\n    break\n    …\n    return_expression"
      ],
      "detailedDesc": [
        {
          "desc": [
            "where:",
            "**variable_declaration** - An optional variable declaration. The `return expression` can provide the initialization value for this variable.",
            "**condition** - when true, the local block of the `while` statement is executed. When false, execution of the script resumes after the `while` statement.",
            "**continue** - The `continue` keyword causes the loop to branch to its next iteration.",
            "**break** - The `break` keyword causes the loop to terminate. The script's execution resumes after the `while` statement.",
            "**return_expression** - An optional line providing the `while` statement's returning value."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"while\")",
            "// This is a simple example of calculating a factorial using a while loop.",
            "int i_n = input.int(10, \"Factorial Size\", minval=0)",
            "int counter   = i_n",
            "int factorial = 1",
            "while counter > 0",
            "\tfactorial := factorial * counter",
            "\tcounter   := counter - 1",
            "",
            "plot(factorial)"
          ]
        }
      ],
      "remarks": [
        "The local code block after the initial `while` line must be indented with four spaces or a tab. For the `while` loop to terminate, the boolean expression following `while` must eventually become false, or a `break` must be executed."
      ]
    },
    {
      "name": "var",
      "desc": [
        "**var** is the keyword used for assigning and one-time initializing of the variable.",
        "Normally, a syntax of assignment of variables, which doesn’t include the keyword var, results in the value of the variable being overwritten with every update of the data. Contrary to that, when assigning variables with the keyword var, they can “keep the state” despite the data updating, only changing it when conditions within if-expressions are met."
      ],
      "syntax": ["var variable_name = expression"],
      "detailedDesc": [
        {
          "desc": [
            "where:",
            "**variable_name** - any name of the user’s variable that’s allowed in Pine Script® (can contain capital and lowercase Latin characters, numbers, and underscores (_), but can’t start with a number).",
            "**expression** - any arithmetic expression, just as with defining a regular variable. The expression will be calculated and assigned to a variable once."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Var keyword example\")",
            "var a = close",
            "var b = 0.0",
            "var c = 0.0",
            "var green_bars_count = 0",
            "if close > open",
            "\tvar x = close",
            "\tb := x",
            "\tgreen_bars_count := green_bars_count + 1",
            "\tif green_bars_count >= 10",
            "\t\tvar y = close",
            "\t\tc := y",
            "plot(a)",
            "plot(b)",
            "plot(c)"
          ]
        },
        {
          "desc": [
            "The variable 'a' keeps the closing price of the first bar for each bar in the series.",
            "The variable 'b' keeps the closing price of the first \"green\" bar in the series.",
            "The variable 'c' keeps the closing price of the tenth \"green\" bar in the series."
          ]
        }
      ]
    },
    {
      "name": "varip",
      "desc": [
        "**varip** (var intrabar persist) is the keyword used for the assignment and one-time initialization of a variable or a field of a user-defined [type](#kw_type). It’s similar to the [var](#kw_var) keyword, but variables and fields declared with [varip](#kw_varip) retain their values between executions of the script on the same bar."
      ],
      "syntax": [
        "varip [<variable_type> ]<variable_name> = <expression>\n\n[export ]type <UDT_identifier>\n    varip <field_type> <field_name> [= <value>]"
      ],
      "detailedDesc": [
        {
          "desc": [
            "where:",
            "**variable_type** - An optional fundamental type ([int](#type_int), [float](#type_float), [bool](#type_bool), [color](#type_color), [string](#type_string)) or a user-defined type, or an array or matrix of one of those types. Special types are not compatible with this keyword.",
            "**variable_name** - A [valid identifier](https://www.tradingview.com/pine-script-docs/language/identifiers/). The variable can also be an object created from a UDT.",
            "**expression** - Any arithmetic expression, just as when defining a regular variable. The expression will be calculated and assigned to the variable only once, on the first bar.",
            "**UDT_identifier, field_type, field_name, value** - Constructs related to user-defined types as described in the [type](#kw_type) section."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"varip\")",
            "varip int v = -1",
            "v := v + 1",
            "plot(v)"
          ]
        },
        {
          "desc": [
            "With [var](#kw_var), `v` would equal the value of the [bar_index](#var_bar_index). On historical bars, where the script calculates only once per chart bar, the value of `v` is the same as with [var](#kw_var). However, on realtime bars, the script will evaluate the expression on each new chart update, producing a different result."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"varip with types\")",
            "type barData",
            "    int index = -1",
            "    varip int ticks = -1",
            "",
            "var currBar = barData.new()",
            "currBar.index += 1",
            "currBar.ticks += 1",
            "",
            "// Will be equal to bar_index on all bars",
            "plot(currBar.index)",
            "// In real time, will increment per every tick on the chart",
            "plot(currBar.ticks)"
          ]
        },
        {
          "desc": [
            "The same [+=](#op_+=) operation applied to both the `index` and `ticks` fields results in different real-time values because `ticks` increases on every chart update, while `index` only does so once per bar. Note how the `currBar` object does not use the [varip](#kw_varip) keyword. The `ticks` field of the object can increment on every tick, but the reference itself is defined once and then stays unchanged. If we were to declare `currBar` using [varip](#kw_varip), the behavior of `index` would remain unchanged because while the reference to the type instance would persist between chart updates, the `index` field of the object would not."
          ]
        }
      ],
      "remarks": [
        "When using [varip](#kw_varip) to declare variables in strategies that may execute more than once per historical chart bar, the values of such variables are preserved across successive iterations of the script on the same bar.",
        "The effect of [varip](#kw_varip) eliminates the [rollback](https://www.tradingview.com/pine-script-docs/language/execution-model/#calculation-based-on-realtime-bars) of variables before each successive execution of a script on the same bar."
      ]
    },
    {
      "name": "import",
      "desc": [
        "Used to load an external [library](#fun_library) into a script and bind its functions to a namespace. The importing script can be an indicator, a strategy, or another library. A library must be published (privately or publicly) before it can be imported."
      ],
      "args": [
        {
          "name": "username",
          "desc": "User name of the library's author.",
          "displayType": "literal string"
        },
        {
          "name": "libraryName",
          "desc": "Name of the imported library, which corresponds to the `title` argument used by the author in his library script.",
          "displayType": "literal string"
        },
        {
          "name": "libraryVersion",
          "desc": "Version number of the imported library.",
          "displayType": "literal int"
        },
        {
          "name": "alias",
          "desc": "A non-numeric identifier used as a namespace to refer to the library's functions. Optional. The default is the `libraryName` string.",
          "displayType": "literal string"
        }
      ],
      "syntax": ["import {username}/{libraryName}/{libraryVersion} as {alias}"],
      "examples": [
        "//@version=6",
        "indicator(\"num_methods import\")",
        "// Import the first version of the username’s \"num_methods\" library and assign it to the \"m\" namespace\",",
        "import username/num_methods/1 as m",
        "// Call the “sinh()” function from the imported library",
        "y = m.sinh(3.14)",
        "// Plot value returned by the \"sinh()\" function\",",
        "plot(y)"
      ],
      "remarks": [
        "Using an alias that replaces a built-in namespace such as math.* or strategy.* is allowed, but if the library contains function names that shadow Pine Script®'s built-in functions, the built-ins will become unavailable. The same version of a library can only be imported once. Aliases must be distinct for each imported library. When calling library functions, casting their arguments to types other than their declared type is not allowed. An import statement cannot use 'as' or 'import' as `username`, `libraryName`, or `alias` identifiers."
      ],
      "seeAlso": ["[library](#fun_library)", "[export](#kw_export)"]
    },
    {
      "name": "enum",
      "desc": [
        "This keyword allows the creation of an enumeration, enum for short. Enums are unique constructs that hold groups of predefined constants.",
        "Each field in an enum has a `const string` title. Scripts can access the fields in an enum using dot notation, similar to accessing the fields of a user-defined type.",
        "Each field represents a value of the `enumName` enum. Scripts can declare each field in an `enum` with an optional `const string` title. If a field's title is not specified, its title is the string representation of its name. Use [str.tostring](#fun_str.tostring) on an enum field to retrieve its title."
      ],
      "syntax": [
        "[export ]enum <enumName> \n<field_1> [= <title_1>] \n<field_2> [= <title_2>] \n... \n<field_N> [= <title_N>]"
      ],
      "detailedDesc": [
        {
          "desc": [
            "One can use an enum to quickly create a dropdown input with the help of the [input.enum](#fun_input.enum) function. The options that appear in the dropdown represent the titles of the enum fields."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Session highlight\", overlay = true)",
            "",
            "//@enum       Contains fields with popular timezones as titles.",
            "//@field exch Has an empty string as the title to represent the chart timezone.",
            "enum tz",
            "\tutc  = \"UTC\"",
            "\texch = \"\"",
            "\tny   = \"America/New_York\"",
            "\tchi  = \"America/Chicago\"",
            "\tlon  = \"Europe/London\"",
            "\ttok  = \"Asia/Tokyo\"",
            "",
            "//@variable The session string.",
            "selectedSession = input.session(\"1200-1500\", \"Session\")",
            "//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.",
            "selectedTimezone = input.enum(tz.utc, \"Session Timezone\")",
            "",
            "//@variable Is `true` if the current bar's time is in the specified session.",
            "bool inSession = false",
            "if not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))",
            "\tinSession := true",
            "",
            "// Highlight the background when `inSession` is `true`.",
            "bgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
          ]
        },
        {
          "desc": [
            "Additionally, one can use an enum in a collection's type template to restrict the values it will allow as elements. When used inside a type template, the collection will only accept fields that belong to the specified enum."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Map with enum keys\")",
            "",
            "//@enum        Contains fields with titles representing ticker IDs.",
            "//@field aapl  Has an Apple ticker ID as its title.",
            "//@field tsla  Has a Tesla ticker ID as its title.",
            "//@field amzn  Has an Amazon ticker ID as its title.",
            "enum symbols",
            "    aapl = \"NASDAQ:AAPL\"",
            "    tsla = \"NASDAQ:TSLA\"",
            "    amzn = \"NASDAQ:AMZN\"",
            "",
            "//@variable A map that accepts fields from the `symbols` enum as keys and \"float\" values.",
            "map<symbols, float> data = map.new<symbols, float>()",
            "// Put key-value pairs into the `data` map.",
            "data.put(symbols.aapl, request.security(str.tostring(symbols.aapl), timeframe.period, close))",
            "data.put(symbols.tsla, request.security(str.tostring(symbols.tsla), timeframe.period, close))",
            "data.put(symbols.amzn, request.security(str.tostring(symbols.amzn), timeframe.period, close))",
            "// Plot the value from the `data` map accessed by the `symbols.aapl` key.",
            "plot(data.get(symbols.aapl))"
          ]
        }
      ]
    },
    {
      "name": "export",
      "desc": [
        "Used in libraries to prefix the declaration of functions or user-defined type definitions that will be available from other scripts importing the library."
      ],
      "examples": [
        "//@version=6",
        "//@description Library of debugging functions.",
        "library(\"Debugging_library\", overlay = true)",
        "//@function Displays a string as a table cell for debugging purposes.",
        "//@param txt String to display.",
        "//@returns Void.",
        "export print(string txt) => ",
        "\tvar table t = table.new(position.middle_right, 1, 1)",
        "\ttable.cell(t, 0, 0, txt, bgcolor = color.yellow)",
        "// Using the function from inside the library to show an example on the published chart.",
        "// This has no impact on scripts using the library.",
        "print(\"Library Test\")"
      ],
      "remarks": [
        "Each library must have at least one exported function or user-defined type (UDT).",
        "Exported functions cannot use variables from the global scope if they are arrays, mutable variables (reassigned with `:=`), or variables of 'input' form.",
        "Exported functions cannot use `request.*()` functions.",
        "Exported functions must explicitly declare each parameter's type and all parameters must be used in the function's body. By default, all arguments passed to exported functions are of the [series](#type_series) form, unless they are explicitly specified as [simple](#type_simple) in the function's signature.",
        "The @description, @function, @param, @type, @field, and @returns compiler annotations are used to automatically generate the library's description and release notes, and in the Pine Script® Editor's tooltips."
      ],
      "seeAlso": [
        "[library](#fun_library)",
        "[import](#kw_import)",
        "[simple](#type_simple)",
        "[series](#type_series)",
        "[type](#kw_type)"
      ]
    },
    {
      "name": "type",
      "desc": [
        "This keyword allows the declaration of user-defined types (UDT) from which scripts can instantiate objects. UDTs are composite types that contain an arbitrary number of fields of any built-in or user-defined type, including the defined UDT itself. The syntax to define a UDT is:"
      ],
      "syntax": [
        "[export ]type <UDT_identifier>\n    [varip ]<field_type> <field_name> [= <value>]\n    …"
      ],
      "detailedDesc": [
        {
          "desc": [
            "Once a UDT is defined, scripts can instantiate objects from it with the `UDT_identifier.new()` construct. When creating a new type instance, the fields of the resulting object will initialize with the default values from the UDT's definition. Any type fields without specified defaults will initialize as [na](#var_na). Alternatively, users can pass initial values as arguments in the `*.new()` method to override the type's defaults. For example, `newFooObject = foo.new(x = true)` assigns a new `foo` object to the `newFooObject` variable with its `x` field initialized using a value of [true](#const_true).",
            "Field declarations can include the [varip](#kw_varip) keyword, in which case the field values persist between successive script iterations on the same bar.",
            "For more information see the User Manual's sections on [defining UDTs](https://www.tradingview.com/pine-script-docs/language/type-system#user-defined-types) and [using objects](https://www.tradingview.com/pine-script-docs/language/objects/).",
            "Libraries can export UDTs. See the [Libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/#user-defined-types-and-objects) page of our User Manual to learn more."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Multi Time Period Chart\", overlay = true)",
            "",
            "timeframeInput = input.timeframe(\"1D\")",
            "",
            "type bar",
            "    float o = open",
            "    float h = high",
            "    float l = low",
            "    float c = close",
            "    int   t = time",
            "",
            "drawBox(bar b, right) =>",
            "    bar s = bar.new()",
            "    color boxColor = b.c >= b.o ? color.green : color.red",
            "    box.new(b.t, b.h, right, b.l, boxColor, xloc = xloc.bar_time, bgcolor = color.new(boxColor, 90))",
            "",
            "updateBox(box boxId, bar b) =>",
            "    color boxColor = b.c >= b.o ? color.green : color.red",
            "    box.set_border_color(boxId, boxColor)",
            "    box.set_bgcolor(boxId, color.new(boxColor, 90))",
            "    box.set_top(boxId, b.h)",
            "    box.set_bottom(boxId, b.l)",
            "    box.set_right(boxId, time)",
            "",
            "secBar = request.security(syminfo.tickerid, timeframeInput, bar.new())",
            "",
            "if not na(secBar)",
            "    // To avoid a runtime error, only process data when an object exists.",
            "    if not barstate.islast",
            "        if timeframe.change(timeframeInput)",
            "            // On historical bars, draw a new box in the past when the HTF closes.",
            "            drawBox(secBar, time[1])",
            "    else",
            "        var box lastBox = na",
            "        if na(lastBox) or timeframe.change(timeframeInput)",
            "            // On the last bar, only draw a new current box the first time we get there or when HTF changes.",
            "            lastBox := drawBox(secBar, time)",
            "        else",
            "            // On other chart updates, use setters to modify the current box.",
            "            updateBox(lastBox, secBar)"
          ]
        }
      ]
    },
    {
      "name": "method",
      "desc": [
        "This keyword is used to prefix a function declaration, indicating it can then be invoked using dot notation by appending its name to a variable of the type of its first parameter and omitting that first parameter. Alternatively, functions declared as methods can also be invoked like normal user-defined functions. In that case, an argument must be supplied for its first parameter.",
        "The first parameter of a method declaration must be explicitly typified."
      ],
      "syntax": [
        "[export] method <functionName>(<paramType> <paramName> [= <defaultValue>], …) =>\n    <functionBlock>"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"\")",
        "",
        "var prices = array.new<float>()",
        "",
        "//@function Pushes a new value into the array and removes the first one if the resulting array is greater than `maxSize`. Can be used as a method.",
        "method maintainArray(array<float> id, maxSize, value) =>",
        "    id.push(value)",
        "    if id.size() > maxSize",
        "        id.shift()",
        "",
        "prices.maintainArray(50, close)",
        "// The method can also be called like a function, without using dot notation.",
        "// In this case an argument must be supplied for its first parameter.",
        "// maintainArray(prices, 50, close)",
        "",
        "// This calls the `array.avg()` built-in using dot notation with the `prices` array.",
        "// It is possible because built-in functions belonging to some namespaces that are a special Pine type",
        "// can be invoked with method notation when the function's first parameter is an ID of that type.",
        "// Those namespaces are: `array`, `matrix`, `line`, `linefill`, `label`, `box`, and `table`.",
        "plot(prices.avg())"
      ]
    },
    {
      "name": "else"
    },
    {
      "name": "to"
    },
    {
      "name": "by"
    },
    {
      "name": "break"
    },
    {
      "name": "continue"
    },
    {
      "name": "as"
    },
    {
      "name": "in"
    }
  ],
  "operators": [
    {
      "name": "?:",
      "desc": ["Ternary conditional operator."],
      "syntax": ["expr1 ? expr2 : expr3"],
      "examples": [
        "//@version=6",
        "indicator(\"?:\")",
        "// Draw circles at the bars where open crosses close",
        "s2 = ta.cross(open, close) ? math.avg(open,close) : na",
        "plot(s2, style=plot.style_circles, linewidth=2, color=color.red)",
        "",
        "// Combination of ?: operators for 'switch'-like logic",
        "c = timeframe.isintraday ? color.red : timeframe.isdaily ? color.green : timeframe.isweekly ? color.blue : color.gray",
        "plot(hl2, color=c)"
      ],
      "returns": [
        "expr2 if expr1 is evaluated to true, expr3 otherwise. Zero value (0 and also NaN, +Infinity, -Infinity) is considered to be false, any other value is true."
      ],
      "remarks": [
        "Use [na](#var_na) for 'else' branch if you do not need it.",
        "You can combine two or more [?:](#op_?:) operators to achieve the equivalent of a 'switch'-like statement (see examples above).",
        "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
      ],
      "seeAlso": ["[na](#var_na)"]
    },
    {
      "name": "+",
      "desc": ["Addition or unary plus. Applicable to numerical expressions or strings."],
      "syntax": ["expr1 + expr2"],
      "returns": [
        "Binary `+` for strings returns concatenation of expr1 and expr2",
        "For numbers returns integer or float value, or series of values:",
        "Binary `+` returns expr1 plus expr2.",
        "Unary `+` returns expr (does nothing added just for the symmetry with the unary - operator)."
      ],
      "remarks": [
        "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
      ]
    },
    {
      "name": "+",
      "desc": ["Addition or unary plus. Applicable to numerical expressions or strings."],
      "syntax": ["+ expr"],
      "returns": [
        "Binary `+` for strings returns concatenation of expr1 and expr2",
        "For numbers returns integer or float value, or series of values:",
        "Binary `+` returns expr1 plus expr2.",
        "Unary `+` returns expr (does nothing added just for the symmetry with the unary - operator)."
      ],
      "remarks": [
        "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
      ]
    },
    {
      "name": "-",
      "desc": ["Subtraction or unary minus. Applicable to numerical expressions."],
      "syntax": ["expr1 - expr2"],
      "returns": [
        "Returns integer or float value, or series of values:",
        "Binary `-` returns expr1 minus expr2.",
        "Unary `-` returns the negation of expr."
      ],
      "remarks": [
        "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
      ]
    },
    {
      "name": "-",
      "desc": ["Subtraction or unary minus. Applicable to numerical expressions."],
      "syntax": ["- expr"],
      "returns": [
        "Returns integer or float value, or series of values:",
        "Binary `-` returns expr1 minus expr2.",
        "Unary `-` returns the negation of expr."
      ],
      "remarks": [
        "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
      ]
    },
    {
      "name": "[]",
      "desc": [
        "Series subscript. Provides access to previous values of series expr1. expr2 is the number of bars back, and must be numerical. Floats will be rounded down."
      ],
      "syntax": ["expr1[expr2]"],
      "examples": [
        "//@version=6",
        "indicator(\"[]\")",
        "// [] can be used to \"save\" variable value between bars",
        "a = 0.0 // declare `a`",
        "a := a[1] // immediately set current value to the same as previous. `na` in the beginning of history",
        "if high == low // if some condition - change `a` value to another",
        "    a := low",
        "plot(a)"
      ],
      "returns": ["A series of values."],
      "seeAlso": ["[math.floor](#fun_math.floor)"]
    },
    {
      "name": ":=",
      "desc": [
        "Reassignment operator. It is used to assign a new value to a previously declared variable."
      ],
      "syntax": ["<var_name> := <new_value>"],
      "examples": [
        "//@version=6",
        "indicator(\"My script\")",
        "",
        "myVar = 10",
        "",
        "if close > open",
        "    // Modifies the existing global scope `myVar` variable by changing its value from 10 to 20.",
        "    myVar := 20",
        "    // Creates a new `myVar` variable local to the `if` condition and unreachable from the global scope.",
        "    // Does not affect the `myVar` declared in global scope.",
        "    myVar = 30",
        "",
        "plot(myVar)"
      ]
    },
    {
      "name": "==",
      "desc": ["Equal to. Applicable to expressions of any type."],
      "syntax": ["expr1 == expr2"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "!=",
      "desc": ["Not equal to. Applicable to expressions of any type."],
      "syntax": ["expr1 != expr2"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": ">",
      "desc": ["Greater than. Applicable to numerical expressions."],
      "syntax": ["expr1 > expr2"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "<",
      "desc": ["Less than. Applicable to numerical expressions."],
      "syntax": ["expr1 < expr2"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": ">=",
      "desc": ["Greater than or equal to. Applicable to numerical expressions."],
      "syntax": ["expr1 >= expr2"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "<=",
      "desc": ["Less than or equal to. Applicable to numerical expressions."],
      "syntax": ["expr1 <= expr2"],
      "returns": ["Boolean value, or series of boolean values."]
    },
    {
      "name": "*",
      "desc": ["Multiplication. Applicable to numerical expressions."],
      "syntax": ["expr1 * expr2"],
      "returns": ["Integer or float value, or series of values."]
    },
    {
      "name": "/",
      "desc": ["Division. Applicable to numerical expressions."],
      "syntax": ["expr1 / expr2"],
      "returns": ["Integer or float value, or series of values."]
    },
    {
      "name": "%",
      "desc": ["Modulo (integer remainder). Applicable to numerical expressions."],
      "syntax": ["expr1 % expr2"],
      "returns": ["Integer or float value, or series of values."],
      "remarks": [
        "In Pine Script®, when the integer remainder is calculated, the quotient is truncated, i.e. rounded towards the lowest absolute value. The resulting value will have the same sign as the dividend.",
        "Example: `-1 % 9 = -1 - 9 * int(-1/9) = -1 - 9 * int(-0.111) = -1 - 9 * 0 = -1.`"
      ]
    },
    {
      "name": "+=",
      "desc": ["Addition assignment. Applicable to numerical expressions or strings."],
      "syntax": ["expr1 += expr2"],
      "examples": [
        "//@version=6",
        "indicator(\"+=\")",
        "// Equals to expr1 = expr1 + expr2.",
        "a = 2",
        "b = 3",
        "a += b",
        "// Result: a = 5.",
        "plot(a)"
      ],
      "returns": [
        "For strings returns concatenation of expr1 and expr2. For numbers returns integer or float value, or series of values."
      ],
      "remarks": [
        "You may use arithmetic operators with numbers as well as with series variables. In case of usage with series the operators are applied elementwise."
      ]
    },
    {
      "name": "-=",
      "desc": ["Subtraction assignment. Applicable to numerical expressions."],
      "syntax": ["expr1 -= expr2"],
      "examples": [
        "//@version=6",
        "indicator(\"-=\")",
        "// Equals to expr1 = expr1 - expr2.",
        "a = 2",
        "b = 3",
        "a -= b",
        "// Result: a = -1.",
        "plot(a)"
      ],
      "returns": ["Integer or float value, or series of values."]
    },
    {
      "name": "*=",
      "desc": ["Multiplication assignment. Applicable to numerical expressions."],
      "syntax": ["expr1 *= expr2"],
      "examples": [
        "//@version=6",
        "indicator(\"*=\")",
        "// Equals to expr1 = expr1 * expr2.",
        "a = 2",
        "b = 3",
        "a *= b",
        "// Result: a = 6.",
        "plot(a)"
      ],
      "returns": ["Integer or float value, or series of values."]
    },
    {
      "name": "/=",
      "desc": ["Division assignment. Applicable to numerical expressions."],
      "syntax": ["expr1 /= expr2"],
      "examples": [
        "//@version=6",
        "indicator(\"/=\")",
        "// Equals to expr1 = expr1 / expr2.",
        "float a = 3.0",
        "b = 3",
        "a /= b",
        "// Result: a = 1.",
        "plot(a)"
      ],
      "returns": ["Integer or float value, or series of values."]
    },
    {
      "name": "%=",
      "desc": ["Modulo assignment. Applicable to numerical expressions."],
      "syntax": ["expr1 %= expr2"],
      "examples": [
        "//@version=6",
        "indicator(\"%=\")",
        "// Equals to expr1 = expr1 % expr2.",
        "a = 3",
        "b = 3",
        "a %= b",
        "// Result: a = 0.",
        "plot(a)"
      ],
      "returns": ["Integer or float value, or series of values."]
    },
    {
      "name": "=>",
      "desc": [
        "The '=>' operator is used in user-defined function declarations and in [switch](#kw_switch) statements.",
        "The function declaration syntax is:"
      ],
      "syntax": [
        "<identifier>([<parameter_name>[=<default_value>]], ...) =>\n    <local_block>\n    <function_result>"
      ],
      "detailedDesc": [
        {
          "desc": [
            "A <local_block> is zero or more Pine Script® statements.",
            "The <function_result> is a variable, an expression, or a tuple."
          ],
          "examples": [
            "//@version=6",
            "indicator(\"=>\")",
            "// single-line function",
            "f1(x, y) => x + y",
            "// multi-line function",
            "f2(x, y) => ",
            "\tsum = x + y",
            "\tsumChange = ta.change(sum, 10)",
            "\t// Function automatically returns the last expression used in it",
            "plot(f1(30, 8) + f2(1, 3))"
          ]
        }
      ],
      "remarks": [
        "You can learn more about user-defined functions in the User Manual's pages on [Declaring functions](https://www.tradingview.com/pine-script-docs/language/user-defined-functions/) and [Libraries](https://www.tradingview.com/pine-script-docs/concepts/libraries/)."
      ]
    }
  ],
  "variables": [
    {
      "name": "session.isfirstbar",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) if the current bar is the first bar of the day's session, [false](#const_false) otherwise. If extended session information is used, only returns `true` on the first bar of the pre-market bars."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`session.isfirstbar` Example\", overlay = true)",
        "longCondition = year >= 2022",
        "// Place a long order at the `close` of the trading session's first bar.",
        "if session.isfirstbar and longCondition ",
        "    strategy.entry(\"Long\", strategy.long)",
        "",
        "// Close the long position at the `close` of the trading session's last bar.",
        "if session.islastbar and barstate.isconfirmed",
        "    strategy.close(\"Long\", immediately = true)"
      ],
      "seeAlso": [
        "[session.isfirstbar_regular](#var_session.isfirstbar_regular)",
        "[session.islastbar](#var_session.islastbar)",
        "[session.islastbar_regular](#var_session.islastbar_regular)"
      ]
    },
    {
      "name": "session.islastbar",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) if the current bar is the last bar of the day's session, [false](#const_false) otherwise. If extended session information is used, only returns `true` on the last bar of the post-market bars."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`session.islastbar` Example\", overlay = true)",
        "longCondition = year >= 2022",
        "// Place a long order at the `close` of the trading session's last bar.",
        "// The position will enter on the `open` of next session's first bar.",
        "if session.islastbar and longCondition",
        "    strategy.entry(\"Long\", strategy.long)",
        " // Close 'Long' position at the close of the last bar of the trading session",
        "if session.islastbar and barstate.isconfirmed",
        "    strategy.close(\"Long\", immediately = true)"
      ],
      "seeAlso": [
        "[session.isfirstbar](#var_session.isfirstbar)",
        "[session.islastbar_regular](#var_session.islastbar_regular)"
      ],
      "remarks": [
        "This variable is not guaranteed to return [true](#const_true) once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar.",
        "This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko."
      ]
    },
    {
      "name": "session.isfirstbar_regular",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) on the first regular session bar of the day, [false](#const_false) otherwise. The result is the same whether extended session information is used or not."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`session.isfirstbar_regular` Example\", overlay = true)",
        "longCondition = year >= 2022",
        "// Place a long order at the `close` of the trading session's first bar.",
        "if session.isfirstbar and longCondition",
        "    strategy.entry(\"Long\", strategy.long)",
        "// Close the long position at the `close` of the trading session's last bar.",
        "if session.islastbar_regular and barstate.isconfirmed",
        "    strategy.close(\"Long\", immediately = true)"
      ],
      "seeAlso": [
        "[session.isfirstbar](#var_session.isfirstbar)",
        "[session.islastbar](#var_session.islastbar)"
      ]
    },
    {
      "name": "session.islastbar_regular",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) on the last regular session bar of the day, [false](#const_false) otherwise. The result is the same whether extended session information is used or not."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`session.islastbar_regular` Example\", overlay = true)",
        "longCondition = year >= 2022",
        "// Place a long order at the `close` of the trading session's first bar.",
        "if session.isfirstbar and longCondition",
        "    strategy.entry(\"Long\", strategy.long)",
        "// Close the long position at the `close` of the trading session's last bar.",
        "if session.islastbar_regular and barstate.isconfirmed",
        "    strategy.close(\"Long\", immediately = true)"
      ],
      "seeAlso": [
        "[session.isfirstbar](#var_session.isfirstbar)",
        "[session.islastbar](#var_session.islastbar)",
        "[session.isfirstbar_regular](#var_session.isfirstbar_regular)"
      ],
      "remarks": [
        "This variable is not guaranteed to return [true](#const_true) once in every session because the last bar of the session might not exist if no trades occur during what should be the session's last bar.",
        "This variable is not guaranteed to work as expected on non-standard chart types, e.g., Renko."
      ]
    },
    {
      "name": "bar_index",
      "type": "series int",
      "desc": ["Current bar index. Numbering is zero-based, index of the first bar is 0."],
      "examples": [
        "//@version=6",
        "indicator(\"bar_index\")",
        "plot(bar_index)",
        "plot(bar_index > 5000 ? close : 0)"
      ],
      "remarks": [
        "Note that **bar_index** has replaced **n** variable in version 4.",
        "Note that bar indexing starts from 0 on the first historical bar.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[last_bar_index](#var_last_bar_index)",
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.isrealtime](#var_barstate.isrealtime)"
      ]
    },
    {
      "name": "last_bar_index",
      "type": "series int",
      "desc": ["Bar index of the last chart bar. Bar indices begin at zero on the first bar."],
      "examples": [
        "//@version=6",
        "strategy(\"Mark Last X Bars For Backtesting\", overlay = true, calc_on_every_tick = true)",
        "lastBarsFilterInput = input.int(100, \"Bars Count:\")",
        "// Here, we store the 'last_bar_index' value that is known from the beginning of the script's calculation.",
        "// The 'last_bar_index' will change when new real-time bars appear, so we declare 'lastbar' with the 'var' keyword.",
        "var lastbar = last_bar_index",
        "// Check if the current bar_index is 'lastBarsFilterInput' removed from the last bar on the chart, or the chart is traded in real-time.",
        "allowedToTrade = (lastbar - bar_index <= lastBarsFilterInput) or barstate.isrealtime",
        "bgcolor(allowedToTrade ? color.new(color.green, 80) : na)"
      ],
      "returns": [
        "Last historical bar index for closed markets, or the real-time bar index for open markets."
      ],
      "remarks": [
        "Please note that using this variable can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[bar_index](#var_bar_index)",
        "[last_bar_time](#var_last_bar_time)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isrealtime](#var_barstate.isrealtime)"
      ]
    },
    {
      "name": "last_bar_time",
      "type": "series int",
      "desc": [
        "Time in UNIX format of the last chart bar. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "remarks": [
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/).",
        "Note that this variable returns the timestamp based on the time of the bar's open."
      ],
      "seeAlso": [
        "[time](#var_time)",
        "[timenow](#var_timenow)",
        "[timestamp](#fun_timestamp)",
        "[last_bar_index](#var_last_bar_index)"
      ]
    },
    {
      "name": "na",
      "type": "simple na",
      "desc": [
        "A keyword signifying \"not available\", indicating that a variable has no assigned value."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"na\")",
        "// CORRECT",
        "// Plot no value when on bars zero to nine. Plot `close` on other bars.",
        "plot(bar_index < 10 ? na : close)",
        "// CORRECT ALTERNATIVE",
        "// Initialize `a` to `na`. Reassign `close` to `a` on bars 10 and later.",
        "float a = na",
        "if bar_index >= 10",
        "\ta := close",
        "plot(a)",
        "",
        "// INCORRECT",
        "// Trying to test the preceding bar's `close` for `na`.",
        "// The next line, if uncommented, will cause a compilation error, because direct comparison with `na` is not allowed.",
        "// plot(close[1] == na ? close : close[1])",
        "// CORRECT",
        "// Use the `na()` function to test for `na`.",
        "plot(na(close[1]) ? close : close[1])",
        "// CORRECT ALTERNATIVE",
        "// `nz()` tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.",
        "plot(nz(close[1], close))"
      ],
      "remarks": [
        "Do not use this variable with [comparison operators](https://www.tradingview.com/pine-script-docs/language/operators/#comparison-operators) to test values for `na`, as it might lead to unexpected behavior. Instead, use the [na](#fun_na) function. Note that `na` can be used to initialize variables when the initialization statement also specifies the variable's type."
      ],
      "seeAlso": ["[na](#fun_na)", "[nz](#fun_nz)", "[fixnan](#fun_fixnan)"]
    },
    {
      "name": "volume",
      "type": "series float",
      "desc": ["Current bar volume."],
      "remarks": [
        "Previous values may be accessed with square brackets operator [], e.g. volume[1], volume[2]."
      ],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "open",
      "type": "series float",
      "desc": ["Current open price."],
      "remarks": [
        "Previous values may be accessed with square brackets operator [], e.g. open[1], open[2]."
      ],
      "seeAlso": [
        "[high](#var_high)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "high",
      "type": "series float",
      "desc": ["Current high price."],
      "remarks": [
        "Previous values may be accessed with square brackets operator [], e.g. high[1], high[2]."
      ],
      "seeAlso": [
        "[open](#var_open)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "low",
      "type": "series float",
      "desc": ["Current low price."],
      "remarks": [
        "Previous values may be accessed with square brackets operator [], e.g. low[1], low[2]."
      ],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "close",
      "type": "series float",
      "desc": [
        "Close price of the current bar when it has closed, or last traded price of a yet incomplete, realtime bar."
      ],
      "remarks": [
        "Previous values may be accessed with square brackets operator [], e.g. close[1], close[2]."
      ],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "hl2",
      "type": "series float",
      "desc": ["Is a shortcut for (high + low)/2"],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "hlc3",
      "type": "series float",
      "desc": ["Is a shortcut for (high + low + close)/3"],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "hlcc4",
      "type": "series float",
      "desc": ["Is a shortcut for (high + low + close + close)/4"],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "ohlc4",
      "type": "series float",
      "desc": ["Is a shortcut for (open + high + low + close)/4"],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[close](#var_close)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)"
      ]
    },
    {
      "name": "ask",
      "type": "series float",
      "desc": [
        "The current ask price, which represents the lowest price an active seller will accept for the instrument at its current value. This information is available only on the \"1T\" timeframe. On other timeframes, the variable's value is [na](#var_na)."
      ],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[bid](#var_bid)"
      ]
    },
    {
      "name": "bid",
      "type": "series float",
      "desc": [
        "The current bid price, which represents the highest price an active buyer is willing to pay for the instrument at its current value. This information is available only on the \"1T\" timeframe. On other timeframes, the variable's value is [na](#var_na)."
      ],
      "seeAlso": [
        "[open](#var_open)",
        "[high](#var_high)",
        "[low](#var_low)",
        "[volume](#var_volume)",
        "[time](#fun_time)",
        "[hl2](#var_hl2)",
        "[hlc3](#var_hlc3)",
        "[hlcc4](#var_hlcc4)",
        "[ohlc4](#var_ohlc4)",
        "[ask](#var_ask)"
      ]
    },
    {
      "name": "ta.vwap",
      "type": "series float",
      "desc": ["Volume Weighted Average Price. It uses [hlc3](#var_hlc3) as its source series."],
      "seeAlso": ["[ta.vwap](#fun_ta.vwap) (function)"]
    },
    {
      "name": "ta.accdist",
      "type": "series float",
      "desc": ["Accumulation/distribution index."]
    },
    {
      "name": "ta.tr",
      "type": "series float",
      "desc": [
        "True range, equivalent to `ta.tr(handle_na = false)`. It is calculated as `math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1]))`."
      ],
      "seeAlso": ["[ta.tr](#fun_ta.tr)", "[ta.atr](#fun_ta.atr)"]
    },
    {
      "name": "ta.iii",
      "type": "series float",
      "desc": ["Intraday Intensity Index."],
      "examples": [
        "//@version=6",
        "indicator(\"Intraday Intensity Index\")",
        "plot(ta.iii, color=color.yellow)",
        "",
        "// the same on pine",
        "f_iii() =>",
        "    (2 * close - high - low) / ((high - low) * volume)",
        "",
        "plot(f_iii())"
      ]
    },
    {
      "name": "ta.wvad",
      "type": "series float",
      "desc": ["Williams Variable Accumulation/Distribution."],
      "examples": [
        "//@version=6",
        "indicator(\"Williams Variable Accumulation/Distribution\")",
        "plot(ta.wvad, color=color.yellow)",
        "",
        "// the same on pine",
        "f_wvad() =>",
        "    (close - open) / (high - low) * volume",
        "",
        "plot(f_wvad())"
      ]
    },
    {
      "name": "ta.wad",
      "type": "series float",
      "desc": ["Williams Accumulation/Distribution."],
      "examples": [
        "//@version=6",
        "indicator(\"Williams Accumulation/Distribution\")",
        "plot(ta.wad, color=color.yellow)",
        "",
        "// the same on pine",
        "f_wad() =>",
        "    trueHigh = math.max(high, close[1])",
        "    trueLow = math.min(low, close[1])",
        "    mom = ta.change(close)",
        "    gain = (mom > 0) ? close - trueLow : (mom < 0) ? close - trueHigh : 0",
        "    ta.cum(gain)",
        "",
        "plot(f_wad())"
      ]
    },
    {
      "name": "ta.obv",
      "type": "series float",
      "desc": ["On Balance Volume."],
      "examples": [
        "//@version=6",
        "indicator(\"On Balance Volume\")",
        "plot(ta.obv, color=color.yellow)",
        "",
        "// the same on pine",
        "f_obv() =>",
        "    ta.cum(math.sign(ta.change(close)) * volume)",
        "",
        "plot(f_obv())"
      ]
    },
    {
      "name": "ta.pvt",
      "type": "series float",
      "desc": ["Price-Volume Trend."],
      "examples": [
        "//@version=6",
        "indicator(\"Price-Volume Trend\")",
        "plot(ta.pvt, color=color.yellow)",
        "",
        "// the same on pine",
        "f_pvt() =>",
        "    ta.cum((ta.change(close) / close[1]) * volume)",
        "",
        "plot(f_pvt())"
      ]
    },
    {
      "name": "ta.nvi",
      "type": "series float",
      "desc": ["Negative Volume Index."],
      "examples": [
        "//@version=6",
        "indicator(\"Negative Volume Index\")",
        "",
        "plot(ta.nvi, color=color.yellow)",
        "",
        "// the same on pine",
        "f_nvi() =>",
        "    float ta_nvi = 1.0",
        "    float prevNvi = (nz(ta_nvi[1], 0.0) == 0.0) ? 1.0 : ta_nvi[1]",
        "    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0",
        "        ta_nvi := prevNvi",
        "    else",
        "        ta_nvi := (volume < nz(volume[1], 0.0)) ? prevNvi + ((close - close[1]) / close[1]) * prevNvi : prevNvi",
        "    result = ta_nvi",
        "",
        "plot(f_nvi())"
      ]
    },
    {
      "name": "ta.pvi",
      "type": "series float",
      "desc": ["Positive Volume Index."],
      "examples": [
        "//@version=6",
        "indicator(\"Positive Volume Index\")",
        "",
        "plot(ta.pvi, color=color.yellow)",
        "",
        "// the same on pine",
        "f_pvi() =>",
        "    float ta_pvi = 1.0",
        "    float prevPvi = (nz(ta_pvi[1], 0.0) == 0.0) ? 1.0 : ta_pvi[1]",
        "    if nz(close, 0.0) == 0.0 or nz(close[1], 0.0) == 0.0",
        "        ta_pvi := prevPvi",
        "    else",
        "        ta_pvi := (volume > nz(volume[1], 0.0)) ? prevPvi + ((close - close[1]) / close[1]) * prevPvi : prevPvi",
        "    result = ta_pvi",
        "",
        "plot(f_pvi())"
      ]
    },
    {
      "name": "syminfo.ticker",
      "type": "simple string",
      "desc": ["Symbol name without exchange prefix, e.g. 'MSFT'."],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.multiplier](#var_timeframe.multiplier)",
        "[syminfo.root](#var_syminfo.root)"
      ]
    },
    {
      "name": "syminfo.mincontract",
      "type": "simple float",
      "desc": [
        "The smallest amount of the current symbol that can be traded. This limit is set by the exchange. For cryptocurrencies, it is often less than 1 token. For most other types of asset, it is often 1."
      ],
      "seeAlso": [
        "[syminfo.mintick](#var_syminfo.mintick)",
        "[syminfo.pointvalue](#var_syminfo.pointvalue)"
      ]
    },
    {
      "name": "syminfo.tickerid",
      "type": "simple string",
      "desc": [
        "A ticker identifier representing the chart's symbol or a requested symbol, depending on how the script uses it. The variable's value represents a requested dataset's ticker ID when used in the `expression` argument of a `request.*()` function call. Otherwise, it represents the chart's ticker ID. The value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend adjustment, non-standard chart type, currency conversion, etc."
      ],
      "remarks": [
        "Because the value of this variable does not always use a simple \"prefix:ticker\" format, it is a poor candidate for use in boolean comparisons or string manipulation functions. In those contexts, run the variable's result through [ticker.standard](#fun_ticker.standard) to purify it. This will remove any extraneous information and return a ticker ID consistently formatted using the \"prefix:ticker\" structure.",
        "To always access the script's main ticker ID, even within another context, use the [syminfo.main_tickerid](#var_syminfo.main_tickerid) variable."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new) (function)",
        "[syminfo.main_tickerid](#var_syminfo.main_tickerid)",
        "[timeframe.main_period](#var_timeframe.main_period)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.multiplier](#var_timeframe.multiplier)",
        "[syminfo.root](#var_syminfo.root)"
      ]
    },
    {
      "name": "syminfo.main_tickerid",
      "type": "simple string",
      "desc": [
        "A ticker identifier representing the current chart's symbol. The value contains an exchange prefix and a symbol name, separated by a colon (e.g., \"NASDAQ:AAPL\"). It can also include information about data modifications such as dividend adjustment, non-standard chart type, currency conversion, etc. Unlike [syminfo.tickerid](#var_syminfo.tickerid), this variable's value does not change when used in the `expression` argument of a `request.*()` function call."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[timeframe.main_period](#var_timeframe.main_period)",
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.multiplier](#var_timeframe.multiplier)",
        "[syminfo.root](#var_syminfo.root)"
      ]
    },
    {
      "name": "syminfo.expiration_date",
      "type": "simple int",
      "desc": [
        "A UNIX timestamp representing the start of the last day of the current futures contract. This variable is only compatible with non-continuous futures symbols. On other symbols, it returns [na](#var_na)."
      ]
    },
    {
      "name": "syminfo.minmove",
      "type": "simple int",
      "desc": [
        "Returns a whole number used to calculate the smallest increment between a symbol's price movements ([syminfo.mintick](#var_syminfo.mintick)). It is the numerator in the [syminfo.mintick](#var_syminfo.mintick) formula: `syminfo.minmove / syminfo.pricescale = syminfo.mintick`."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new) (function)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.multiplier](#var_timeframe.multiplier)",
        "[syminfo.root](#var_syminfo.root)"
      ]
    },
    {
      "name": "syminfo.pricescale",
      "type": "simple int",
      "desc": [
        "Returns a whole number used to calculate the smallest increment between a symbol's price movements ([syminfo.mintick](#var_syminfo.mintick)). It is the denominator in the [syminfo.mintick](#var_syminfo.mintick) formula: `syminfo.minmove / syminfo.pricescale = syminfo.mintick`."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new) (function)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.multiplier](#var_timeframe.multiplier)",
        "[syminfo.root](#var_syminfo.root)"
      ]
    },
    {
      "name": "timeframe.period",
      "type": "simple string",
      "desc": [
        "A string representation of the script's main timeframe or a requested timeframe, depending on how the script uses it. The variable's value represents the timeframe of a requested dataset when used in the `expression` argument of a `request.*()` function call. Otherwise, its value represents the script's main timeframe ([timeframe.main_period](#var_timeframe.main_period)), which equals either the `timeframe` argument of the [indicator](#fun_indicator) declaration statement or the chart's timeframe.",
        "The string's format is \"<quantity>[<unit>]\", where <unit> is \"T\" for ticks, \"S\" for seconds, \"D\" for days, \"W\" for weeks, and \"M\" for months, but is absent for minutes. No <unit> exists for hours: hourly timeframes are expressed in minutes.",
        "The variable's value is: \"10S\" for 10 seconds, \"30\" for 30 minutes, \"240\" for four hours, \"1D\" for one day, \"2W\" for two weeks, and \"3M\" for one quarter."
      ],
      "remarks": [
        "To always access the script's main timeframe, even within another context, use the [timeframe.main_period](#var_timeframe.main_period) variable."
      ],
      "seeAlso": [
        "[timeframe.main_period](#var_timeframe.main_period)",
        "[syminfo.main_tickerid](#var_syminfo.main_tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[timeframe.multiplier](#var_timeframe.multiplier)"
      ]
    },
    {
      "name": "timeframe.main_period",
      "type": "simple string",
      "desc": [
        "A string representation of the script's main timeframe. If the script is an [indicator](#fun_indicator) that specifies a `timeframe` value in its declaration statement, this variable holds that value. Otherwise, its value represents the chart's timeframe. Unlike [timeframe.period](#var_timeframe.period), this variable's value does not change when used in the `expression` argument of a `request.*()` function call.",
        "The string's format is \"<quantity>[<unit>]\", where <unit> is \"T\" for ticks, \"S\" for seconds, \"D\" for days, \"W\" for weeks, and \"M\" for months, but is absent for minutes. No <unit> exists for hours: hourly timeframes are expressed in minutes.",
        "The variable's value is: \"10S\" for 10 seconds, \"30\" for 30 minutes, \"240\" for four hours, \"1D\" for one day, \"2W\" for two weeks, and \"3M\" for one quarter."
      ],
      "seeAlso": [
        "[timeframe.period](#var_timeframe.period)",
        "[syminfo.main_tickerid](#var_syminfo.main_tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[timeframe.multiplier](#var_timeframe.multiplier)"
      ]
    },
    {
      "name": "syminfo.root",
      "type": "simple string",
      "desc": [
        "Root for derivatives like futures contract. For other symbols returns the same value as [syminfo.ticker](#var_syminfo.ticker)."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo.root\")",
        "",
        "// If the current chart symbol is continuous futures ('ES1!'), it would display 'ES'.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, syminfo.root)"
      ],
      "seeAlso": [
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ]
    },
    {
      "name": "syminfo.prefix",
      "type": "simple string",
      "desc": ["Prefix of current symbol name (i.e. for 'CME_EOD:TICKER' prefix is 'CME_EOD')."],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo.prefix\")",
        "",
        "// If current chart symbol is 'BATS:MSFT' then syminfo.prefix is 'BATS'.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text=syminfo.prefix)"
      ],
      "seeAlso": [
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ]
    },
    {
      "name": "syminfo.mintick",
      "type": "simple float",
      "desc": ["Min tick value for the current symbol."],
      "seeAlso": [
        "[syminfo.pointvalue](#var_syminfo.pointvalue)",
        "[syminfo.mincontract](#var_syminfo.mincontract)"
      ]
    },
    {
      "name": "syminfo.pointvalue",
      "type": "simple float",
      "desc": ["Point value for the current symbol."],
      "seeAlso": [
        "[syminfo.mintick](#var_syminfo.mintick)",
        "[syminfo.mincontract](#var_syminfo.mincontract)"
      ]
    },
    {
      "name": "syminfo.session",
      "type": "simple string",
      "desc": [
        "Session type of the chart main series. Possible values are [session.regular](#const_session.regular), [session.extended](#const_session.extended)."
      ],
      "seeAlso": [
        "[session.regular](#const_session.regular)",
        "[session.extended](#const_session.extended)."
      ]
    },
    {
      "name": "syminfo.timezone",
      "type": "simple string",
      "desc": [
        "Timezone of the exchange of the chart main series. Possible values see in [timestamp](#fun_timestamp)."
      ],
      "seeAlso": ["[timestamp](#fun_timestamp)"]
    },
    {
      "name": "syminfo.description",
      "type": "simple string",
      "desc": ["Description for the current symbol."],
      "seeAlso": ["[syminfo.ticker](#var_syminfo.ticker)", "[syminfo.prefix](#var_syminfo.prefix)"]
    },
    {
      "name": "syminfo.currency",
      "type": "simple string",
      "desc": [
        "Returns a string containing the code representing the currency of the symbol's prices. For example, this variable returns \"USD\" for \"NASDAQ:AAPL\" and \"JPY\" for \"EURJPY\"."
      ],
      "seeAlso": [
        "[syminfo.basecurrency](#var_syminfo.basecurrency)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[currency.USD](#const_currency.USD)",
        "[currency.EUR](#const_currency.EUR)"
      ]
    },
    {
      "name": "syminfo.basecurrency",
      "type": "simple string",
      "desc": [
        "Returns a string containing the code representing the symbol's base currency (i.e., the traded currency or coin) if the instrument is a Forex or Crypto pair or a derivative based on such a pair. Otherwise, it returns an empty string. For example, this variable returns \"EUR\" for \"EURJPY\", \"BTC\" for \"BTCUSDT\", \"CAD\" for \"CME:6C1!\", and \"\" for \"NASDAQ:AAPL\"."
      ],
      "seeAlso": [
        "[syminfo.currency](#var_syminfo.currency)",
        "[syminfo.ticker](#var_syminfo.ticker)"
      ]
    },
    {
      "name": "syminfo.type",
      "type": "simple string",
      "desc": [
        "The type of market the symbol belongs to. The values are \"stock\", \"fund\", \"dr\", \"right\", \"bond\", \"warrant\", \"structured\", \"index\", \"forex\", \"futures\", \"spread\", \"economic\", \"fundamental\", \"crypto\", \"spot\", \"swap\", \"option\", \"commodity\"."
      ],
      "seeAlso": ["[syminfo.ticker](#var_syminfo.ticker)"]
    },
    {
      "name": "syminfo.sector",
      "type": "simple string",
      "desc": [
        "Returns the sector of the symbol, or [na](#var_na) if the symbol has no sector. Example: \"Electronic Technology\", \"Technology services\", \"Energy Minerals\", \"Consumer Durables\", etc. These are the same values one can see in the chart's \"Symbol info\" window."
      ],
      "remarks": [
        "A sector is a broad section of the economy. An industry is a narrower classification. NASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry."
      ]
    },
    {
      "name": "syminfo.industry",
      "type": "simple string",
      "desc": [
        "Returns the industry of the symbol, or [na](#var_na) if the symbol has no industry. Example: \"Internet Software/Services\", \"Packaged software\", \"Integrated Oil\", \"Motor Vehicles\", etc. These are the same values one can see in the chart's \"Symbol info\" window."
      ],
      "remarks": [
        "A sector is a broad section of the economy. An industry is a narrower classification. NASDAQ:CAT (Caterpillar, Inc.) for example, belongs to the \"Producer Manufacturing\" sector and the \"Trucks/Construction/Farm Machinery\" industry."
      ]
    },
    {
      "name": "syminfo.country",
      "type": "simple string",
      "desc": [
        "Returns the two-letter code of the country where the symbol is traded, in the [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format, or [na](#var_na) if the exchange is not directly tied to a specific country. For example, on \"NASDAQ:AAPL\" it will return \"US\", on \"LSE:AAPL\" it will return \"GB\", and on \"BITSTAMP:BTCUSD it will return [na](#var_na)."
      ]
    },
    {
      "name": "syminfo.volumetype",
      "type": "simple string",
      "desc": [
        "Volume type of the current symbol. Possible values are: \"base\" for base currency, \"quote\" for quote currency, \"tick\" for the number of transactions, and \"n/a\" when there is no volume or its type is not specified."
      ],
      "remarks": [
        "Only some data feed suppliers provide information qualifying volume. As a result, the variable will return a value on some symbols only, mostly in the crypto sector."
      ],
      "seeAlso": ["[syminfo.type](#var_syminfo.type)"]
    },
    {
      "name": "syminfo.employees",
      "type": "simple int",
      "desc": ["The number of employees the company has."],
      "seeAlso": [
        "[syminfo.shareholders](#var_syminfo.shareholders)",
        "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)",
        "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo simple\")",
        "//@variable A table containing information about a company's employees, shareholders, and shares.",
        "var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)",
        "if barstate.islastconfirmedhistory",
        "\t// Add header cells",
        "\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")",
        "\t// Add employee info cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))",
        "\t// Add shareholder cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))",
        "\t// Add float shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))",
        "\t// Add total shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ]
    },
    {
      "name": "syminfo.shareholders",
      "type": "simple int",
      "desc": ["The number of shareholders the company has."],
      "seeAlso": [
        "[syminfo.employees](#var_syminfo.employees)",
        "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)",
        "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo simple\")",
        "//@variable A table containing information about a company's employees, shareholders, and shares.",
        "var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)",
        "if barstate.islastconfirmedhistory",
        "\t// Add header cells",
        "\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")",
        "\t// Add employee info cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))",
        "\t// Add shareholder cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))",
        "\t// Add float shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))",
        "\t// Add total shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ]
    },
    {
      "name": "syminfo.shares_outstanding_float",
      "type": "simple float",
      "desc": [
        "The total number of shares outstanding a company has available, excluding any of its restricted shares."
      ],
      "seeAlso": [
        "[syminfo.employees](#var_syminfo.employees)",
        "[syminfo.shareholders](#var_syminfo.shareholders)",
        "[syminfo.shares_outstanding_total](#var_syminfo.shares_outstanding_total)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo simple\")",
        "//@variable A table containing information about a company's employees, shareholders, and shares.",
        "var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)",
        "if barstate.islastconfirmedhistory",
        "\t// Add header cells",
        "\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")",
        "\t// Add employee info cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))",
        "\t// Add shareholder cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))",
        "\t// Add float shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))",
        "\t// Add total shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ]
    },
    {
      "name": "syminfo.shares_outstanding_total",
      "type": "simple int",
      "desc": [
        "The total number of shares outstanding a company has available, including restricted shares held by insiders, major shareholders, and employees."
      ],
      "seeAlso": [
        "[syminfo.employees](#var_syminfo.employees)",
        "[syminfo.shareholders](#var_syminfo.shareholders)",
        "[syminfo.shares_outstanding_float](#var_syminfo.shares_outstanding_float)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo simple\")",
        "//@variable A table containing information about a company's employees, shareholders, and shares.",
        "var result_table = table.new(position = position.top_right, columns = 2, rows = 5, border_width = 1)",
        "if barstate.islastconfirmedhistory",
        "\t// Add header cells",
        "\ttable.cell(table_id = result_table, column = 0, row = 0, text = \"name\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 0, text = \"value\")",
        "\t// Add employee info cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 1, text = \"employees\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 1, text = str.tostring(syminfo.employees))",
        "\t// Add shareholder cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 2, text = \"shareholders\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 2, text = str.tostring(syminfo.shareholders))",
        "\t// Add float shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 3, text = \"shares_outstanding_float\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 3, text = str.tostring(syminfo.shares_outstanding_float))",
        "\t// Add total shares outstanding cells.",
        "\ttable.cell(table_id = result_table, column = 0, row = 4, text = \"shares_outstanding_total\")",
        "\ttable.cell(table_id = result_table, column = 1, row = 4, text = str.tostring(syminfo.shares_outstanding_total))"
      ]
    },
    {
      "name": "syminfo.target_price_average",
      "type": "series float",
      "desc": [
        "The average of the last yearly price targets for the symbol predicted by analysts."
      ],
      "remarks": [
        "If analysts supply the targets when the market is closed, the variable can return [na](#var_na) until the market opens."
      ],
      "seeAlso": [
        "[syminfo.target_price_date](#var_syminfo.target_price_date)",
        "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
        "[syminfo.target_price_high](#var_syminfo.target_price_high)",
        "[syminfo.target_price_low](#var_syminfo.target_price_low)",
        "[syminfo.target_price_median](#var_syminfo.target_price_median)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo target_price\")",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t//@variable A line connecting the current `close` to the highest yearly price estimate.",
        "\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the lowest yearly price estimate.",
        "\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the median yearly price estimate.",
        "\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the average yearly price estimate.",
        "\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)",
        "\t// Fill the space between targets",
        "\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))",
        "\tlinefill.new(medianLine, highLine, color.new(color.green, 90))",
        "\t// Create a label displaying the total number of analyst estimates.",
        "\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)",
        "\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ]
    },
    {
      "name": "syminfo.target_price_date",
      "type": "series int",
      "desc": ["The starting date of the last price target prediction for the current symbol."],
      "remarks": [
        "If analysts supply the targets when the market is closed, the variable can return [na](#var_na) until the market opens."
      ],
      "seeAlso": [
        "[syminfo.target_price_average](#var_syminfo.target_price_average)",
        "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
        "[syminfo.target_price_high](#var_syminfo.target_price_high)",
        "[syminfo.target_price_low](#var_syminfo.target_price_low)",
        "[syminfo.target_price_median](#var_syminfo.target_price_median)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo target_price\")",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t//@variable A line connecting the current `close` to the highest yearly price estimate.",
        "\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the lowest yearly price estimate.",
        "\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the median yearly price estimate.",
        "\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the average yearly price estimate.",
        "\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)",
        "\t// Fill the space between targets",
        "\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))",
        "\tlinefill.new(medianLine, highLine, color.new(color.green, 90))",
        "\t// Create a label displaying the total number of analyst estimates.",
        "\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)",
        "\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ]
    },
    {
      "name": "syminfo.target_price_estimates",
      "type": "series float",
      "desc": ["The latest total number of price target predictions for the current symbol."],
      "remarks": [
        "If analysts supply the targets when the market is closed, the variable can return [na](#var_na) until the market opens."
      ],
      "seeAlso": [
        "[syminfo.target_price_average](#var_syminfo.target_price_average)",
        "[syminfo.target_price_date](#var_syminfo.target_price_date)",
        "[syminfo.target_price_high](#var_syminfo.target_price_high)",
        "[syminfo.target_price_low](#var_syminfo.target_price_low)",
        "[syminfo.target_price_median](#var_syminfo.target_price_median)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo target_price\")",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t//@variable A line connecting the current `close` to the highest yearly price estimate.",
        "\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the lowest yearly price estimate.",
        "\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the median yearly price estimate.",
        "\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the average yearly price estimate.",
        "\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)",
        "\t// Fill the space between targets",
        "\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))",
        "\tlinefill.new(medianLine, highLine, color.new(color.green, 90))",
        "\t// Create a label displaying the total number of analyst estimates.",
        "\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)",
        "\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ]
    },
    {
      "name": "syminfo.target_price_high",
      "type": "series float",
      "desc": ["The last highest yearly price target for the symbol predicted by analysts."],
      "remarks": [
        "If analysts supply the targets when the market is closed, the variable can return [na](#var_na) until the market opens."
      ],
      "seeAlso": [
        "[syminfo.target_price_average](#var_syminfo.target_price_average)",
        "[syminfo.target_price_date](#var_syminfo.target_price_date)",
        "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
        "[syminfo.target_price_low](#var_syminfo.target_price_low)",
        "[syminfo.target_price_median](#var_syminfo.target_price_median)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo target_price\")",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t//@variable A line connecting the current `close` to the highest yearly price estimate.",
        "\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the lowest yearly price estimate.",
        "\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the median yearly price estimate.",
        "\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the average yearly price estimate.",
        "\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)",
        "\t// Fill the space between targets",
        "\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))",
        "\tlinefill.new(medianLine, highLine, color.new(color.green, 90))",
        "\t// Create a label displaying the total number of analyst estimates.",
        "\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)",
        "\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ]
    },
    {
      "name": "syminfo.target_price_low",
      "type": "series float",
      "desc": ["The last lowest yearly price target for the symbol predicted by analysts."],
      "remarks": [
        "If analysts supply the targets when the market is closed, the variable can return [na](#var_na) until the market opens."
      ],
      "seeAlso": [
        "[syminfo.target_price_average](#var_syminfo.target_price_average)",
        "[syminfo.target_price_date](#var_syminfo.target_price_date)",
        "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
        "[syminfo.target_price_high](#var_syminfo.target_price_high)",
        "[syminfo.target_price_median](#var_syminfo.target_price_median)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo target_price\")",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t//@variable A line connecting the current `close` to the highest yearly price estimate.",
        "\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the lowest yearly price estimate.",
        "\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the median yearly price estimate.",
        "\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the average yearly price estimate.",
        "\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)",
        "\t// Fill the space between targets",
        "\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))",
        "\tlinefill.new(medianLine, highLine, color.new(color.green, 90))",
        "\t// Create a label displaying the total number of analyst estimates.",
        "\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)",
        "\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ]
    },
    {
      "name": "syminfo.target_price_median",
      "type": "series float",
      "desc": ["The median of the last yearly price targets for the symbol predicted by analysts."],
      "remarks": [
        "If analysts supply the targets when the market is closed, the variable can return [na](#var_na) until the market opens."
      ],
      "seeAlso": [
        "[syminfo.target_price_average](#var_syminfo.target_price_average)",
        "[syminfo.target_price_date](#var_syminfo.target_price_date)",
        "[syminfo.target_price_estimates](#var_syminfo.target_price_estimates)",
        "[syminfo.target_price_high](#var_syminfo.target_price_high)",
        "[syminfo.target_price_low](#var_syminfo.target_price_low)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo target_price\")",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t//@variable A line connecting the current `close` to the highest yearly price estimate.",
        "\thighLine = line.new(time, close, YTD, syminfo.target_price_high, color = color.green, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the lowest yearly price estimate.",
        "\tlowLine = line.new(time, close, YTD, syminfo.target_price_low, color = color.red, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the median yearly price estimate.",
        "\tmedianLine = line.new(time, close, YTD, syminfo.target_price_median, color = color.gray, xloc = xloc.bar_time)",
        "\t//@variable A line connecting the current `close` to the average yearly price estimate.",
        "\taverageLine = line.new(time, close, YTD, syminfo.target_price_average, color = color.orange, xloc = xloc.bar_time)",
        "\t// Fill the space between targets",
        "\tlinefill.new(lowLine, medianLine, color.new(color.red, 90))",
        "\tlinefill.new(medianLine, highLine, color.new(color.green, 90))",
        "\t// Create a label displaying the total number of analyst estimates.",
        "\tstring estimatesText = str.format(\"Number of estimates: {0}\", syminfo.target_price_estimates)",
        "\tlabel.new(bar_index, close, estimatesText, textcolor = color.white, size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_buy",
      "type": "series int",
      "desc": ["The number of analysts who gave the current symbol a \"Buy\" rating."],
      "seeAlso": [
        "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
        "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
        "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
        "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
        "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
        "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_buy_strong",
      "type": "series int",
      "desc": ["The number of analysts who gave the current symbol a \"Strong Buy\" rating."],
      "seeAlso": [
        "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
        "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
        "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
        "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
        "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
        "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_date",
      "type": "series int",
      "desc": ["The starting date of the last set of recommendations for the current symbol."],
      "seeAlso": [
        "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
        "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
        "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
        "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
        "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
        "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_hold",
      "type": "series int",
      "desc": ["The number of analysts who gave the current symbol a \"Hold\" rating."],
      "seeAlso": [
        "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
        "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
        "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
        "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
        "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
        "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_total",
      "type": "series int",
      "desc": ["The total number of recommendations for the current symbol."],
      "seeAlso": [
        "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
        "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
        "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
        "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
        "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)",
        "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_sell",
      "type": "series int",
      "desc": ["The number of analysts who gave the current symbol a \"Sell\" rating."],
      "seeAlso": [
        "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
        "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
        "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
        "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
        "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
        "[syminfo.recommendations_sell_strong](#var_syminfo.recommendations_sell_strong)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "syminfo.recommendations_sell_strong",
      "type": "series int",
      "desc": ["The number of analysts who gave the current symbol a \"Strong Sell\" rating."],
      "seeAlso": [
        "[syminfo.recommendations_buy](#var_syminfo.recommendations_buy)",
        "[syminfo.recommendations_buy_strong](#var_syminfo.recommendations_buy_strong)",
        "[syminfo.recommendations_date](#var_syminfo.recommendations_date)",
        "[syminfo.recommendations_hold](#var_syminfo.recommendations_hold)",
        "[syminfo.recommendations_total](#var_syminfo.recommendations_total)",
        "[syminfo.recommendations_sell](#var_syminfo.recommendations_sell)"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo recommendations\", overlay = true)",
        "//@variable A table containing information about analyst recommendations.",
        "var table ratings = table.new(position.top_right, 8, 2, frame_color = #000000)",
        "if barstate.islastconfirmedhistory",
        "\t//@variable The time value one year from the date of the last analyst recommendations.",
        "\tint YTD = syminfo.target_price_date + timeframe.in_seconds(\"12M\") * 1000",
        "\t// Add header cells.",
        "\ttable.cell(ratings, 0, 0, \"Start Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 0, \"End Date\", bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 0, \"Buy\", bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 0, \"Strong Buy\", bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 0, \"Sell\", bgcolor = color.maroon, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 5, 0, \"Strong Sell\", bgcolor = color.red, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 6, 0, \"Hold\", bgcolor = color.orange, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 7, 0, \"Total\", bgcolor = color.silver, text_color = #000000, text_size = size.large)",
        "\t// Recommendation strings",
        "\tstring startDate         = str.format_time(syminfo.recommendations_date, \"yyyy-MM-dd\")",
        "\tstring endDate           = str.format_time(YTD, \"yyyy-MM-dd\")",
        "\tstring buyRatings        = str.tostring(syminfo.recommendations_buy)",
        "\tstring strongBuyRatings  = str.tostring(syminfo.recommendations_buy_strong)",
        "\tstring sellRatings       = str.tostring(syminfo.recommendations_sell)",
        "\tstring strongSellRatings = str.tostring(syminfo.recommendations_sell_strong)",
        "\tstring holdRatings       = str.tostring(syminfo.recommendations_hold)",
        "\tstring totalRatings      = str.tostring(syminfo.recommendations_total)",
        "\t// Add value cells",
        "\ttable.cell(ratings, 0, 1, startDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 1, 1, endDate, bgcolor = color.gray, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 2, 1, buyRatings, bgcolor = color.teal, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 3, 1, strongBuyRatings, bgcolor = color.lime, text_color = #000000, text_size = size.large)",
        "\ttable.cell(ratings, 4, 1, sellRatings, bgcolor = color.maroon, text_color = #000000, text_size = size.large)"
      ]
    },
    {
      "name": "timeframe.multiplier",
      "type": "simple int",
      "desc": ["Multiplier of resolution, e.g. '60' - 60, 'D' - 1, '5D' - 5, '12M' - 12."],
      "seeAlso": [
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[timeframe.period](#var_timeframe.period)"
      ]
    },
    {
      "name": "timeframe.isdwm",
      "type": "simple bool",
      "desc": [
        "Returns true if current resolution is a daily or weekly or monthly resolution, false otherwise."
      ],
      "seeAlso": [
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.isweekly](#var_timeframe.isweekly)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timeframe.isintraday",
      "type": "simple bool",
      "desc": [
        "Returns true if current resolution is an intraday (minutes or seconds) resolution, false otherwise."
      ],
      "seeAlso": [
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.isweekly](#var_timeframe.isweekly)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timeframe.isdaily",
      "type": "simple bool",
      "desc": ["Returns true if current resolution is a daily resolution, false otherwise."],
      "seeAlso": [
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isweekly](#var_timeframe.isweekly)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timeframe.isweekly",
      "type": "simple bool",
      "desc": ["Returns true if current resolution is a weekly resolution, false otherwise."],
      "seeAlso": [
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timeframe.ismonthly",
      "type": "simple bool",
      "desc": ["Returns true if current resolution is a monthly resolution, false otherwise."],
      "seeAlso": [
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.isweekly](#var_timeframe.isweekly)"
      ]
    },
    {
      "name": "timeframe.isminutes",
      "type": "simple bool",
      "desc": ["Returns true if current resolution is a minutes resolution, false otherwise."],
      "seeAlso": [
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.isweekly](#var_timeframe.isweekly)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timeframe.isseconds",
      "type": "simple bool",
      "desc": ["Returns true if current resolution is a seconds resolution, false otherwise."],
      "seeAlso": [
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isticks](#var_timeframe.isticks)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.isweekly](#var_timeframe.isweekly)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timeframe.isticks",
      "type": "simple bool",
      "desc": ["Returns true if current resolution is a ticks resolution, false otherwise."],
      "seeAlso": [
        "[timeframe.isdwm](#var_timeframe.isdwm)",
        "[timeframe.isintraday](#var_timeframe.isintraday)",
        "[timeframe.isminutes](#var_timeframe.isminutes)",
        "[timeframe.isseconds](#var_timeframe.isseconds)",
        "[timeframe.isdaily](#var_timeframe.isdaily)",
        "[timeframe.isweekly](#var_timeframe.isweekly)",
        "[timeframe.ismonthly](#var_timeframe.ismonthly)"
      ]
    },
    {
      "name": "timenow",
      "type": "series int",
      "desc": [
        "Current time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "remarks": [
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[timestamp](#fun_timestamp)",
        "[time](#var_time) (variable)",
        "[time_close](#var_time_close)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "time",
      "type": "series int",
      "desc": [
        "Current bar time in UNIX format. It is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "remarks": [
        "Note that this variable returns the timestamp based on the time of the bar's open. Because of that, for overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this variable can return time before the specified date of the trading day. For example, on EURUSD, `dayofmonth(time)` can be lower by 1 than the date of the trading day, because the bar for the current day actually opens one day prior."
      ],
      "seeAlso": [
        "[time](#fun_time) (function)",
        "[time_close](#var_time_close)",
        "[timenow](#var_timenow)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "time_close",
      "type": "series int",
      "desc": [
        "The time of the current bar's close in UNIX format. It represents the number of milliseconds elapsed since 00:00:00 UTC, 1 January 1970. On non-standard price-based chart types (Renko, Line break, Kagi, Point & Figure, and Range), this variable returns [na](#var_na) on the chart's realtime bars."
      ],
      "seeAlso": [
        "[time](#var_time)",
        "[timenow](#var_timenow)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "time_tradingday",
      "type": "series int",
      "desc": [
        "The beginning time of the trading day the current bar belongs to, in UNIX format (the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970)."
      ],
      "remarks": [
        "The variable is useful for overnight sessions, where the current day's session can start on the previous calendar day (e.g., on FXCM:EURUSD the Monday session will start on Sunday, 17:00 in the exchange timezone). Unlike `time`, which would return the timestamp for Sunday at 17:00 for the Monday daily bar, `time_tradingday` will return the timestamp for Monday, 00:00 UTC.",
        "When used on timeframes higher than 1D, `time_tradingday` returns the trading day of the last day inside the bar (e.g. on 1W, it will return the last trading day of the week)."
      ],
      "seeAlso": ["[time](#var_time)", "[time_close](#var_time_close)"]
    },
    {
      "name": "year",
      "type": "series int",
      "desc": ["Current bar year in exchange timezone."],
      "remarks": [
        "Note that this variable returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the year of the trading day."
      ],
      "seeAlso": [
        "[year](#fun_year) (function)",
        "[time](#var_time)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "month",
      "type": "series int",
      "desc": ["Current bar month in exchange timezone."],
      "remarks": [
        "Note that this variable returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the month of the trading day."
      ],
      "seeAlso": [
        "[month](#fun_month) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "weekofyear",
      "type": "series int",
      "desc": ["Week number of current bar time in exchange timezone."],
      "remarks": [
        "Note that this variable returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day."
      ],
      "seeAlso": [
        "[weekofyear](#fun_weekofyear) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "dayofmonth",
      "type": "series int",
      "desc": ["Date of current bar time in exchange timezone."],
      "remarks": [
        "Note that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day."
      ],
      "seeAlso": [
        "[dayofmonth](#fun_dayofmonth) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "dayofweek",
      "type": "series int",
      "desc": ["Day of week for current bar time in exchange timezone."],
      "remarks": [
        "Note that this variable returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",
        "You can use [dayofweek.sunday](#const_dayofweek.sunday), [dayofweek.monday](#const_dayofweek.monday), [dayofweek.tuesday](#const_dayofweek.tuesday), [dayofweek.wednesday](#const_dayofweek.wednesday), [dayofweek.thursday](#const_dayofweek.thursday), [dayofweek.friday](#const_dayofweek.friday) and [dayofweek.saturday](#const_dayofweek.saturday) variables for comparisons."
      ],
      "seeAlso": [
        "[dayofweek](#fun_dayofweek) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[hour](#var_hour)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "hour",
      "type": "series int",
      "desc": ["Current bar hour in exchange timezone."],
      "seeAlso": [
        "[hour](#fun_hour) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[minute](#var_minute)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "minute",
      "type": "series int",
      "desc": ["Current bar minute in exchange timezone."],
      "seeAlso": [
        "[minute](#fun_minute) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[second](#var_second)"
      ]
    },
    {
      "name": "second",
      "type": "series int",
      "desc": ["Current bar second in exchange timezone."],
      "seeAlso": [
        "[second](#fun_second) (function)",
        "[time](#var_time)",
        "[year](#var_year)",
        "[month](#var_month)",
        "[weekofyear](#var_weekofyear)",
        "[dayofmonth](#var_dayofmonth)",
        "[dayofweek](#var_dayofweek)",
        "[hour](#var_hour)",
        "[minute](#var_minute)"
      ]
    },
    {
      "name": "strategy.position_size",
      "type": "series float",
      "desc": [
        "Direction and size of the current market position. If the value is > 0, the market position is long. If the value is < 0, the market position is short. The absolute value is the number of contracts/shares/lots/units in trade (position size)."
      ],
      "seeAlso": ["[strategy.position_avg_price](#var_strategy.position_avg_price)"]
    },
    {
      "name": "strategy.position_avg_price",
      "type": "series float",
      "desc": [
        "Average entry price of current market position. If the market position is flat, 'NaN' is returned."
      ],
      "seeAlso": ["[strategy.position_size](#var_strategy.position_size)"]
    },
    {
      "name": "strategy.openprofit",
      "type": "series float",
      "desc": ["Current unrealized profit or loss for all open positions."],
      "seeAlso": [
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.position_size](#var_strategy.position_size)"
      ]
    },
    {
      "name": "strategy.netprofit",
      "type": "series float",
      "desc": ["Total currency value of all completed trades."],
      "seeAlso": [
        "[strategy.openprofit](#var_strategy.openprofit)",
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.grossprofit](#var_strategy.grossprofit)",
        "[strategy.grossloss](#var_strategy.grossloss)"
      ]
    },
    {
      "name": "strategy.equity",
      "type": "series float",
      "desc": [
        "Current equity ([strategy.initial_capital](#var_strategy.initial_capital) + [strategy.netprofit](#var_strategy.netprofit) + [strategy.openprofit](#var_strategy.openprofit))."
      ],
      "seeAlso": [
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.openprofit](#var_strategy.openprofit)",
        "[strategy.position_size](#var_strategy.position_size)"
      ]
    },
    {
      "name": "strategy.position_entry_name",
      "type": "series string",
      "desc": ["Name of the order that initially opened current market position."],
      "seeAlso": ["[strategy.position_size](#var_strategy.position_size)"]
    },
    {
      "name": "strategy.grossprofit",
      "type": "series float",
      "desc": ["Total currency value of all completed winning trades."],
      "seeAlso": [
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.grossloss](#var_strategy.grossloss)"
      ]
    },
    {
      "name": "strategy.grossloss",
      "type": "series float",
      "desc": ["Total currency value of all completed losing trades."],
      "seeAlso": [
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.grossprofit](#var_strategy.grossprofit)"
      ]
    },
    {
      "name": "strategy.max_drawdown",
      "type": "series float",
      "desc": ["Maximum equity drawdown value for the whole trading range."],
      "seeAlso": [
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.equity](#var_strategy.equity)",
        "[strategy.max_runup](#var_strategy.max_runup)"
      ]
    },
    {
      "name": "strategy.max_runup",
      "type": "series float",
      "desc": ["Maximum equity run-up value for the whole trading range."],
      "seeAlso": [
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.equity](#var_strategy.equity)",
        "[strategy.max_drawdown](#var_strategy.max_drawdown)"
      ]
    },
    {
      "name": "strategy.grossloss_percent",
      "type": "series float",
      "desc": [
        "The total value of all completed losing trades, expressed as a percentage of the initial capital."
      ],
      "seeAlso": ["[strategy.grossloss](#var_strategy.grossloss)"]
    },
    {
      "name": "strategy.max_runup_percent",
      "type": "series float",
      "desc": [
        "The maximum equity run-up value for the whole trading range, expressed as a percentage and calculated by formula: `Highest Value During Trade / (Entry Price x Quantity) * 100`."
      ],
      "seeAlso": ["[strategy.max_runup](#var_strategy.max_runup)"]
    },
    {
      "name": "strategy.netprofit_percent",
      "type": "series float",
      "desc": [
        "The total value of all completed trades, expressed as a percentage of the initial capital."
      ],
      "seeAlso": ["[strategy.netprofit](#var_strategy.netprofit)"]
    },
    {
      "name": "strategy.openprofit_percent",
      "type": "series float",
      "desc": [
        "The current unrealized profit or loss for all open positions, expressed as a percentage and calculated by formula: `openPL / realizedEquity * 100`."
      ],
      "seeAlso": ["[strategy.openprofit](#var_strategy.openprofit)"]
    },
    {
      "name": "strategy.grossprofit_percent",
      "type": "series float",
      "desc": [
        "The total currency value of all completed winning trades, expressed as a percentage of the initial capital."
      ],
      "seeAlso": ["[strategy.grossprofit](#var_strategy.grossprofit)"]
    },
    {
      "name": "strategy.max_drawdown_percent",
      "type": "series float",
      "desc": [
        "The maximum equity drawdown value for the whole trading range, expressed as a percentage and calculated by formula: `Lowest Value During Trade / (Entry Price x Quantity) * 100`."
      ],
      "seeAlso": ["[strategy.max_drawdown](#var_strategy.max_drawdown)"]
    },
    {
      "name": "strategy.avg_trade",
      "type": "series float",
      "desc": [
        "Returns the average amount of money gained or lost per trade. Calculated as the sum of all profits and losses divided by the number of closed trades."
      ],
      "seeAlso": ["[strategy.avg_trade_percent](#var_strategy.avg_trade_percent)"]
    },
    {
      "name": "strategy.avg_trade_percent",
      "type": "series float",
      "desc": [
        "Returns the average percentage gain or loss per trade. Calculated as the sum of all profit and loss percentages divided by the number of closed trades."
      ],
      "seeAlso": ["[strategy.avg_trade](#var_strategy.avg_trade)"]
    },
    {
      "name": "strategy.avg_winning_trade",
      "type": "series float",
      "desc": [
        "Returns the average amount of money gained per winning trade. Calculated as the sum of profits divided by the number of winning trades."
      ],
      "seeAlso": ["[strategy.avg_winning_trade_percent](#var_strategy.avg_winning_trade_percent)"]
    },
    {
      "name": "strategy.avg_winning_trade_percent",
      "type": "series float",
      "desc": [
        "Returns the average percentage gain per winning trade. Calculated as the sum of profit percentages divided by the number of winning trades."
      ],
      "seeAlso": ["[strategy.avg_winning_trade](#var_strategy.avg_winning_trade)"]
    },
    {
      "name": "strategy.avg_losing_trade",
      "type": "series float",
      "desc": [
        "Returns the average amount of money lost per losing trade. Calculated as the sum of losses divided by the number of losing trades."
      ],
      "seeAlso": ["[strategy.avg_losing_trade_percent](#var_strategy.avg_losing_trade_percent)"]
    },
    {
      "name": "strategy.avg_losing_trade_percent",
      "type": "series float",
      "desc": [
        "Returns the average percentage loss per losing trade. Calculated as the sum of loss percentages divided by the number of losing trades."
      ],
      "seeAlso": ["[strategy.avg_losing_trade](#var_strategy.avg_losing_trade)"]
    },
    {
      "name": "strategy.max_contracts_held_all",
      "type": "series float",
      "desc": [
        "Maximum number of contracts/shares/lots/units in one trade for the whole trading range."
      ],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.max_contracts_held_long](#var_strategy.max_contracts_held_long)",
        "[strategy.max_contracts_held_short](#var_strategy.max_contracts_held_short)"
      ]
    },
    {
      "name": "strategy.max_contracts_held_long",
      "type": "series float",
      "desc": [
        "Maximum number of contracts/shares/lots/units in one long trade for the whole trading range."
      ],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.max_contracts_held_all](#var_strategy.max_contracts_held_all)",
        "[strategy.max_contracts_held_short](#var_strategy.max_contracts_held_short)"
      ]
    },
    {
      "name": "strategy.max_contracts_held_short",
      "type": "series float",
      "desc": [
        "Maximum number of contracts/shares/lots/units in one short trade for the whole trading range."
      ],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.max_contracts_held_all](#var_strategy.max_contracts_held_all)",
        "[strategy.max_contracts_held_long](#var_strategy.max_contracts_held_long)"
      ]
    },
    {
      "name": "strategy.opentrades",
      "type": "series int",
      "desc": [
        "Number of market position entries, which were not closed and remain opened. If there is no open market position, 0 is returned."
      ],
      "seeAlso": ["[strategy.position_size](#var_strategy.position_size)"]
    },
    {
      "name": "strategy.opentrades.capital_held",
      "type": "series float",
      "desc": ["Returns the capital amount currently held by open trades."],
      "examples": [
        "//@version=6",
        "strategy(",
        "   \"strategy.opentrades.capital_held example\", overlay=false, margin_long=50, margin_short=50, ",
        "   default_qty_type = strategy.percent_of_equity, default_qty_value = 100",
        " )",
        "",
        "// Enter a short position on the first bar.",
        "if barstate.isfirst",
        "    strategy.entry(\"Short\", strategy.short)",
        "",
        "// Plot the capital held by the short position.",
        "plot(strategy.opentrades.capital_held, \"Capital held\")",
        "// Highlight the chart background if the position is completely closed by margin calls.",
        "bgcolor(bar_index > 0 and strategy.opentrades.capital_held == 0 ? color.new(color.red, 60) : na)"
      ],
      "remarks": [
        "This variable returns [na](#var_na) if the strategy does not simulate funding trades with a portion of the hypothetical account, i.e., if the [strategy](#fun_strategy) function does not include nonzero `margin_long` or `margin_short` arguments."
      ]
    },
    {
      "name": "strategy.closedtrades",
      "type": "series int",
      "desc": ["Number of trades, which were closed for the whole trading range."],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.opentrades](#var_strategy.opentrades)",
        "[strategy.wintrades](#var_strategy.wintrades)",
        "[strategy.losstrades](#var_strategy.losstrades)",
        "[strategy.eventrades](#var_strategy.eventrades)"
      ]
    },
    {
      "name": "strategy.wintrades",
      "type": "series int",
      "desc": ["Number of profitable trades for the whole trading range."],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.opentrades](#var_strategy.opentrades)",
        "[strategy.closedtrades](#var_strategy.closedtrades)",
        "[strategy.losstrades](#var_strategy.losstrades)",
        "[strategy.eventrades](#var_strategy.eventrades)"
      ]
    },
    {
      "name": "strategy.closedtrades.first_index",
      "type": "series int",
      "desc": [
        "The index, or trade number, of the first (oldest) trade listed in the List of Trades. This number is usually zero. If more trades than the allowed limit have been closed, the oldest trades are removed, and this number is the index of the oldest remaining trade."
      ],
      "args": [],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.opentrades](#var_strategy.opentrades)",
        "[strategy.wintrades](#var_strategy.wintrades)",
        "[strategy.losstrades](#var_strategy.losstrades)",
        "[strategy.eventrades](#var_strategy.eventrades)"
      ]
    },
    {
      "name": "strategy.losstrades",
      "type": "series int",
      "desc": ["Number of unprofitable trades for the whole trading range."],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.opentrades](#var_strategy.opentrades)",
        "[strategy.closedtrades](#var_strategy.closedtrades)",
        "[strategy.wintrades](#var_strategy.wintrades)",
        "[strategy.eventrades](#var_strategy.eventrades)"
      ]
    },
    {
      "name": "strategy.eventrades",
      "type": "series int",
      "desc": ["Number of breakeven trades for the whole trading range."],
      "seeAlso": [
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.opentrades](#var_strategy.opentrades)",
        "[strategy.closedtrades](#var_strategy.closedtrades)",
        "[strategy.wintrades](#var_strategy.wintrades)",
        "[strategy.losstrades](#var_strategy.losstrades)"
      ]
    },
    {
      "name": "strategy.initial_capital",
      "type": "series float",
      "desc": ["The amount of initial capital set in the strategy properties."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.account_currency",
      "type": "simple string",
      "desc": [
        "Returns the currency used to calculate results, which can be set in the strategy's properties."
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.convert_to_account](#fun_strategy.convert_to_account)",
        "[strategy.convert_to_symbol](#fun_strategy.convert_to_symbol)"
      ]
    },
    {
      "name": "strategy.margin_liquidation_price",
      "type": "series float",
      "desc": [
        "When margin is used in a strategy, returns the price point where a simulated margin call will occur and liquidate enough of the position to meet the margin requirements."
      ],
      "remarks": [
        "The variable returns [na](#var_na) if the strategy does not use margin, i.e., the [strategy](#fun_strategy) declaration statement does not specify an argument for the `margin_long` or `margin_short` parameter."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"Margin call management\", overlay = true, margin_long = 25, margin_short = 25, ",
        "  default_qty_type = strategy.percent_of_equity, default_qty_value = 395)",
        "",
        "float maFast = ta.sma(close, 14)",
        "float maSlow = ta.sma(close, 28)",
        "",
        "if ta.crossover(maFast, maSlow)",
        "    strategy.entry(\"Long\", strategy.long)",
        "",
        "if ta.crossunder(maFast, maSlow)",
        "    strategy.entry(\"Short\", strategy.short)",
        "",
        "changePercent(v1, v2) => ",
        "    float result = (v1 - v2) * 100 / math.abs(v2)",
        "",
        "// exit when we're 10% away from a margin call, to prevent it.",
        "if math.abs(changePercent(close, strategy.margin_liquidation_price)) <= 10",
        "    strategy.close(\"Long\")",
        "    strategy.close(\"Short\")"
      ]
    },
    {
      "name": "barstate.isfirst",
      "type": "series bool",
      "desc": ["Returns true if current bar is first bar in barset, false otherwise."],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isrealtime](#var_barstate.isrealtime)",
        "[barstate.isnew](#var_barstate.isnew)",
        "[barstate.isconfirmed](#var_barstate.isconfirmed)",
        "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
      ]
    },
    {
      "name": "barstate.islast",
      "type": "series bool",
      "desc": [
        "Returns true if current bar is the last bar in barset, false otherwise. This condition is true for all real-time bars in barset."
      ],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isrealtime](#var_barstate.isrealtime)",
        "[barstate.isnew](#var_barstate.isnew)",
        "[barstate.isconfirmed](#var_barstate.isconfirmed)",
        "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
      ]
    },
    {
      "name": "barstate.ishistory",
      "type": "series bool",
      "desc": ["Returns true if current bar is a historical bar, false otherwise."],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.isrealtime](#var_barstate.isrealtime)",
        "[barstate.isnew](#var_barstate.isnew)",
        "[barstate.isconfirmed](#var_barstate.isconfirmed)",
        "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
      ]
    },
    {
      "name": "barstate.isrealtime",
      "type": "series bool",
      "desc": ["Returns true if current bar is a real-time bar, false otherwise."],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isnew](#var_barstate.isnew)",
        "[barstate.isconfirmed](#var_barstate.isconfirmed)",
        "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
      ]
    },
    {
      "name": "barstate.isnew",
      "type": "series bool",
      "desc": [
        "Returns true if script is currently calculating on new bar, false otherwise. This variable is true when calculating on historical bars or on first update of a newly generated real-time bar."
      ],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isrealtime](#var_barstate.isrealtime)",
        "[barstate.isconfirmed](#var_barstate.isconfirmed)",
        "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
      ]
    },
    {
      "name": "barstate.isconfirmed",
      "type": "series bool",
      "desc": [
        "Returns true if the script is calculating the last (closing) update of the current bar. The next script calculation will be on the new bar data."
      ],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "It is NOT recommended to use [barstate.isconfirmed](#var_barstate.isconfirmed) in [request.security](#fun_request.security) expression. Its value requested from [request.security](#fun_request.security) is unpredictable.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isrealtime](#var_barstate.isrealtime)",
        "[barstate.isnew](#var_barstate.isnew)",
        "[barstate.islastconfirmedhistory](#var_barstate.islastconfirmedhistory)"
      ]
    },
    {
      "name": "barstate.islastconfirmedhistory",
      "type": "series bool",
      "desc": [
        "Returns true if script is executing on the dataset's last bar when market is closed, or script is executing on the bar immediately preceding the real-time bar, if market is open. Returns false otherwise."
      ],
      "remarks": [
        "Pine Script® code that uses this variable could calculate differently on history and real-time data.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[barstate.isfirst](#var_barstate.isfirst)",
        "[barstate.islast](#var_barstate.islast)",
        "[barstate.ishistory](#var_barstate.ishistory)",
        "[barstate.isrealtime](#var_barstate.isrealtime)",
        "[barstate.isnew](#var_barstate.isnew)"
      ]
    },
    {
      "name": "session.ismarket",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) if the current bar is a part of the regular trading hours (i.e. market hours), [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[session.ispremarket](#var_session.ispremarket)",
        "[session.ispostmarket](#var_session.ispostmarket)"
      ]
    },
    {
      "name": "session.ispremarket",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) if the current bar is a part of the pre-market, [false](#const_false) otherwise. On non-intraday charts always returns `false`."
      ],
      "seeAlso": [
        "[session.ismarket](#var_session.ismarket)",
        "[session.ispostmarket](#var_session.ispostmarket)"
      ]
    },
    {
      "name": "session.ispostmarket",
      "type": "series bool",
      "desc": [
        "Returns [true](#const_true) if the current bar is a part of the post-market, [false](#const_false) otherwise. On non-intraday charts always returns `false`."
      ],
      "seeAlso": [
        "[session.ismarket](#var_session.ismarket)",
        "[session.ispremarket](#var_session.ispremarket)"
      ]
    },
    {
      "name": "label.all",
      "type": "array<label>",
      "desc": ["Returns an array filled with all the current labels drawn by the script."],
      "examples": [
        "//@version=6",
        "indicator(\"label.all\")",
        "//delete all labels",
        "label.new(bar_index, close)",
        "a_allLabels = label.all",
        "if array.size(a_allLabels) > 0",
        "\tfor i = 0 to array.size(a_allLabels) - 1",
        "\t\tlabel.delete(array.get(a_allLabels, i))"
      ],
      "remarks": [
        "The array is read-only. Index zero of the array is the ID of the oldest object on the chart."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[line.all](#var_line.all)",
        "[box.all](#var_box.all)",
        "[table.all](#var_table.all)."
      ]
    },
    {
      "name": "line.all",
      "type": "array<line>",
      "desc": ["Returns an array filled with all the current lines drawn by the script."],
      "examples": [
        "//@version=6",
        "indicator(\"line.all\")",
        "//delete all lines",
        "line.new(bar_index - 10, close, bar_index, close)",
        "a_allLines = line.all",
        "if array.size(a_allLines) > 0",
        "\tfor i = 0 to array.size(a_allLines) - 1",
        "\t\tline.delete(array.get(a_allLines, i))"
      ],
      "remarks": [
        "The array is read-only. Index zero of the array is the ID of the oldest object on the chart."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[label.all](#var_label.all)",
        "[box.all](#var_box.all)",
        "[table.all](#var_table.all)."
      ]
    },
    {
      "name": "linefill.all",
      "type": "array<linefill>",
      "desc": [
        "Returns an array filled with all the current linefill objects drawn by the script."
      ],
      "remarks": [
        "The array is read-only. Index zero of the array is the ID of the oldest object on the chart."
      ]
    },
    {
      "name": "box.all",
      "type": "array<box>",
      "desc": ["Returns an array filled with all the current boxes drawn by the script."],
      "examples": [
        "//@version=6",
        "indicator(\"box.all\")",
        "//delete all boxes",
        "box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)",
        "a_allBoxes = box.all",
        "if array.size(a_allBoxes) > 0",
        "\tfor i = 0 to array.size(a_allBoxes) - 1",
        "\t\tbox.delete(array.get(a_allBoxes, i))"
      ],
      "remarks": [
        "The array is read-only. Index zero of the array is the ID of the oldest object on the chart."
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[line.all](#var_line.all)",
        "[label.all](#var_label.all)",
        "[table.all](#var_table.all)."
      ]
    },
    {
      "name": "table.all",
      "type": "array<table>",
      "desc": ["Returns an array filled with all the current tables drawn by the script."],
      "examples": [
        "//@version=6",
        "indicator(\"table.all\")",
        "//delete all tables",
        "table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)",
        "a_allTables = table.all",
        "if array.size(a_allTables) > 0",
        "\tfor i = 0 to array.size(a_allTables) - 1",
        "\t\ttable.delete(array.get(a_allTables, i))"
      ],
      "remarks": [
        "The array is read-only. Index zero of the array is the ID of the oldest object on the chart."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[line.all](#var_line.all)",
        "[label.all](#var_label.all)",
        "[box.all](#var_box.all)."
      ]
    },
    {
      "name": "chart.bg_color",
      "type": "input color",
      "desc": [
        "Returns the color of the chart's background from the \"Chart settings/Appearance/Background\" field. When a gradient is selected, the middle point of the gradient is returned."
      ],
      "seeAlso": ["[chart.fg_color](#var_chart.fg_color)"]
    },
    {
      "name": "chart.fg_color",
      "type": "input color",
      "desc": [
        "Returns a color providing optimal contrast with [chart.bg_color](#var_chart.bg_color)."
      ],
      "seeAlso": ["[chart.bg_color](#var_chart.bg_color)"]
    },
    {
      "name": "chart.left_visible_bar_time",
      "type": "input int",
      "desc": ["The [time](#var_time) of the leftmost bar currently visible on the chart."],
      "remarks": [
        "Scripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars.",
        "Alerts created on a script that includes this variable will only use the value assigned to the variable at the moment of the alert's creation, regardless of whether the value changes afterward, which may lead to repainting."
      ],
      "seeAlso": ["[chart.right_visible_bar_time](#var_chart.right_visible_bar_time)"]
    },
    {
      "name": "chart.right_visible_bar_time",
      "type": "input int",
      "desc": ["The [time](#var_time) of the rightmost bar currently visible on the chart."],
      "remarks": [
        "Scripts using this variable will automatically re-execute when its value updates to reflect changes in the chart, which can be caused by users scrolling the chart, or new real-time bars.",
        "Alerts created on a script that includes this variable will only use the value assigned to the variable at the moment of the alert's creation, regardless of whether the value changes afterward, which may lead to repainting."
      ],
      "seeAlso": ["[chart.left_visible_bar_time](#var_chart.left_visible_bar_time)"]
    },
    {
      "name": "chart.is_heikinashi",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is Heikin Ashi, [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_renko](#var_chart.is_renko)",
        "[chart.is_linebreak](#var_chart.is_linebreak)",
        "[chart.is_kagi](#var_chart.is_kagi)",
        "[chart.is_pnf](#var_chart.is_pnf)",
        "[chart.is_range](#var_chart.is_range)"
      ]
    },
    {
      "name": "chart.is_renko",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is Renko, [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_heikinashi](#var_chart.is_heikinashi)",
        "[chart.is_linebreak](#var_chart.is_linebreak)",
        "[chart.is_kagi](#var_chart.is_kagi)",
        "[chart.is_pnf](#var_chart.is_pnf)",
        "[chart.is_range](#var_chart.is_range)"
      ]
    },
    {
      "name": "chart.is_linebreak",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is Line break, [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_renko](#var_chart.is_renko)",
        "[chart.is_heikinashi](#var_chart.is_heikinashi)",
        "[chart.is_kagi](#var_chart.is_kagi)",
        "[chart.is_pnf](#var_chart.is_pnf)",
        "[chart.is_range](#var_chart.is_range)"
      ]
    },
    {
      "name": "chart.is_kagi",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is Kagi, [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_renko](#var_chart.is_renko)",
        "[chart.is_linebreak](#var_chart.is_linebreak)",
        "[chart.is_heikinashi](#var_chart.is_heikinashi)",
        "[chart.is_pnf](#var_chart.is_pnf)",
        "[chart.is_range](#var_chart.is_range)"
      ]
    },
    {
      "name": "chart.is_pnf",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is Point & figure, [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_renko](#var_chart.is_renko)",
        "[chart.is_linebreak](#var_chart.is_linebreak)",
        "[chart.is_kagi](#var_chart.is_kagi)",
        "[chart.is_heikinashi](#var_chart.is_heikinashi)",
        "[chart.is_range](#var_chart.is_range)"
      ]
    },
    {
      "name": "chart.is_range",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is Range, [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_renko](#var_chart.is_renko)",
        "[chart.is_linebreak](#var_chart.is_linebreak)",
        "[chart.is_kagi](#var_chart.is_kagi)",
        "[chart.is_pnf](#var_chart.is_pnf)",
        "[chart.is_heikinashi](#var_chart.is_heikinashi)"
      ]
    },
    {
      "name": "chart.is_standard",
      "type": "simple bool",
      "returns": [
        "Returns [true](#const_true) if the chart type is not one of the following: Renko, Kagi, Line break, Point & figure, Range, Heikin Ashi; [false](#const_false) otherwise."
      ],
      "seeAlso": [
        "[chart.is_renko](#var_chart.is_renko)",
        "[chart.is_linebreak](#var_chart.is_linebreak)",
        "[chart.is_kagi](#var_chart.is_kagi)",
        "[chart.is_pnf](#var_chart.is_pnf)",
        "[chart.is_range](#var_chart.is_range)",
        "[chart.is_heikinashi](#var_chart.is_heikinashi)"
      ]
    },
    {
      "name": "earnings.future_time",
      "type": "series int",
      "desc": [
        "Returns a UNIX timestamp indicating the expected time of the next earnings report, or [na](#var_na) if this data isn't available."
      ],
      "returns": ["UNIX time, expressed in milliseconds."],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "earnings.future_period_end_time",
      "type": "series int",
      "desc": [
        "Checks the data for the next earnings report and returns the UNIX timestamp of the day when the financial period covered by those earnings ends, or [na](#var_na) if this data isn't available."
      ],
      "returns": ["UNIX time, expressed in milliseconds."],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "earnings.future_eps",
      "type": "series float",
      "desc": [
        "Returns the estimated Earnings per Share of the next earnings report in the currency of the instrument, or [na](#var_na) if this data isn't available."
      ],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "earnings.future_revenue",
      "type": "series float",
      "desc": [
        "Returns the estimated Revenue of the next earnings report in the currency of the instrument, or [na](#var_na) if this data isn't available."
      ],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected time of the next earnings report."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "polyline.all",
      "type": "array<polyline>",
      "desc": [
        "Returns an array containing all current [polyline](#type_polyline) instances drawn by the script."
      ],
      "remarks": [
        "The array is read-only. Index zero of the array references the ID of the oldest polyline object on the chart."
      ]
    },
    {
      "name": "dividends.future_amount",
      "type": "series float",
      "desc": [
        "Returns the payment amount of the upcoming dividend in the currency of the current instrument, or [na](#var_na) if this data isn't available."
      ],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend."
      ]
    },
    {
      "name": "dividends.future_ex_date",
      "type": "series int",
      "returns": ["UNIX time, expressed in milliseconds."],
      "desc": [
        "Returns the Ex-dividend date (Ex-date) of the current instrument's next dividend payment, or [na](#var_na) if this data isn't available. Ex-dividend date signifies when investors are no longer entitled to a payout from the most recent dividend. Only those who purchased shares before this day are entitled to the dividend payment."
      ],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend."
      ]
    },
    {
      "name": "dividends.future_pay_date",
      "type": "series int",
      "returns": ["UNIX time, expressed in milliseconds."],
      "desc": [
        "Returns the Payment date (Pay date) of the current instrument's next dividend payment, or [na](#var_na) if this data isn't available. Payment date signifies the day when eligible investors will receive the dividend payment."
      ],
      "remarks": [
        "This value is only fetched once during the script's initial calculation. The variable will return the same value until the script is recalculated, even after the expected Payment date of the next dividend."
      ]
    }
  ],
  "constants": [
    {
      "name": "math.pi",
      "type": "const float",
      "desc": [
        "Is a named constant for [Archimedes' constant](https://en.wikipedia.org/wiki/Pi). It is equal to 3.1415926535897932."
      ],
      "seeAlso": [
        "[math.e](#const_math.e)",
        "[math.phi](#const_math.phi)",
        "[math.rphi](#const_math.rphi)"
      ]
    },
    {
      "name": "math.phi",
      "type": "const float",
      "desc": [
        "Is a named constant for the [golden ratio](https://en.wikipedia.org/wiki/Golden_ratio). It is equal to 1.6180339887498948."
      ],
      "seeAlso": [
        "[math.e](#const_math.e)",
        "[math.pi](#const_math.pi)",
        "[math.rphi](#const_math.rphi)"
      ]
    },
    {
      "name": "math.rphi",
      "type": "const float",
      "desc": [
        "Is a named constant for the [golden ratio conjugate](https://en.wikipedia.org/wiki/Golden_ratio#Golden_ratio_conjugate). It is equal to 0.6180339887498948."
      ],
      "seeAlso": [
        "[math.e](#const_math.e)",
        "[math.pi](#const_math.pi)",
        "[math.phi](#const_math.phi)"
      ]
    },
    {
      "name": "math.e",
      "type": "const float",
      "desc": [
        "Is a named constant for [Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant)). It is equal to 2.7182818284590452."
      ],
      "seeAlso": [
        "[math.phi](#const_math.phi)",
        "[math.pi](#const_math.pi)",
        "[math.rphi](#const_math.rphi)"
      ]
    },
    {
      "name": "session.regular",
      "type": "const string",
      "desc": ["Constant for regular session type (no extended hours data)."],
      "seeAlso": [
        "[session.extended](#const_session.extended)",
        "[syminfo.session](#var_syminfo.session)"
      ]
    },
    {
      "name": "session.extended",
      "type": "const string",
      "desc": ["Constant for extended session type (with extended hours data)."],
      "seeAlso": [
        "[session.regular](#const_session.regular)",
        "[syminfo.session](#var_syminfo.session)"
      ]
    },
    {
      "name": "adjustment.none",
      "type": "const string",
      "desc": ["Constant for none adjustment type (no adjustment is applied)."],
      "seeAlso": [
        "[adjustment.splits](#const_adjustment.splits)",
        "[adjustment.dividends](#const_adjustment.dividends)",
        "[ticker.new](#fun_ticker.new)"
      ]
    },
    {
      "name": "adjustment.splits",
      "type": "const string",
      "desc": ["Constant for splits adjustment type (splits adjustment is applied)."],
      "seeAlso": [
        "[adjustment.none](#const_adjustment.none)",
        "[adjustment.dividends](#const_adjustment.dividends)",
        "[ticker.new](#fun_ticker.new)"
      ]
    },
    {
      "name": "adjustment.dividends",
      "type": "const string",
      "desc": ["Constant for dividends adjustment type (dividends adjustment is applied)."],
      "seeAlso": [
        "[adjustment.none](#const_adjustment.none)",
        "[adjustment.splits](#const_adjustment.splits)",
        "[ticker.new](#fun_ticker.new)"
      ]
    },
    {
      "name": "hline.style_solid",
      "type": "const hline_style",
      "desc": ["Is a named constant for solid linestyle of [hline](#fun_hline) function."],
      "seeAlso": [
        "[hline.style_dotted](#const_hline.style_dotted)",
        "[hline.style_dashed](#const_hline.style_dashed)"
      ]
    },
    {
      "name": "hline.style_dotted",
      "type": "const hline_style",
      "desc": ["Is a named constant for dotted linestyle of [hline](#fun_hline) function."],
      "seeAlso": [
        "[hline.style_solid](#const_hline.style_solid)",
        "[hline.style_dashed](#const_hline.style_dashed)"
      ]
    },
    {
      "name": "hline.style_dashed",
      "type": "const hline_style",
      "desc": ["Is a named constant for dashed linestyle of [hline](#fun_hline) function."],
      "seeAlso": [
        "[hline.style_solid](#const_hline.style_solid)",
        "[hline.style_dotted](#const_hline.style_dotted)"
      ]
    },
    {
      "name": "position.top_left",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the upper-left edge."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.top_center",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the top edge in the center."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.top_right",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the upper-right edge."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.middle_left",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the left side of the screen."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.middle_center",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the center of the screen."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.middle_right",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the right side of the screen."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.bottom_left",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the bottom left of the screen."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_center](#const_position.bottom_center),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.bottom_center",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the bottom edge in the center."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left),\t[position.bottom_right](#const_position.bottom_right)"
      ]
    },
    {
      "name": "position.bottom_right",
      "type": "const string",
      "desc": [
        "Table position is used in [table.new](#fun_table.new), [table.cell](#fun_table.cell) functions.",
        "Binds the table to the bottom right of the screen."
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[table.cell](#fun_table.cell)",
        "[table.set_position](#fun_table.set_position)",
        "[position.top_left](#const_position.top_left)",
        "[position.top_center](#const_position.top_center)",
        "[position.top_right](#const_position.top_right)",
        "[position.middle_left](#const_position.middle_left)",
        "[position.middle_center](#const_position.middle_center)",
        "[position.middle_right](#const_position.middle_right)",
        "[position.bottom_left](#const_position.bottom_left)",
        "[position.bottom_center](#const_position.bottom_center)"
      ]
    },
    {
      "name": "size.auto",
      "type": "const string",
      "desc": [
        "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. The size of the shape automatically adapts to the size of the bars."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[label.set_size](#fun_label.set_size)",
        "[size.tiny](#const_size.tiny)",
        "[size.small](#const_size.small)",
        "[size.normal](#const_size.normal)",
        "[size.large](#const_size.large)",
        "[size.huge](#const_size.huge)"
      ]
    },
    {
      "name": "size.tiny",
      "type": "const string",
      "desc": [
        "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. The size of the shape constantly tiny."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[label.set_size](#fun_label.set_size)",
        "[size.auto](#const_size.auto)",
        "[size.small](#const_size.small)",
        "[size.normal](#const_size.normal)",
        "[size.large](#const_size.large)",
        "[size.huge](#const_size.huge)"
      ]
    },
    {
      "name": "size.small",
      "type": "const string",
      "desc": [
        "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. The size of the shape constantly small."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[label.set_size](#fun_label.set_size)",
        "[size.auto](#const_size.auto)",
        "[size.tiny](#const_size.tiny)",
        "[size.normal](#const_size.normal)",
        "[size.large](#const_size.large)",
        "[size.huge](#const_size.huge)"
      ]
    },
    {
      "name": "size.normal",
      "type": "const string",
      "desc": [
        "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. The size of the shape constantly normal."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[label.set_size](#fun_label.set_size)",
        "[size.auto](#const_size.auto)",
        "[size.tiny](#const_size.tiny)",
        "[size.small](#const_size.small)",
        "[size.large](#const_size.large)",
        "[size.huge](#const_size.huge)"
      ]
    },
    {
      "name": "size.large",
      "type": "const string",
      "desc": [
        "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. The size of the shape constantly large."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[label.set_size](#fun_label.set_size)",
        "[size.auto](#const_size.auto)",
        "[size.tiny](#const_size.tiny)",
        "[size.small](#const_size.small)",
        "[size.normal](#const_size.normal)",
        "[size.huge](#const_size.huge)"
      ]
    },
    {
      "name": "size.huge",
      "type": "const string",
      "desc": [
        "Size value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. The size of the shape constantly huge."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[label.set_size](#fun_label.set_size)",
        "[size.auto](#const_size.auto)",
        "[size.tiny](#const_size.tiny)",
        "[size.small](#const_size.small)",
        "[size.normal](#const_size.normal)",
        "[size.large](#const_size.large)"
      ]
    },
    {
      "name": "plot.style_line",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Line' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_linebr",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Line With Breaks' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function. Similar to [plot.style_line](#const_plot.style_line), except the gaps in the data are not filled."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_stepline",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Step Line' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_stepline_diamond",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Step Line With Diamonds' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function. Similar to [plot.style_stepline](#const_plot.style_stepline), except the data changes are also marked with the Diamond shapes."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_histogram",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Histogram' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_cross",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Cross' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_area",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Area' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_areabr",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Area With Breaks' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function. Similar to [plot.style_area](#const_plot.style_area), except the gaps in the data are not filled."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_columns](#const_plot.style_columns)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_columns",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Columns' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_circles](#const_plot.style_circles)"
      ]
    },
    {
      "name": "plot.style_circles",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Circles' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_steplinebr](#const_plot.style_steplinebr)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)"
      ]
    },
    {
      "name": "plot.style_steplinebr",
      "type": "const plot_style",
      "desc": [
        "A named constant for the 'Step line with Breaks' style, to be used as an argument for the `style` parameter in the [plot](#fun_plot) function."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plot.style_circles](#const_plot.style_circles)",
        "[plot.style_line](#const_plot.style_line)",
        "[plot.style_linebr](#const_plot.style_linebr)",
        "[plot.style_stepline](#const_plot.style_stepline)",
        "[plot.style_stepline_diamond](#const_plot.style_stepline_diamond)",
        "[plot.style_histogram](#const_plot.style_histogram)",
        "[plot.style_cross](#const_plot.style_cross)",
        "[plot.style_area](#const_plot.style_area)",
        "[plot.style_areabr](#const_plot.style_areabr)",
        "[plot.style_columns](#const_plot.style_columns)"
      ]
    },
    {
      "name": "format.inherit",
      "type": "const string",
      "desc": [
        "Is a named constant for selecting the formatting of the script output values from the parent series in the [indicator](#fun_indicator) function."
      ],
      "seeAlso": [
        "[indicator](#fun_indicator)",
        "[format.price](#const_format.price)",
        "[format.volume](#const_format.volume)",
        "[format.percent](#const_format.percent)"
      ]
    },
    {
      "name": "format.price",
      "type": "const string",
      "desc": [
        "Is a named constant for selecting the formatting of the script output values as prices in the [indicator](#fun_indicator) function."
      ],
      "remarks": [
        "If format is format.price, default precision value is set. You can use the precision argument of indicator function to change the precision value."
      ],
      "seeAlso": [
        "[indicator](#fun_indicator)",
        "[format.inherit](#const_format.inherit)",
        "[format.volume](#const_format.volume)",
        "[format.percent](#const_format.percent)"
      ]
    },
    {
      "name": "format.volume",
      "type": "const string",
      "desc": [
        "Is a named constant for selecting the formatting of the script output values as volume in the [indicator](#fun_indicator) function, e.g. '5183' will be formatted as '5.183K'.",
        "The decimal precision rules defined by this variable take precedence over other precision settings. When an [indicator](#fun_indicator), [strategy](#fun_strategy), or `plot*()` call uses this `format` option, the function's `precision` parameter will not affect the result."
      ],
      "seeAlso": [
        "[indicator](#fun_indicator)",
        "[format.inherit](#const_format.inherit)",
        "[format.price](#const_format.price)",
        "[format.percent](#const_format.percent)"
      ]
    },
    {
      "name": "format.percent",
      "type": "const string",
      "desc": [
        "Is a named constant for selecting the formatting of the script output values as a percentage in the indicator function. It adds a percent sign after values."
      ],
      "remarks": [
        "The default precision is 2, regardless of the precision of the chart itself. This can be changed with the 'precision' argument of the [indicator](#fun_indicator) function."
      ],
      "seeAlso": [
        "[indicator](#fun_indicator)",
        "[format.inherit](#const_format.inherit)",
        "[format.price](#const_format.price)",
        "[format.volume](#const_format.volume)"
      ]
    },
    {
      "name": "format.mintick",
      "type": "const string",
      "desc": [
        "Is a named constant to use with the [str.tostring](#fun_str.tostring) function. Passing a number to [str.tostring](#fun_str.tostring) with this argument rounds the number to the nearest value that can be divided by [syminfo.mintick](#var_syminfo.mintick), without the remainder, with ties rounding up, and returns the string version of said value with trailing zeros."
      ],
      "seeAlso": [
        "[indicator](#fun_indicator)",
        "[format.inherit](#const_format.inherit)",
        "[format.price](#const_format.price)",
        "[format.volume](#const_format.volume)"
      ]
    },
    {
      "name": "dayofweek.sunday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.monday](#const_dayofweek.monday)",
        "[dayofweek.tuesday](#const_dayofweek.tuesday)",
        "[dayofweek.wednesday](#const_dayofweek.wednesday)",
        "[dayofweek.thursday](#const_dayofweek.thursday)",
        "[dayofweek.friday](#const_dayofweek.friday)",
        "[dayofweek.saturday](#const_dayofweek.saturday)"
      ]
    },
    {
      "name": "dayofweek.monday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.sunday](#const_dayofweek.sunday)",
        "[dayofweek.tuesday](#const_dayofweek.tuesday)",
        "[dayofweek.wednesday](#const_dayofweek.wednesday)",
        "[dayofweek.thursday](#const_dayofweek.thursday)",
        "[dayofweek.friday](#const_dayofweek.friday)",
        "[dayofweek.saturday](#const_dayofweek.saturday)"
      ]
    },
    {
      "name": "dayofweek.tuesday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.sunday](#const_dayofweek.sunday)",
        "[dayofweek.monday](#const_dayofweek.monday)",
        "[dayofweek.wednesday](#const_dayofweek.wednesday)",
        "[dayofweek.thursday](#const_dayofweek.thursday)",
        "[dayofweek.friday](#const_dayofweek.friday)",
        "[dayofweek.saturday](#const_dayofweek.saturday)"
      ]
    },
    {
      "name": "dayofweek.wednesday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.sunday](#const_dayofweek.sunday)",
        "[dayofweek.monday](#const_dayofweek.monday)",
        "[dayofweek.tuesday](#const_dayofweek.tuesday)",
        "[dayofweek.thursday](#const_dayofweek.thursday)",
        "[dayofweek.friday](#const_dayofweek.friday)",
        "[dayofweek.saturday](#const_dayofweek.saturday)"
      ]
    },
    {
      "name": "dayofweek.thursday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.sunday](#const_dayofweek.sunday)",
        "[dayofweek.monday](#const_dayofweek.monday)",
        "[dayofweek.tuesday](#const_dayofweek.tuesday)",
        "[dayofweek.wednesday](#const_dayofweek.wednesday)",
        "[dayofweek.friday](#const_dayofweek.friday)",
        "[dayofweek.saturday](#const_dayofweek.saturday)"
      ]
    },
    {
      "name": "dayofweek.friday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.sunday](#const_dayofweek.sunday)",
        "[dayofweek.monday](#const_dayofweek.monday)",
        "[dayofweek.tuesday](#const_dayofweek.tuesday)",
        "[dayofweek.wednesday](#const_dayofweek.wednesday)",
        "[dayofweek.thursday](#const_dayofweek.thursday)",
        "[dayofweek.saturday](#const_dayofweek.saturday)"
      ]
    },
    {
      "name": "dayofweek.saturday",
      "type": "const int",
      "desc": [
        "Is a named constant for return value of [dayofweek](#fun_dayofweek) function and value of [dayofweek](#var_dayofweek) variable."
      ],
      "seeAlso": [
        "[dayofweek.sunday](#const_dayofweek.sunday)",
        "[dayofweek.monday](#const_dayofweek.monday)",
        "[dayofweek.tuesday](#const_dayofweek.tuesday)",
        "[dayofweek.wednesday](#const_dayofweek.wednesday)",
        "[dayofweek.thursday](#const_dayofweek.thursday)",
        "[dayofweek.friday](#const_dayofweek.friday)"
      ]
    },
    {
      "name": "shape.xcross",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.cross",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.circle",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.triangleup",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.triangledown",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.flag",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.arrowup",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.arrowdown",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.labelup",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.labeldown",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.square",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "shape.diamond",
      "type": "const string",
      "desc": ["Shape style for [plotshape](#fun_plotshape) function."],
      "seeAlso": ["[plotshape](#fun_plotshape)"]
    },
    {
      "name": "location.abovebar",
      "type": "const string",
      "desc": [
        "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. Shape is plotted above main series bars."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[location.belowbar](#const_location.belowbar)",
        "[location.top](#const_location.top)",
        "[location.bottom](#const_location.bottom)",
        "[location.absolute](#const_location.absolute)"
      ]
    },
    {
      "name": "location.belowbar",
      "type": "const string",
      "desc": [
        "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. Shape is plotted below main series bars."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[location.abovebar](#const_location.abovebar)",
        "[location.top](#const_location.top)",
        "[location.bottom](#const_location.bottom)",
        "[location.absolute](#const_location.absolute)"
      ]
    },
    {
      "name": "location.top",
      "type": "const string",
      "desc": [
        "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. Shape is plotted near the top chart border."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[location.abovebar](#const_location.abovebar)",
        "[location.belowbar](#const_location.belowbar)",
        "[location.bottom](#const_location.bottom)",
        "[location.absolute](#const_location.absolute)"
      ]
    },
    {
      "name": "location.bottom",
      "type": "const string",
      "desc": [
        "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. Shape is plotted near the bottom chart border."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[location.abovebar](#const_location.abovebar)",
        "[location.belowbar](#const_location.belowbar)",
        "[location.top](#const_location.top)",
        "[location.absolute](#const_location.absolute)"
      ]
    },
    {
      "name": "location.absolute",
      "type": "const string",
      "desc": [
        "Location value for [plotshape](#fun_plotshape), [plotchar](#fun_plotchar) functions. Shape is plotted on chart using indicator value as a price coordinate."
      ],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[location.abovebar](#const_location.abovebar)",
        "[location.belowbar](#const_location.belowbar)",
        "[location.top](#const_location.top)",
        "[location.bottom](#const_location.bottom)"
      ]
    },
    {
      "name": "scale.right",
      "type": "const scale_type",
      "desc": [
        "Scale value for [indicator](#fun_indicator) function. Indicator is added to the right price scale."
      ],
      "seeAlso": ["[indicator](#fun_indicator)"]
    },
    {
      "name": "scale.left",
      "type": "const scale_type",
      "desc": [
        "Scale value for [indicator](#fun_indicator) function. Indicator is added to the left price scale."
      ],
      "seeAlso": ["[indicator](#fun_indicator)"]
    },
    {
      "name": "scale.none",
      "type": "const scale_type",
      "desc": [
        "Scale value for [indicator](#fun_indicator) function. Indicator is added in 'No Scale' mode. Can be used only with 'overlay=true'."
      ],
      "seeAlso": ["[indicator](#fun_indicator)"]
    },
    {
      "name": "strategy.oca.none",
      "type": "const string",
      "desc": [
        "A named constant for use with the `oca_type` parameter of the [strategy.entry](#fun_strategy.entry) and [strategy.order](#fun_strategy.order) commands. It specifies that the order executes independently of all other orders, including those with the same `oca_name`."
      ],
      "seeAlso": [
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.exit](#fun_strategy.exit)",
        "[strategy.order](#fun_strategy.order)"
      ]
    },
    {
      "name": "strategy.oca.cancel",
      "type": "const string",
      "desc": [
        "A named constant for use with the `oca_type` parameter of the [strategy.entry](#fun_strategy.entry) and [strategy.order](#fun_strategy.order) commands. It specifies that the strategy cancels the unfilled order when another order with the same `oca_name` and `oca_type` executes."
      ],
      "remarks": [
        "Strategies cannot cancel or reduce pending orders from an OCA group if they execute on the same tick. For example, if the market price triggers two stop orders from [strategy.order](#fun_strategy.order) calls with the same `oca_*` arguments, the strategy cannot fully or partially cancel either one."
      ],
      "seeAlso": [
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.exit](#fun_strategy.exit)",
        "[strategy.order](#fun_strategy.order)"
      ]
    },
    {
      "name": "strategy.oca.reduce",
      "type": "const string",
      "desc": [
        "A named constant for use with the `oca_type` parameter of the [strategy.entry](#fun_strategy.entry) and [strategy.order](#fun_strategy.order) commands. It specifies that when another order with the same `oca_name` and `oca_type` executes, the strategy reduces the unfilled order by that order's size. If the unfilled order's size reaches 0 after reduction, it is the same as canceling the order entirely."
      ],
      "remarks": [
        "Strategies cannot cancel or reduce pending orders from an OCA group if they execute on the same tick. For example, if the market price triggers two stop orders from [strategy.order](#fun_strategy.order) calls with the same `oca_*` arguments, the strategy cannot fully or partially cancel either one.",
        "Orders from [strategy.exit](#fun_strategy.exit) automatically use this OCA type, and they belong to the same OCA group by default."
      ],
      "seeAlso": [
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.exit](#fun_strategy.exit)",
        "[strategy.order](#fun_strategy.order)"
      ]
    },
    {
      "name": "strategy.commission.percent",
      "type": "const string",
      "desc": ["Commission type for an order. A percentage of the cash volume of order."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.commission.cash_per_contract",
      "type": "const string",
      "desc": [
        "Commission type for an order. Money displayed in the account currency per contract."
      ],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.commission.cash_per_order",
      "type": "const string",
      "desc": ["Commission type for an order. Money displayed in the account currency per order."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.fixed",
      "type": "const string",
      "desc": [
        "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the [strategy](#fun_strategy) declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) function calls. It specifies that a number of contracts/shares/lots will be used to enter trades."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.fixed\", overlay = true, default_qty_value = 50, default_qty_type = strategy.fixed, initial_capital = 1000000)",
        "",
        "if bar_index == 0",
        "    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 contracts.",
        "    // qty = 50",
        "    strategy.entry(\"EN\", strategy.long)",
        "if bar_index == 2",
        "    strategy.close(\"EN\")"
      ],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.cash",
      "type": "const string",
      "desc": [
        "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the [strategy](#fun_strategy) declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) function calls. It specifies that an amount of cash in the `strategy.account_currency` will be used to enter trades."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.cash\", overlay = true, default_qty_value = 50, default_qty_type = strategy.cash, initial_capital = 1000000)",
        "",
        "if bar_index == 0",
        "    // As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 50 units of cash in the currency of `strategy.account_currency`.",
        "    // `qty` is calculated as (default_qty_value)/(close price). If current price is $5, then qty = 50/5 = 10.",
        "    strategy.entry(\"EN\", strategy.long)",
        "if bar_index == 2",
        "    strategy.close(\"EN\")"
      ],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.percent_of_equity",
      "type": "const string",
      "desc": [
        "This is one of the arguments that can be supplied to the `default_qty_type` parameter in the [strategy](#fun_strategy) declaration statement. It is only relevant when no value is used for the ‘qty’ parameter in [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) function calls. It specifies that a percentage (0-100) of equity will be used to enter trades."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.percent_of_equity\", overlay = false, default_qty_value = 100, default_qty_type = strategy.percent_of_equity, initial_capital = 1000000)",
        "",
        "// As ‘qty’ is not defined, the previously defined values for the `default_qty_type` and `default_qty_value` parameters are used to enter trades, namely 100% of available equity.",
        "if bar_index == 0",
        "    strategy.entry(\"EN\", strategy.long)",
        "if bar_index == 2",
        "    strategy.close(\"EN\")",
        "plot(strategy.equity)",
        "",
        " // The ‘qty’ parameter is set to 10. Entering position with fixed size of 10 contracts and entry market price = (10 * close).",
        "if bar_index == 4",
        "    strategy.entry(\"EN\", strategy.long, qty = 10)",
        "if bar_index == 6",
        "    strategy.close(\"EN\")"
      ],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "strategy.direction.all",
      "type": "const string",
      "desc": ["It allows strategy to open both long and short positions."],
      "seeAlso": ["[strategy.risk.allow_entry_in](#fun_strategy.risk.allow_entry_in)"]
    },
    {
      "name": "strategy.direction.long",
      "type": "const string",
      "desc": ["It allows strategy to open only long positions."],
      "seeAlso": ["[strategy.risk.allow_entry_in](#fun_strategy.risk.allow_entry_in)"]
    },
    {
      "name": "strategy.direction.short",
      "type": "const string",
      "desc": ["It allows strategy to open only short positions."],
      "seeAlso": ["[strategy.risk.allow_entry_in](#fun_strategy.risk.allow_entry_in)"]
    },
    {
      "name": "currency.NONE",
      "type": "const string",
      "desc": ["Unspecified currency."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.USD",
      "type": "const string",
      "desc": ["United States dollar."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.EUR",
      "type": "const string",
      "desc": ["Euro."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.AUD",
      "type": "const string",
      "desc": ["Australian dollar."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.GBP",
      "type": "const string",
      "desc": ["Pound sterling."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.NZD",
      "type": "const string",
      "desc": ["New Zealand dollar."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.CAD",
      "type": "const string",
      "desc": ["Canadian dollar."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.CHF",
      "type": "const string",
      "desc": ["Swiss franc."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.HKD",
      "type": "const string",
      "desc": ["Hong Kong dollar."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.JPY",
      "type": "const string",
      "desc": ["Japanese yen."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.NOK",
      "type": "const string",
      "desc": ["Norwegian krone."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.SEK",
      "type": "const string",
      "desc": ["Swedish krona."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.SGD",
      "type": "const string",
      "desc": ["Singapore dollar."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.TRY",
      "type": "const string",
      "desc": ["Turkish lira."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.ZAR",
      "type": "const string",
      "desc": ["South African rand."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.RUB",
      "type": "const string",
      "desc": ["Russian ruble."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.BTC",
      "type": "const string",
      "desc": ["Bitcoin."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.ETH",
      "type": "const string",
      "desc": ["Ethereum."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.MYR",
      "type": "const string",
      "desc": ["Malaysian ringgit."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.KRW",
      "type": "const string",
      "desc": ["South Korean won."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.USDT",
      "type": "const string",
      "desc": ["Tether."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "currency.INR",
      "type": "const string",
      "desc": ["Indian rupee."],
      "seeAlso": ["[strategy](#fun_strategy)"]
    },
    {
      "name": "barmerge.lookahead_off",
      "type": "const barmerge_lookahead",
      "desc": [
        "Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their close time. This merge strategy disables effect of getting data from \"future\" on calculation on history."
      ],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[barmerge.lookahead_on](#const_barmerge.lookahead_on)"
      ]
    },
    {
      "name": "barmerge.lookahead_on",
      "type": "const barmerge_lookahead",
      "desc": [
        "Merge strategy for the requested data position. Requested barset is merged with current barset in the order of sorting bars by their opening time. This merge strategy can lead to undesirable effect of getting data from \"future\" on calculation on history. This is unacceptable in backtesting strategies, but can be useful in indicators."
      ],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[barmerge.lookahead_off](#const_barmerge.lookahead_off)"
      ]
    },
    {
      "name": "barmerge.gaps_off",
      "type": "const barmerge_gaps",
      "desc": [
        "Merge strategy for requested data. Data is merged continuously without gaps, all the gaps are filled with the previous nearest existing value."
      ],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[barmerge.gaps_on](#const_barmerge.gaps_on)"
      ]
    },
    {
      "name": "barmerge.gaps_on",
      "type": "const barmerge_gaps",
      "desc": [
        "Merge strategy for requested data. Data is merged with possible gaps ([na](#var_na) values)."
      ],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[barmerge.gaps_off](#const_barmerge.gaps_off)"
      ]
    },
    {
      "name": "xloc.bar_index",
      "type": "const string",
      "desc": [
        "A constant that specifies how functions that create and modify Pine drawings interpret x-coordinates. If `xloc = xloc.bar_index`, the drawing object treats each x-coordinate as a `bar_index` value."
      ],
      "seeAlso": [
        "[xloc.bar_time](#const_xloc.bar_time)",
        "[line.new](#fun_line.new)",
        "[label.new](#fun_label.new)",
        "[box.new](#fun_box.new)",
        "[polyline.new](#fun_polyline.new)",
        "[line.set_xloc](#fun_line.set_xloc)",
        "[label.set_xloc](#fun_label.set_xloc)"
      ]
    },
    {
      "name": "xloc.bar_time",
      "type": "const string",
      "desc": [
        "A constant that specifies how functions that create and modify Pine drawings interpret x-coordinates. If `xloc = xloc.bar_time`, the drawing object treats each x-coordinate as a UNIX timestamp, expressed in milliseconds."
      ],
      "seeAlso": [
        "[xloc.bar_index](#const_xloc.bar_index)",
        "[line.new](#fun_line.new)",
        "[label.new](#fun_label.new)",
        "[box.new](#fun_box.new)",
        "[polyline.new](#fun_polyline.new)",
        "[line.set_xloc](#fun_line.set_xloc)",
        "[label.set_xloc](#fun_label.set_xloc)",
        "[xloc.bar_index](#const_xloc.bar_index)"
      ]
    },
    {
      "name": "yloc.price",
      "type": "const string",
      "desc": [
        "A named constant that specifies the algorithm of interpretation of y-value in function [label.new](#fun_label.new)."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_yloc](#fun_label.set_yloc)",
        "[yloc.abovebar](#const_yloc.abovebar)",
        "[yloc.belowbar](#const_yloc.belowbar)"
      ]
    },
    {
      "name": "yloc.abovebar",
      "type": "const string",
      "desc": [
        "A named constant that specifies the algorithm of interpretation of y-value in function [label.new](#fun_label.new)."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_yloc](#fun_label.set_yloc)",
        "[yloc.price](#const_yloc.price)",
        "[yloc.belowbar](#const_yloc.belowbar)"
      ]
    },
    {
      "name": "yloc.belowbar",
      "type": "const string",
      "desc": [
        "A named constant that specifies the algorithm of interpretation of y-value in function [label.new](#fun_label.new)."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_yloc](#fun_label.set_yloc)",
        "[yloc.price](#const_yloc.price)",
        "[yloc.abovebar](#const_yloc.abovebar)"
      ]
    },
    {
      "name": "extend.none",
      "type": "const string",
      "desc": [
        "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_extend](#fun_line.set_extend)",
        "[extend.left](#const_extend.left)",
        "[extend.right](#const_extend.right)",
        "[extend.both](#const_extend.both)"
      ]
    },
    {
      "name": "extend.left",
      "type": "const string",
      "desc": [
        "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_extend](#fun_line.set_extend)",
        "[extend.none](#const_extend.none)",
        "[extend.right](#const_extend.right)",
        "[extend.both](#const_extend.both)"
      ]
    },
    {
      "name": "extend.right",
      "type": "const string",
      "desc": [
        "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_extend](#fun_line.set_extend)",
        "[extend.none](#const_extend.none)",
        "[extend.left](#const_extend.left)",
        "[extend.both](#const_extend.both)"
      ]
    },
    {
      "name": "extend.both",
      "type": "const string",
      "desc": [
        "A named constant for [line.new](#fun_line.new) and [line.set_extend](#fun_line.set_extend) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_extend](#fun_line.set_extend)",
        "[extend.none](#const_extend.none)",
        "[extend.left](#const_extend.left)",
        "[extend.right](#const_extend.right)"
      ]
    },
    {
      "name": "label.style_none",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_xcross",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_cross",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_triangleup",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_triangledown",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_flag",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_circle",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_arrowup",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_arrowdown",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_up",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_down",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_left",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_right",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_lower_left",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_lower_right",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_upper_left",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_upper_right",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_label_center",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_square",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "label.style_diamond",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)"
      ]
    },
    {
      "name": "label.style_text_outline",
      "type": "const string",
      "desc": [
        "Label style for [label.new](#fun_label.new) and [label.set_style](#fun_label.set_style) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.style_none](#const_label.style_none)",
        "[label.style_xcross](#const_label.style_xcross)",
        "[label.style_cross](#const_label.style_cross)",
        "[label.style_triangleup](#const_label.style_triangleup)",
        "[label.style_triangledown](#const_label.style_triangledown)",
        "[label.style_flag](#const_label.style_flag)",
        "[label.style_circle](#const_label.style_circle)",
        "[label.style_arrowup](#const_label.style_arrowup)",
        "[label.style_arrowdown](#const_label.style_arrowdown)",
        "[label.style_label_up](#const_label.style_label_up)",
        "[label.style_label_down](#const_label.style_label_down)",
        "[label.style_label_left](#const_label.style_label_left)",
        "[label.style_label_right](#const_label.style_label_right)",
        "[label.style_label_lower_left](#const_label.style_label_lower_left)",
        "[label.style_label_lower_right](#const_label.style_label_lower_right)",
        "[label.style_label_upper_left](#const_label.style_label_upper_left)",
        "[label.style_label_upper_right](#const_label.style_label_upper_right)",
        "[label.style_label_center](#const_label.style_label_center)",
        "[label.style_square](#const_label.style_square)",
        "[label.style_diamond](#const_label.style_diamond)"
      ]
    },
    {
      "name": "display.none",
      "type": "const plot_simple_display",
      "desc": [
        "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. `plot*()` functions using this will not display their plotted values anywhere. However, alert template messages and [fill](#fun_fill) functions can still use the values, and they will appear in exported chart data. `input*()` functions using this constant will only display their values within the script's settings."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[plotbar](#fun_plotbar)",
        "[plotcandle](#fun_plotcandle)"
      ]
    },
    {
      "name": "display.pane",
      "type": "const plot_display",
      "desc": [
        "A named constant for use with the `display` parameter of `plot*()` functions. Displays plotted values in the chart pane used by the script."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[plotbar](#fun_plotbar)",
        "[plotcandle](#fun_plotcandle)"
      ]
    },
    {
      "name": "display.data_window",
      "type": "const plot_display",
      "desc": [
        "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. Displays plotted or input values in the Data Window, a menu accessible from the chart's right sidebar."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[plotbar](#fun_plotbar)",
        "[plotcandle](#fun_plotcandle)"
      ]
    },
    {
      "name": "display.price_scale",
      "type": "const plot_display",
      "desc": [
        "A named constant for use with the `display` parameter of `plot*()` functions. Displays the plot’s label and value on the price scale if the chart's settings allow it."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[plotbar](#fun_plotbar)",
        "[plotcandle](#fun_plotcandle)"
      ]
    },
    {
      "name": "display.status_line",
      "type": "const plot_display",
      "desc": [
        "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. Displays plotted or input values in the status line next to the script's name on the chart if the chart's settings allow it."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[plotbar](#fun_plotbar)",
        "[plotcandle](#fun_plotcandle)"
      ]
    },
    {
      "name": "display.all",
      "type": "const plot_simple_display",
      "desc": [
        "A named constant for use with the `display` parameter of `plot*()` and `input*()` functions. Displays plotted or input values in all possible locations."
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[plotbar](#fun_plotbar)",
        "[plotcandle](#fun_plotcandle)"
      ]
    },
    {
      "name": "text.format_none",
      "type": "const text_format",
      "desc": [
        "A named constant for use with the `text_formatting` parameter of the `label.new()`, `box.new()`, `table.cell()`, and `*set_text_formatting()` functions. Signifies no special text formatting."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[box.new](#fun_box.new)",
        "[table.cell](#fun_table.cell)"
      ]
    },
    {
      "name": "text.format_bold",
      "type": "const text_format",
      "desc": [
        "A named constant for use with the `text_formatting` parameter of the `label.new()`, `box.new()`, `table.cell()`, and `*set_text_formatting()` functions. Makes the text bold."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[box.new](#fun_box.new)",
        "[table.cell](#fun_table.cell)"
      ]
    },
    {
      "name": "text.format_italic",
      "type": "const text_format",
      "desc": [
        "A named constant for use with the `text_formatting` parameter of the `label.new()`, `box.new()`, `table.cell()`, and `*set_text_formatting()` functions. Italicizes the text."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[box.new](#fun_box.new)",
        "[table.cell](#fun_table.cell)"
      ]
    },
    {
      "name": "line.style_solid",
      "type": "const string",
      "desc": [
        "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_style](#fun_line.set_style)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_right](#const_line.style_arrow_right)",
        "[line.style_arrow_both](#const_line.style_arrow_both)"
      ]
    },
    {
      "name": "line.style_dotted",
      "type": "const string",
      "desc": [
        "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_style](#fun_line.set_style)",
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_right](#const_line.style_arrow_right)",
        "[line.style_arrow_both](#const_line.style_arrow_both)"
      ]
    },
    {
      "name": "line.style_dashed",
      "type": "const string",
      "desc": [
        "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_style](#fun_line.set_style)",
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_right](#const_line.style_arrow_right)",
        "[line.style_arrow_both](#const_line.style_arrow_both)"
      ]
    },
    {
      "name": "line.style_arrow_left",
      "type": "const string",
      "desc": [
        "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions. Solid line with arrow on the first point."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_style](#fun_line.set_style)",
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_right](#const_line.style_arrow_right)",
        "[line.style_arrow_both](#const_line.style_arrow_both)"
      ]
    },
    {
      "name": "line.style_arrow_right",
      "type": "const string",
      "desc": [
        "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions. Solid line with arrow on the second point."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_style](#fun_line.set_style)",
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_both](#const_line.style_arrow_both)"
      ]
    },
    {
      "name": "line.style_arrow_both",
      "type": "const string",
      "desc": [
        "Line style for [line.new](#fun_line.new) and [line.set_style](#fun_line.set_style) functions. Solid line with arrows on both points."
      ],
      "seeAlso": [
        "[line.new](#fun_line.new)",
        "[line.set_style](#fun_line.set_style)",
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_right](#const_line.style_arrow_right)"
      ]
    },
    {
      "name": "text.align_center",
      "type": "const string",
      "desc": [
        "Text alignment for [box.new](#fun_box.new), [box.set_text_halign](#fun_box.set_text_halign), [box.set_text_valign](#fun_box.set_text_valign), [label.new](#fun_label.new) and [label.set_textalign](#fun_label.set_textalign) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[text.align_left](#const_text.align_left)",
        "[text.align_right](#const_text.align_right)."
      ]
    },
    {
      "name": "text.align_left",
      "type": "const string",
      "desc": [
        "Horizontal text alignment for [box.new](#fun_box.new), [box.set_text_halign](#fun_box.set_text_halign), [label.new](#fun_label.new) and [label.set_textalign](#fun_label.set_textalign) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[text.align_center](#const_text.align_center)",
        "[text.align_right](#const_text.align_right)."
      ]
    },
    {
      "name": "text.align_right",
      "type": "const string",
      "desc": [
        "Horizontal text alignment for [box.new](#fun_box.new), [box.set_text_halign](#fun_box.set_text_halign), [label.new](#fun_label.new) and [label.set_textalign](#fun_label.set_textalign) functions."
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_style](#fun_label.set_style)",
        "[text.align_center](#const_text.align_center)",
        "[text.align_left](#const_text.align_left)."
      ]
    },
    {
      "name": "text.align_top",
      "type": "const string",
      "desc": [
        "Vertical text alignment for [box.new](#fun_box.new), [box.set_text_valign](#fun_box.set_text_valign), [table.cell](#fun_table.cell) and [table.cell_set_text_valign](#fun_table.cell_set_text_valign) functions."
      ],
      "seeAlso": [
        "[table.cell](#fun_table.cell)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[text.align_center](#const_text.align_center)",
        "[text.align_left](#const_text.align_left)",
        "[text.align_right](#const_text.align_right)."
      ]
    },
    {
      "name": "text.align_bottom",
      "type": "const string",
      "desc": [
        "Vertical text alignment for [box.new](#fun_box.new), [box.set_text_valign](#fun_box.set_text_valign), [table.cell](#fun_table.cell) and [table.cell_set_text_valign](#fun_table.cell_set_text_valign) functions."
      ],
      "seeAlso": [
        "[table.cell](#fun_table.cell)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[text.align_center](#const_text.align_center)",
        "[text.align_left](#const_text.align_left)",
        "[text.align_right](#const_text.align_right)."
      ]
    },
    {
      "name": "font.family_default",
      "type": "const string",
      "desc": [
        "Default text font for [box.new](#fun_box.new), [box.set_text_font_family](#fun_box.set_text_font_family), [label.new](#fun_label.new), [label.set_text_font_family](#fun_label.set_text_font_family), [table.cell](#fun_table.cell) and [table.cell_set_text_font_family](#fun_table.cell_set_text_font_family) functions."
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.set_text_font_family](#fun_box.set_text_font_family)",
        "[label.new](#fun_label.new)",
        "[label.set_text_font_family](#fun_label.set_text_font_family)",
        "[table.cell](#fun_table.cell)",
        "[table.cell_set_text_font_family](#fun_table.cell_set_text_font_family)",
        "[font.family_monospace](#const_font.family_monospace)"
      ]
    },
    {
      "name": "font.family_monospace",
      "type": "const string",
      "desc": [
        "Monospace text font for [box.new](#fun_box.new), [box.set_text_font_family](#fun_box.set_text_font_family), [label.new](#fun_label.new), [label.set_text_font_family](#fun_label.set_text_font_family), [table.cell](#fun_table.cell) and [table.cell_set_text_font_family](#fun_table.cell_set_text_font_family) functions."
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.set_text_font_family](#fun_box.set_text_font_family)",
        "[label.new](#fun_label.new)",
        "[label.set_text_font_family](#fun_label.set_text_font_family)",
        "[table.cell](#fun_table.cell)",
        "[table.cell_set_text_font_family](#fun_table.cell_set_text_font_family)",
        "[font.family_default](#const_font.family_default)"
      ]
    },
    {
      "name": "text.wrap_auto",
      "type": "const string",
      "desc": [
        "Automatic wrapping mode for [box.new](#fun_box.new) and [box.set_text_wrap](#fun_box.set_text_wrap) functions."
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_wrap](#fun_box.set_text_wrap)"
      ]
    },
    {
      "name": "text.wrap_none",
      "type": "const string",
      "desc": [
        "Disabled wrapping mode for [box.new](#fun_box.new) and [box.set_text_wrap](#fun_box.set_text_wrap) functions."
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_wrap](#fun_box.set_text_wrap)"
      ]
    },
    {
      "name": "order.ascending",
      "type": "const sort_order",
      "desc": ["Determines the sort order of the array from the smallest to the largest value."],
      "seeAlso": ["[array.new_float](#fun_array.new_float)", "[array.sort](#fun_array.sort)."]
    },
    {
      "name": "order.descending",
      "type": "const sort_order",
      "desc": ["Determines the sort order of the array from the largest to the smallest value."],
      "seeAlso": ["[array.new_float](#fun_array.new_float)", "[array.sort](#fun_array.sort)."]
    },
    {
      "name": "alert.freq_all",
      "type": "const string",
      "desc": [
        "A named constant for use with the `freq` parameter of the alert() function.",
        "All function calls trigger the alert."
      ],
      "seeAlso": ["[alert](#fun_alert)."]
    },
    {
      "name": "alert.freq_once_per_bar",
      "type": "const string",
      "desc": [
        "A named constant for use with the `freq` parameter of the alert() function.",
        "The first function call during the bar triggers the alert."
      ],
      "seeAlso": ["[alert](#fun_alert)."]
    },
    {
      "name": "alert.freq_once_per_bar_close",
      "type": "const string",
      "desc": [
        "A named constant for use with the `freq` parameter of the alert() function.",
        "The function call triggers the alert only when it occurs during the last script iteration of the real-time bar, when it closes."
      ],
      "seeAlso": ["[alert](#fun_alert)."]
    },
    {
      "name": "earnings.actual",
      "type": "const string",
      "desc": [
        "A named constant for the [request.earnings](#fun_request.earnings) function. Is used to request the earnings value as it was reported."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "earnings.estimate",
      "type": "const string",
      "desc": [
        "A named constant for the [request.earnings](#fun_request.earnings) function. Is used to request the estimated earnings value."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "earnings.standardized",
      "type": "const string",
      "desc": [
        "A named constant for the [request.earnings](#fun_request.earnings) function. Is used to request the standardized earnings value."
      ],
      "seeAlso": ["[request.earnings](#fun_request.earnings)."]
    },
    {
      "name": "dividends.net",
      "type": "const string",
      "desc": [
        "A named constant for the [request.dividends](#fun_request.dividends) function. Is used to request the dividends return on a stock after deductions."
      ],
      "seeAlso": ["[request.dividends](#fun_request.dividends)."]
    },
    {
      "name": "dividends.gross",
      "type": "const string",
      "desc": [
        "A named constant for the [request.dividends](#fun_request.dividends) function. Is used to request the dividends return on a stock before deductions."
      ],
      "seeAlso": ["[request.dividends](#fun_request.dividends)."]
    },
    {
      "name": "splits.denominator",
      "type": "const string",
      "desc": [
        "A named constant for the [request.splits](#fun_request.splits) function. Is used to request the denominator (the number below the line in a fraction) of a splits."
      ],
      "seeAlso": ["[request.splits](#fun_request.splits)."]
    },
    {
      "name": "splits.numerator",
      "type": "const string",
      "desc": [
        "A named constant for the [request.splits](#fun_request.splits) function. Is used to request the numerator (the number above the line in a fraction) of a splits."
      ],
      "seeAlso": ["[request.splits](#fun_request.splits)."]
    },
    {
      "name": "true",
      "desc": [
        "Literal representing one of the values a [bool](#type_bool) variable can hold, or an expression can evaluate to when it uses comparison or logical operators."
      ],
      "remarks": [
        "See the User Manual for [comparison operators](https://www.tradingview.com/pine-script-docs/language/operators/#comparison-operators) and [logical operators](https://www.tradingview.com/pine-script-docs/language/operators/#logical-operators)."
      ],
      "seeAlso": ["[bool](#type_bool)"]
    },
    {
      "name": "false",
      "desc": [
        "Literal representing a [bool](#type_bool) value, and result of a comparison operation."
      ],
      "remarks": [
        "See the User Manual for [comparison operators](https://www.tradingview.com/pine-script-docs/language/operators/#comparison-operators) and [logical operators](https://www.tradingview.com/pine-script-docs/language/operators/#logical-operators)."
      ],
      "seeAlso": ["[bool](#type_bool)"]
    },
    {
      "name": "strategy.long",
      "type": "const strategy_direction",
      "desc": [
        "A named constant for use with the `direction` parameter of the [strategy.entry](#fun_strategy.entry) and [strategy.order](#fun_strategy.order) commands. It specifies that the command creates a buy order."
      ],
      "seeAlso": [
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.exit](#fun_strategy.exit)",
        "[strategy.order](#fun_strategy.order)"
      ]
    },
    {
      "name": "strategy.short",
      "type": "const strategy_direction",
      "desc": [
        "A named constant for use with the `direction` parameter of the [strategy.entry](#fun_strategy.entry) and [strategy.order](#fun_strategy.order) commands. It specifies that the command creates a sell order."
      ],
      "seeAlso": [
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.exit](#fun_strategy.exit)",
        "[strategy.order](#fun_strategy.order)"
      ]
    },
    {
      "name": "settlement_as_close.inherit",
      "type": "const settlement",
      "desc": [
        "A constant to specify the value of the `settlement_as_close` parameter in [ticker.new](#fun_ticker.new) and [ticker.modify](#fun_ticker.modify) functions."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[settlement_as_close.on](#const_settlement_as_close.on)",
        "[settlement_as_close.off](#const_settlement_as_close.off)"
      ]
    },
    {
      "name": "settlement_as_close.on",
      "type": "const settlement",
      "desc": [
        "A constant to specify the value of the `settlement_as_close` parameter in [ticker.new](#fun_ticker.new) and [ticker.modify](#fun_ticker.modify) functions."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
        "[settlement_as_close.off](#const_settlement_as_close.off)"
      ]
    },
    {
      "name": "settlement_as_close.off",
      "type": "const settlement",
      "desc": [
        "A constant to specify the value of the `settlement_as_close` parameter in [ticker.new](#fun_ticker.new) and [ticker.modify](#fun_ticker.modify) functions."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[settlement_as_close.on](#const_settlement_as_close.on)",
        "[settlement_as_close.inherit](#const_settlement_as_close.inherit)"
      ]
    },
    {
      "name": "backadjustment.inherit",
      "type": "const backadjustment",
      "desc": [
        "A constant to specify the value of the `backadjustment` parameter in [ticker.new](#fun_ticker.new) and [ticker.modify](#fun_ticker.modify) functions."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[backadjustment.on](#const_backadjustment.on)",
        "[backadjustment.off](#const_backadjustment.off)"
      ]
    },
    {
      "name": "backadjustment.on",
      "type": "const backadjustment",
      "desc": [
        "A constant to specify the value of the `backadjustment` parameter in [ticker.new](#fun_ticker.new) and [ticker.modify](#fun_ticker.modify) functions."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[backadjustment.inherit](#const_backadjustment.inherit)",
        "[backadjustment.off](#const_backadjustment.off)"
      ]
    },
    {
      "name": "backadjustment.off",
      "type": "const backadjustment",
      "desc": [
        "A constant to specify the value of the `backadjustment` parameter in [ticker.new](#fun_ticker.new) and [ticker.modify](#fun_ticker.modify) functions."
      ],
      "seeAlso": [
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[backadjustment.on](#const_backadjustment.on)",
        "[backadjustment.inherit](#const_backadjustment.inherit)"
      ]
    },
    {
      "name": "color.black",
      "type": "const color",
      "color": "#363A45",
      "desc": ["Is a named constant for #363A45 color."],
      "seeAlso": [
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.silver",
      "type": "const color",
      "color": "#B2B5BE",
      "desc": ["Is a named constant for #B2B5BE color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.gray",
      "type": "const color",
      "color": "#787B86",
      "desc": ["Is a named constant for #787B86 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.white",
      "type": "const color",
      "color": "#FFFFFF",
      "desc": ["Is a named constant for #FFFFFF color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.maroon",
      "type": "const color",
      "color": "#880E4F",
      "desc": ["Is a named constant for #880E4F color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.red",
      "type": "const color",
      "color": "#F23645",
      "desc": ["Is a named constant for #F23645 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.purple",
      "type": "const color",
      "color": "#9C27B0",
      "desc": ["Is a named constant for #9C27B0 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.fuchsia",
      "type": "const color",
      "color": "#E040FB",
      "desc": ["Is a named constant for #E040FB color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.green",
      "type": "const color",
      "color": "#4CAF50",
      "desc": ["Is a named constant for #4CAF50 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.lime",
      "type": "const color",
      "color": "#00E676",
      "desc": ["Is a named constant for #00E676 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.olive",
      "type": "const color",
      "color": "#808000",
      "desc": ["Is a named constant for #808000 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.yellow",
      "type": "const color",
      "color": "#FDD835",
      "desc": ["Is a named constant for #FDD835 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.navy",
      "type": "const color",
      "color": "#311B92",
      "desc": ["Is a named constant for #311B92 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.blue",
      "type": "const color",
      "color": "#2962ff",
      "desc": ["Is a named constant for #2962ff color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.teal",
      "type": "const color",
      "color": "#089981",
      "desc": ["Is a named constant for #089981 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.aqua](#const_color.aqua)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.aqua",
      "type": "const color",
      "color": "#00BCD4",
      "desc": ["Is a named constant for #00BCD4 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.orange](#const_color.orange)"
      ]
    },
    {
      "name": "color.orange",
      "type": "const color",
      "color": "#FF9800",
      "desc": ["Is a named constant for #FF9800 color."],
      "seeAlso": [
        "[color.black](#const_color.black)",
        "[color.silver](#const_color.silver)",
        "[color.gray](#const_color.gray)",
        "[color.white](#const_color.white)",
        "[color.maroon](#const_color.maroon)",
        "[color.red](#const_color.red)",
        "[color.purple](#const_color.purple)",
        "[color.fuchsia](#const_color.fuchsia)",
        "[color.green](#const_color.green)",
        "[color.lime](#const_color.lime)",
        "[color.olive](#const_color.olive)",
        "[color.yellow](#const_color.yellow)",
        "[color.navy](#const_color.navy)",
        "[color.blue](#const_color.blue)",
        "[color.teal](#const_color.teal)",
        "[color.aqua](#const_color.aqua)"
      ]
    }
  ],
  "types": [
    {
      "name": "simple",
      "desc": [
        "The `simple` keyword explicitly assigns the \"simple\" type qualifier to variables and function parameters. Variables and parameters that use the \"simple\" qualifier can reference values established at the beginning of a script's execution that do not change later.",
        "To restrict the parameters in a library's exported functions to only allow values with a \"simple\" or weaker type qualifier, using the `simple` keyword when declaring parameters is often necessary, as libraries automatically qualify all parameters as \"series\" wherever possible by default. Explicitly restricting functions to accept \"simple\" arguments also allows them to return \"simple\" values in some cases, depending on the operations they execute, making them usable with the parameters of built-in functions that do not allow \"series\" arguments.",
        "In variable declarations, the compiler can usually infer the qualified type automatically based on the values assigned to a variable, and it can automatically change a variable's qualifier to a stronger one when necessary. The type qualifier hierarchy is \"const\" < \"input\" < \"simple\" < \"series\", where \"simple\" is stronger than \"input\" and \"const\".",
        "Explicitly declaring a variable with the `simple` keyword restricts the type qualifier to \"simple\", meaning the script cannot pass its value to any variable or function parameter that requires a value with a weaker qualifier (\"const\" or \"input\"). Additionally, one cannot assign a \"series\" value to a variable explicitly declared with the `simple` keyword.",
        "When using this keyword to specify the type qualifier, one must also use a type keyword to declare the allowed type."
      ],
      "syntax": [
        "export [method ]<functionName>([[simple ]<paramType>] <paramName>[ = <defaultValue>])\n\n[method ]<functionName>([simple <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]simple <variableType> <variableName> = <variableValue></variableValue>"
      ],
      "examples": [
        "//@version=6",
        "//@description A library with custom functions.",
        "library(\"CustomFunctions\", overlay = true)",
        "",
        "//@function         Calculates the length values for a ribbon of four EMAs by multiplying the `baseLength`.",
        "//@param baseLength The initial EMA length. Requires \"simple int\" because you can't use \"series int\" in `ta.ema()`.",
        "//@returns          A tuple of length values.",
        "export ribbonLengths(simple int baseLength) =>",
        "    simple int length1 = baseLength",
        "    simple int length2 = baseLength * 2",
        "    simple int length3 = baseLength * 3",
        "    simple int length4 = baseLength * 4",
        "    [length1, length2, length3, length4]",
        "",
        "// Get a tuple of \"simple int\" length values.",
        "[len1, len2, len3, len4] = ribbonLengths(14)",
        "",
        "// Plot four EMAs using the values from the tuple.",
        "plot(ta.ema(close, len1), \"EMA 1\", color = color.red)",
        "plot(ta.ema(close, len2), \"EMA 1\", color = color.orange)",
        "plot(ta.ema(close, len3), \"EMA 1\", color = color.green)",
        "plot(ta.ema(close, len4), \"EMA 1\", color = color.blue)"
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"can't change simple to series\")",
            "",
            "//@variable A variable declared as \"simple float\" with a value of 5.0.",
            "simple float myVar = 5.0",
            "",
            "// This reassignment causes an error.",
            "// The `close` variable returns a \"series float\" value. Since `myVar` is restricted to \"simple\" values, it cannot",
            "// change its qualifier to \"series\".",
            "myVar := close",
            "",
            "plot(myVar)"
          ]
        }
      ],
      "remarks": [
        "To learn more, see our User Manual's section on [type qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)."
      ],
      "seeAlso": ["[series](#type_series)", "[const](#type_const)"]
    },
    {
      "name": "series",
      "desc": [
        "The `series` keyword explicitly assigns the \"series\" type qualifier to variables and function parameters. Variables and parameters that use the \"series\" qualifier can reference values that change throughout a script's execution.",
        "Explicit use of the `series` keyword when declaring the parameters of a library's exported functions is typically unnecessary, as the compiler can usually automatically detect whether a parameter is compatible with \"series\" or \"simple\" qualified values. By default, all exported function parameters are qualified as \"series\" wherever possible.",
        "In variable declarations, the compiler can usually infer the qualified type automatically based on the values assigned to a variable, and it can automatically change a variable's qualifier to a stronger one when necessary. The type qualifier hierarchy is \"const\" < \"input\" < \"simple\" < \"series\", where \"series\" is the strongest.",
        "Explicitly declaring a variable with the `series` keyword restricts the type qualifier to \"series\", meaning the script cannot pass its value to any variable or function parameter that requires a value with a weaker qualifier (\"const\", \"input\", or \"simple\").",
        "When using this keyword to specify the type qualifier, one must also use a type keyword to declare the allowed type."
      ],
      "syntax": [
        "export [method ]<functionName>([[series ]<paramType>] <paramName>[ = <defaultValue>])\n\n[method ]<functionName>([series <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]series <variableType> <variableName> = <variableValue>"
      ],
      "examples": [
        "//@version=6",
        "//@description A library with custom functions.",
        "library(\"CustomFunctions\", overlay = true)",
        "",
        "//@function Finds the highest `source` value over `length` bars, filtered by the `cond` condition.",
        "export conditionalHighest(series float source, series bool cond, series int length) =>",
        "    //@variable The highest `source` value from when the `cond` was `true` over `length` bars.",
        "    series float result = na",
        "    // Loop to find the highest value.",
        "    for i = 0 to length - 1",
        "        if cond[i]",
        "            value   = source[i]",
        "            result := math.max(nz(result, value), value)",
        "    // Return the `result`.",
        "    result",
        "",
        "//@variable Is `true` once every five bars.",
        "series bool condition = bar_index % 5 == 0",
        "",
        "//@variable The highest `close` value from every fifth bar over the last 100 bars.",
        "series float hiValue = conditionalHighest(close, condition, 100)",
        "",
        "plot(hiValue)",
        "bgcolor(condition ? color.new(color.teal, 80) : na)"
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"series variable not allowed\")",
            "",
            "//@variable A variable declared as \"series int\" with a value of 5.",
            "series int myVar = 5",
            "",
            "// This call causes an error.",
            "// The `histbase` accepts \"input int/float\". It can't accept the stronger \"series int\" qualified type.",
            "plot(close, style = plot.style_histogram, histbase = myVar)"
          ]
        }
      ],
      "remarks": [
        "To learn more, see our User Manual's section on [type qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)."
      ],
      "seeAlso": ["[simple](#type_simple)", "[const](#type_const)"]
    },
    {
      "name": "const",
      "desc": [
        "The `const` keyword explicitly assigns the \"const\" type qualifier to variables and the parameters of non-exported functions. Variables and parameters with the \"const\" qualifier reference values established at compile time that never change in the script's execution.",
        "In variable declarations, the compiler can usually infer the qualified type automatically based on the values assigned to a variable, and it can automatically change a variable's qualifier to a stronger one when necessary. The type qualifier hierarchy is \"const\" < \"input\" < \"simple\" < \"series\", where \"const\" is the weakest.",
        "Explicitly declaring a variable with the `const` keyword restricts the type qualifier to \"const\", meaning the variable cannot accept a value with a stronger qualifier (e.g., \"input\"), nor can the value assigned to the variable change at any point in the script's execution.",
        "When using this keyword to specify the type qualifier, one must also use a type keyword to declare the allowed type."
      ],
      "syntax": [
        "[method ]<functionName>([const <paramType> ]<paramName>[ = <defaultValue>])\n\n[var/varip ]const <variableType> <variableName> = <variableValue>"
      ],
      "examples": [
        "//@version=6",
        "indicator(\"custom plot title\")",
        "",
        "//@function Concatenates two \"const string\" values.",
        "concatStrings(const string x, const string y) =>",
        "    const string result = x + y",
        "",
        "//@variable The title of the plot.",
        "const string myTitle = concatStrings(\"My \", \"Plot\")",
        "",
        "plot(close, myTitle)"
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"can't assign input to const\")",
            "",
            "//@variable A variable declared as \"const float\" that attempts to assign the result of `input.float()` as its value.",
            "//          This declaration causes an error. The \"input float\" qualified type is stronger than \"const float\".",
            "const float myVar = input.float(2.0)",
            "",
            "plot(myVar)"
          ]
        }
      ],
      "remarks": [
        "To learn more, see our User Manual's section on [type qualifiers](https://www.tradingview.com/pine-script-docs/language/type-system/#qualifiers)."
      ],
      "seeAlso": ["[simple](#type_simple)", "[series](#type_series)"]
    },
    {
      "name": "int",
      "desc": [
        "Keyword used to explicitly declare the \"int\" (integer) type of a variable or a parameter."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"int\")",
        "int i = 14    // Same as `i = 14`",
        "i := na",
        "plot(i)"
      ],
      "remarks": [
        "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na). Learn more about Pine Script® types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/language/type-system/)."
      ],
      "seeAlso": [
        "[var](#kw_var)",
        "[varip](#kw_varip)",
        "[float](#type_float)",
        "[bool](#type_bool)",
        "[color](#type_color)",
        "[string](#type_string)"
      ]
    },
    {
      "name": "float",
      "desc": [
        "Keyword used to explicitly declare the \"float\" (floating point) type of a variable or a parameter."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"float\")",
        "float f = 3.14    // Same as `f = 3.14`",
        "f := na",
        "plot(f)"
      ],
      "remarks": [
        "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na). Learn more about Pine Script® types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/language/type-system/)."
      ],
      "seeAlso": [
        "[var](#kw_var)",
        "[varip](#kw_varip)",
        "[int](#type_int)",
        "[bool](#type_bool)",
        "[color](#type_color)",
        "[string](#type_string)"
      ]
    },
    {
      "name": "bool",
      "desc": [
        "Keyword used to explicitly declare the \"bool\" (boolean) type of a variable or a parameter. \"Bool\" variables can have values [true](#const_true) or [false](#const_false)."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"bool\")",
        "bool b = true    // Same as `b = true`",
        "plot(b ? open : close)"
      ],
      "remarks": [
        "Explicitly mentioning the type in a variable declaration is optional. Learn more about Pine Script® types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/language/type-system/)."
      ],
      "seeAlso": [
        "[var](#kw_var)",
        "[varip](#kw_varip)",
        "[int](#type_int)",
        "[float](#type_float)",
        "[color](#type_color)",
        "[string](#type_string)",
        "[true](#const_true)",
        "[false](#const_false)"
      ]
    },
    {
      "name": "string",
      "desc": [
        "Keyword used to explicitly declare the \"string\" type of a variable or a parameter."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"string\")",
        "string s = \"Hello World!\"    // Same as `s = \"Hello world!\"`",
        "// string s = na // same as \"\" ",
        "plot(na, title=s)"
      ],
      "remarks": [
        "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na). Learn more about Pine Script® types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/language/type-system/)."
      ],
      "seeAlso": [
        "[var](#kw_var)",
        "[varip](#kw_varip)",
        "[int](#type_int)",
        "[float](#type_float)",
        "[bool](#type_bool)",
        "[str.tostring](#fun_str.tostring)",
        "[str.format](#fun_str.format)"
      ]
    },
    {
      "name": "color",
      "desc": [
        "Keyword used to explicitly declare the \"color\" type of a variable or a parameter."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color\", overlay = true)",
        "",
        "color textColor = color.green",
        "color labelColor = #FF000080 // Red color (FF0000) with 50% transparency (80 which is half of FF).",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = \"Label\", color = labelColor, textcolor = textColor)",
        "",
        "// When declaring variables with color literals, built-in constants(color.green) or functions (color.new(), color.rgb()), the \"color\" keyword for the type can be omitted.",
        "c = color.rgb(0,255,0,0)",
        "plot(close, color = c)"
      ],
      "remarks": [
        "Color literals have the following format: #RRGGBB or #RRGGBBAA. The letter pairs represent 00 to FF hexadecimal values (0 to 255 in decimal) where RR, GG and BB pairs are the values for the color's red, green and blue components. AA is an optional value for the color's transparency (or alpha component) where 00 is invisible and FF opaque. When no AA pair is supplied, FF is used. The hexadecimal letters can be upper or lower case.",
        "Explicitly mentioning the type in a variable declaration is optional, except when it is initialized with [na](#var_na). Learn more about Pine Script® types in the User Manual page on the [Type System](https://www.tradingview.com/pine-script-docs/language/type-system/)."
      ],
      "seeAlso": [
        "[var](#kw_var)",
        "[varip](#kw_varip)",
        "[int](#type_int)",
        "[float](#type_float)",
        "[string](#type_string)",
        "[color.rgb](#fun_color.rgb)",
        "[color.new](#fun_color.new)"
      ]
    },
    {
      "name": "line",
      "desc": [
        "Keyword used to explicitly declare the \"line\" type of a variable or a parameter. Line objects (or IDs) can be created with the [line.new](#fun_line.new) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"line\")",
        "// Empty `line1` line ID.",
        "var line line1 = na",
        "// `line` type is unnecessary because `line.new()` returns \"line\" type.",
        "var line2 = line.new(na, na, na, na)",
        "line3 = line.new(bar_index - 1, high, bar_index, high, extend = extend.right)"
      ],
      "remarks": ["Line objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[label](#type_label)",
        "[box](#type_box)",
        "[line.new](#fun_line.new)"
      ]
    },
    {
      "name": "label",
      "desc": [
        "Keyword used to explicitly declare the \"label\" type of a variable or a parameter. Label objects (or IDs) can be created with the [label.new](#fun_label.new) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"label\")",
        "// Empty `label1` label ID.",
        "var label label1 = na",
        "// `label` type is unnecessary because `label.new()` returns \"label\" type.",
        "var label2 = label.new(na, na, na)",
        "if barstate.islastconfirmedhistory",
        "\tlabel3 = label.new(bar_index, high, text = \"label3 text\")"
      ],
      "remarks": ["Label objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[line](#type_line)",
        "[box](#type_box)",
        "[label.new](#fun_label.new)"
      ]
    },
    {
      "name": "box",
      "desc": [
        "Keyword used to explicitly declare the \"box\" type of a variable or a parameter. Box objects (or IDs) can be created with the [box.new](#fun_box.new) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"box\")",
        "// Empty `box1` box ID.",
        "var box box1 = na",
        "// `box` type is unnecessary because `box.new()` returns a \"box\" type.",
        "var box2 = box.new(na, na, na, na)",
        "box3 = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)"
      ],
      "remarks": ["Box objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[line](#type_line)",
        "[label](#type_label)",
        "[table](#type_table)",
        "[box.new](#fun_box.new)"
      ]
    },
    {
      "name": "table",
      "desc": [
        "Keyword used to explicitly declare the \"table\" type of a variable or a parameter. Table objects (or IDs) can be created with the [table.new](#fun_table.new) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"table\")",
        "// Empty `table1` table ID.",
        "var table table1 = na",
        "// `table` type is unnecessary because `table.new()` returns \"table\" type.",
        "var table2 = table.new(position.top_left, na, na)",
        "",
        "if barstate.islastconfirmedhistory",
        "\tvar table3 = table.new(position = position.top_right, columns = 1, rows = 1, bgcolor = color.yellow, border_width = 1)",
        "\ttable.cell(table_id = table3, column = 0, row = 0, text = \"table3 text\")"
      ],
      "remarks": ["Table objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[line](#type_line)",
        "[label](#type_label)",
        "[box](#type_box)",
        "[table.new](#fun_table.new)"
      ]
    },
    {
      "name": "linefill",
      "desc": [
        "Keyword used to explicitly declare the \"linefill\" type of a variable or a parameter. Linefill objects (or IDs) can be created with the [linefill.new](#fun_linefill.new) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"linefill\", overlay=true)",
        "// Empty `linefill1` line ID.",
        "var linefill linefill1 = na",
        "// `linefill` type is unnecessary because `linefill.new()` returns \"linefill\" type.",
        "var linefill2 = linefill.new(na, na, na)",
        "",
        "if barstate.islastconfirmedhistory",
        "\tline1 = line.new(bar_index - 10, high+1, bar_index, high+1, extend = extend.right)",
        "\tline2 = line.new(bar_index - 10, low+1, bar_index, low+1, extend = extend.right)",
        "\tlinefill3 = linefill.new(line1, line2, color = color.new(color.green, 80))"
      ],
      "remarks": ["Linefill objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[line](#type_line)",
        "[label](#type_label)",
        "[table](#type_table)",
        "[box](#type_box)",
        "[linefill.new](#fun_linefill.new)"
      ]
    },
    {
      "name": "array",
      "desc": [
        "Keyword used to explicitly declare the \"array\" type of a variable or a parameter. Array objects (or IDs) can be created with the [array.new<type>](#fun_array.new<type>), [array.from](#fun_array.from) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array\", overlay=true)",
        "array<float> a = na",
        "a := array.new<float>(1, close)",
        "plot(array.get(a, 0))"
      ],
      "remarks": ["Array objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[line](#type_line)",
        "[label](#type_label)",
        "[table](#type_table)",
        "[box](#type_box)",
        "[array.new<type>](#fun_array.new<type>)",
        "[array.from](#fun_array.from)"
      ]
    },
    {
      "name": "matrix",
      "desc": [
        "Keyword used to explicitly declare the \"matrix\" type of a variable or a parameter. Matrix objects (or IDs) can be created with the [matrix.new<type>](#fun_matrix.new<type>) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"matrix example\")",
        "",
        "// Create `m1` matrix of `int` type.",
        "matrix<int> m1 = matrix.new<int>(2, 3, 0)",
        "",
        "// `matrix<int>` is unnecessary because the `matrix.new<int>()` function returns an `int` type matrix object.",
        "m2 = matrix.new<int>(2, 3, 0)",
        "",
        "// Display matrix using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, str.tostring(m2))"
      ],
      "remarks": ["Matrix objects are always of \"series\" form."],
      "seeAlso": [
        "[var](#kw_var)",
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[array](#type_array)"
      ]
    },
    {
      "name": "chart.point",
      "desc": [
        "Keyword to explicitly declare the type of a variable or parameter as `chart.point`. Scripts can produce `chart.point` instances using the [chart.point.from_time](#fun_chart.point.from_time), [chart.point.from_index](#fun_chart.point.from_index), [chart.point.now](#fun_chart.point.now), and [chart.point.new](#fun_chart.point.new) functions."
      ],
      "fields": [
        {
          "name": "index",
          "desc": "The x-coordinate of the point, expressed as a bar index value.",
          "type": "series int"
        },
        {
          "name": "time",
          "desc": "The x-coordinate of the point, expressed as a UNIX time value, in milliseconds.",
          "type": "series int"
        },
        {
          "name": "price",
          "desc": "The y-coordinate of the point.",
          "type": "series float"
        }
      ],
      "seeAlso": ["[polyline](#type_polyline)"]
    },
    {
      "name": "map",
      "desc": [
        "Keyword used to explicitly declare the \"map\" type of a variable or a parameter. Map objects (or IDs) can be created with the [map.new<type,type>](#fun_map.new<type,type>) function."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map\", overlay=true)",
        "map<int, float> a = na",
        "a := map.new<int, float>()",
        "a.put(bar_index, close)",
        "label.new(bar_index, a.get(bar_index), \"Current close\")"
      ],
      "remarks": [
        "Map objects are always of [series](https://www.tradingview.com/pine-script-docs/language/type-system/#series) form."
      ],
      "seeAlso": ["[map.new<type,type>](#fun_map.new<type,type>)"]
    },
    {
      "name": "polyline",
      "desc": [
        "Keyword to explicitly declare the type of a variable or parameter as `polyline`. Scripts can produce `polyline` instances using the [polyline.new](#fun_polyline.new) function."
      ],
      "seeAlso": ["[chart.point](#type_chart.point)"]
    }
  ],
  "annotations": [
    {
      "name": "@version=",
      "desc": [
        "Specifies the Pine Script® version that the script will use. The number in this annotation should not be confused with the script's version number, which updates on every saved change to the code."
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": ["//@version=6", "indicator(\"Pine v6 Indicator\")", "plot(close)"]
        },
        {
          "desc": [],
          "examples": [
            "//This indicator has no version annotation, so it will try to use v1.",
            "//Pine Script® v1 has no function named `indicator()`, so the script will not compile.",
            "indicator(\"Pine v1 Indicator\")",
            "plot(close)"
          ]
        }
      ],
      "remarks": [
        "The version should always be specified. Otherwise, for compatibility reasons, the script will be compiled using Pine Script® v1, which lacks most of the newer features and is bound to confuse. This annotation can be anywhere within a script, but we recommend placing it at the top of the code for readability."
      ]
    },
    {
      "name": "@description",
      "desc": [
        "Sets a custom description for scripts that use the [library](#fun_library) declaration statement. The text provided with this annotation will be used to pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "// @description Provides a tool to quickly output a label on the chart.",
        "library(\"MyLibrary\")",
        "",
        "// @function Outputs a label with `labelText` on the bar's high.",
        "// @param labelText (series string) The text to display on the label.",
        "// @returns Drawn label.",
        "export drawLabel(string labelText) =>",
        "\tlabel.new(bar_index, high, text = labelText)"
      ]
    },
    {
      "name": "@enum",
      "desc": [
        "If placed above an enum declaration, it adds a custom description for the enum. The Pine Editor's autosuggest uses this description and displays it when a user hovers over the enum name. When used in library scripts, the descriptions of all enums using the [export](#kw_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Session highlight\", overlay = true)",
        "",
        "//@enum       Contains fields with popular timezones as titles.",
        "//@field exch Has an empty string as the title to represent the chart timezone.",
        "enum tz",
        "\tutc  = \"UTC\"",
        "\texch = \"\"",
        "\tny   = \"America/New_York\"",
        "\tchi  = \"America/Chicago\"",
        "\tlon  = \"Europe/London\"",
        "\ttok  = \"Asia/Tokyo\"",
        "",
        "//@variable The session string.",
        "selectedSession = input.session(\"1200-1500\", \"Session\")",
        "//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.",
        "selectedTimezone = input.enum(tz.utc, \"Session Timezone\")",
        "",
        "//@variable Is `true` if the current bar's time is in the specified session.",
        "bool inSession = false",
        "if not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))",
        "\tinSession := true",
        "",
        "// Highlight the background when `inSession` is `true`.",
        "bgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
      ]
    },
    {
      "name": "@function",
      "desc": [
        "If placed above a function declaration, it adds a custom description for the function.",
        "The Pine Editor's autosuggest uses this description and displays it when a user hovers over the function name. When used in [library](#fun_library) scripts, the descriptions of all functions using the [export](#kw_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "// @description Provides a tool to quickly output a label on the chart.",
        "library(\"MyLibrary\")",
        "",
        "// @function Outputs a label with `labelText` on the bar's high.",
        "// @param labelText (series string) The text to display on the label.",
        "// @returns Drawn label.",
        "export drawLabel(string labelText) =>",
        "\tlabel.new(bar_index, high, text = labelText)"
      ]
    },
    {
      "name": "@param",
      "desc": [
        "If placed above a function declaration, it adds a custom description for a function parameter. After the annotation, users should specify the parameter name, then its description.",
        "The Pine Editor's autosuggest uses this description and displays it when a user hovers over the function name. When used in [library](#fun_library) scripts, the descriptions of all functions using the [export](#kw_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "// @description Provides a tool to quickly output a label on the chart.",
        "library(\"MyLibrary\")",
        "",
        "// @function Outputs a label with `labelText` on the bar's high.",
        "// @param labelText (series string) The text to display on the label.",
        "// @returns Drawn label.",
        "export drawLabel(string labelText) =>",
        "\tlabel.new(bar_index, high, text = labelText)"
      ]
    },
    {
      "name": "@returns",
      "desc": [
        "If placed above a function declaration, it adds a custom description for what that function returns.",
        "The Pine Editor's autosuggest uses this description and displays it when a user hovers over the function name. When used in [library](#fun_library) scripts, the descriptions of all functions using the [export](#kw_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "// @description Provides a tool to quickly output a label on the chart.",
        "library(\"MyLibrary\")",
        "",
        "// @function Outputs a label with `labelText` on the bar's high.",
        "// @param labelText (series string) The text to display on the label.",
        "// @returns Drawn label.",
        "export drawLabel(string labelText) =>",
        "\tlabel.new(bar_index, high, text = labelText)"
      ]
    },
    {
      "name": "@variable",
      "desc": [
        "If placed above a variable declaration, it adds a custom description for the variable.",
        "The Pine Editor's autosuggest uses this description and displays it when a user hovers over the variable name."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"New high over the last 20 bars\", overlay = true)",
        "",
        "//@type A point on a chart.",
        "//@field index The index of the bar where the point is located, i.e., its `x` coordinate.",
        "//@field price The price where the point is located, i.e., its `y` coordinate.",
        "type Point",
        "    int index",
        "    float price",
        "",
        "//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.",
        "Point highest = na",
        "",
        "if ta.highestbars(high, 20) == 0",
        "    highest := Point.new(bar_index, high)",
        "    label.new(highest.index, highest.price, str.tostring(highest.price))"
      ]
    },
    {
      "name": "@type",
      "desc": [
        "If placed above a type declaration, it adds a custom description for the type.",
        "The Pine Editor's autosuggest uses this description and displays it when a user hovers over the type name. When used in [library](#fun_library) scripts, the descriptions of all types using the [export](#kw_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"New high over the last 20 bars\", overlay = true)",
        "",
        "//@type A point on a chart.",
        "//@field index The index of the bar where the point is located, i.e., its `x` coordinate.",
        "//@field price The price where the point is located, i.e., its `y` coordinate.",
        "type Point",
        "    int index",
        "    float price",
        "",
        "//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.",
        "Point highest = na",
        "",
        "if ta.highestbars(high, 20) == 0",
        "    highest := Point.new(bar_index, high)",
        "    label.new(highest.index, highest.price, str.tostring(highest.price))"
      ]
    },
    {
      "name": "@field",
      "desc": [
        "If placed above a [type](#kw_type) or [enum](#kw_enum) declaration, it adds a custom description for a field of the type/enum. After the annotation, users should specify the field name, followed by its description.",
        "The Pine Editor's autosuggest uses this description and displays it when a user hovers over the type/enum or field name. When used in [library](#fun_library) scripts, the descriptions of all types/enums using the [export](#kw_export) keyword will pre-fill the \"Description\" field in the publication dialogue."
      ],
      "examples": [
        "//@version=6",
        "indicator(\"New high over the last 20 bars\", overlay = true)",
        "",
        "//@type A point on a chart.",
        "//@field index The index of the bar where the point is located, i.e., its `x` coordinate.",
        "//@field price The price where the point is located, i.e., its `y` coordinate.",
        "type Point",
        "    int index",
        "    float price",
        "",
        "//@variable If the current `high` is the highest over the last 20 bars, returns a new `Point` instance, `na` otherwise.",
        "Point highest = na",
        "",
        "if ta.highestbars(high, 20) == 0",
        "    highest := Point.new(bar_index, high)",
        "    label.new(highest.index, highest.price, str.tostring(highest.price))"
      ]
    },
    {
      "name": "@strategy_alert_message",
      "desc": [
        "If used within a [strategy](#fun_strategy) script, it provides a default message to pre-fill the \"Message\" field in the alert creation dialogue."
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay=true, margin_long=100, margin_short=100)",
        "//@strategy_alert_message Strategy alert on symbol {{ticker}}",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "    strategy.entry(\"My Long Entry Id\", strategy.long)",
        "strategy.exit(\"Exit\", \"My Long Entry Id\", profit = 10 / syminfo.mintick, loss = 10 / syminfo.mintick)"
      ]
    }
  ],
  "functions": [
    {
      "name": "indicator",
      "desc": [
        "This declaration statement designates the script as an indicator and sets a number of indicator-related properties."
      ],
      "args": [
        {
          "name": "title",
          "desc": "The title of the script. It is displayed on the chart when no `shorttitle` argument is used, and becomes the publication's default title when publishing the script.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "shorttitle",
          "desc": "The script's display name on charts. If specified, it will replace the `title` argument in most chart-related windows. Optional. The default is the argument used for `title`.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "overlay",
          "desc": "If [true](#const_true), the indicator will be displayed over the chart. If [false](#const_false), it will be added in a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "format",
          "desc": "Specifies the formatting of the script's displayed values. Possible values: [format.inherit](#const_format.inherit), [format.price](#const_format.price), [format.volume](#const_format.volume), [format.percent](#const_format.percent). Optional. The default is [format.inherit](#const_format.inherit).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "precision",
          "desc": "Specifies the number of digits after the floating point of the script's displayed values. Must be a non-negative integer no greater than 16. If `format` is set to [format.inherit](#const_format.inherit) and `precision` is specified, the format will instead be set to [format.price](#const_format.price). When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is inherited from the precision of the chart's symbol.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "scale",
          "desc": "The price scale used. Possible values: [scale.right](#const_scale.right), [scale.left](#const_scale.left), [scale.none](#const_scale.none). The [scale.none](#const_scale.none) value can only be applied in combination with `overlay = true`. Optional. By default, the script uses the same scale as the chart.",
          "allowedTypeIDs": ["const scale_type"],
          "displayType": "const scale_type"
        },
        {
          "name": "max_bars_back",
          "desc": "The length of the historical buffer the script keeps for every variable and function, which determines how many past values can be referenced using the `[]` history-referencing operator. The required buffer size is automatically detected by the Pine Script® runtime. Using this parameter is only necessary when a runtime error occurs because automatic detection fails. More information on the underlying mechanics of the historical buffer can be found [in our Help Center](https://www.tradingview.com/chart/?solution=43000587849). Optional. The default is 0.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "timeframe",
          "desc": "Adds multi-timeframe functionality to simple scripts. When specified, a \"Timeframe\" field will be included in the \"Calculation\" section of the script's \"Settings/Inputs\" tab. The field's default value will be the argument supplied, whose format must conform to [timeframe string specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications). To specify the chart's timeframe, use an empty string or the [timeframe.period](#var_timeframe.period) variable. The parameter cannot be used with scripts using Pine Script® drawings. Optional. The default is [timeframe.period](#var_timeframe.period).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "timeframe_gaps",
          "desc": "Specifies how the indicator's values are displayed on chart bars when the `timeframe` is higher than the chart's. If [true](#const_true), a value only appears on a chart bar when the higher `timeframe` value becomes available, otherwise [na](#var_na) is returned (thus a \"gap\" occurs). With [false](#const_false), what would otherwise be gaps are filled with the latest known value returned, avoiding [na](#var_na) values. When specified, a \"Wait for timeframe closes\" checkbox will be included in the \"Calculation\" section of the script's \"Settings/Inputs\" tab. Optional. The default is [true](#const_true).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "explicit_plot_zorder",
          "desc": "Specifies the order in which the script's plots, fills, and hlines are rendered. If [true](#const_true), plots are drawn in the order in which they appear in the script's code, each newer plot being drawn above the previous ones. This only applies to `plot*()` functions, [fill](#fun_fill), and [hline](#fun_hline). Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "max_lines_count",
          "desc": "The number of last [line](#type_line) drawings displayed. Possible values: 1-500. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "max_labels_count",
          "desc": "The number of last [label](#type_label) drawings displayed. Possible values: 1-500. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "max_boxes_count",
          "desc": "The number of last [box](#type_box) drawings displayed. Possible values: 1-500. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "calc_bars_count",
          "desc": "Limits the initial calculation of a script to the last number of bars specified. When specified, a \"Calculated bars\" field will be included in the \"Calculation\" section of the script's \"Settings/Inputs\" tab. Optional. The default is 0, in which case the script executes on all available bars.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "max_polylines_count",
          "desc": "The number of last [polyline](#type_polyline) drawings displayed. Possible values: 1-100. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "dynamic_requests",
          "desc": "Specifies whether the script can dynamically call functions from the `request.*()` namespace. Dynamic `request.*()` calls are allowed within the local scopes of conditional structures (e.g., [if](#kw_if)), loops (e.g., [for](#kw_for)), and exported functions. Additionally, such calls allow \"series\" arguments for many of their parameters. Optional. The default is [true](#const_true). See the User Manual's [Dynamic requests](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#dynamic-requests) section for more information.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "behind_chart",
          "desc": "Controls whether the script's plots and drawings in the main chart pane appear behind the chart display (if [true](#const_true)), or in front of it (if [false](#const_false)). Optional. The default is [true](#const_true).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"My script\", shorttitle=\"Script\")",
        "plot(close)"
      ],
      "remarks": ["Every indicator script must have one [indicator](#fun_indicator) call."],
      "seeAlso": ["[strategy](#fun_strategy)", "[library](#fun_library)"],
      "syntax": [
        "indicator(title, shorttitle, overlay, format, precision, scale, max_bars_back, timeframe, timeframe_gaps, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, calc_bars_count, max_polylines_count, dynamic_requests, behind_chart) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "plot",
      "desc": ["Plots a series of data on the chart."],
      "args": [
        {
          "name": "series",
          "desc": "Series of data to be plotted. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "title",
          "desc": "Title of the plot.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "color",
          "desc": "Color of the plot. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "linewidth",
          "desc": "Width of the plotted line. Default value is 1. Not applicable to every style.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "style",
          "desc": "Type of plot. Possible values are: [plot.style_line](#const_plot.style_line), [plot.style_stepline](#const_plot.style_stepline), [plot.style_stepline_diamond](#const_plot.style_stepline_diamond), [plot.style_histogram](#const_plot.style_histogram), [plot.style_cross](#const_plot.style_cross), [plot.style_area](#const_plot.style_area), [plot.style_columns](#const_plot.style_columns), [plot.style_circles](#const_plot.style_circles), [plot.style_linebr](#const_plot.style_linebr), [plot.style_areabr](#const_plot.style_areabr), [plot.style_steplinebr](#const_plot.style_steplinebr). Default value is [plot.style_line](#const_plot.style_line).",
          "allowedTypeIDs": ["input plot_style", "const plot_style"],
          "displayType": "input plot_style"
        },
        {
          "name": "trackprice",
          "desc": "If true then a horizontal price line will be shown at the level of the last indicator value. Default is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "histbase",
          "desc": "The price value used as the reference level when rendering plot with [plot.style_histogram](#const_plot.style_histogram), [plot.style_columns](#const_plot.style_columns) or [plot.style_area](#const_plot.style_area) style. Default is 0.0.",
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "offset",
          "desc": "Shifts the plot to the left or to the right on the given number of bars. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "join",
          "desc": "If true then plot points will be joined with line, applicable only to [plot.style_cross](#const_plot.style_cross) and [plot.style_circles](#const_plot.style_circles) styles. Default is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "editable",
          "desc": "If true then plot style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "display",
          "desc": "Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: [display.none](#const_display.none), [display.pane](#const_display.pane), [display.data_window](#const_display.data_window), [display.price_scale](#const_display.price_scale), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": [
            "input plot_display",
            "const plot_display",
            "input plot_simple_display",
            "const plot_simple_display"
          ],
          "displayType": "input plot_display"
        },
        {
          "name": "format",
          "desc": "Determines whether the script formats the plot's values as prices, percentages, or volume values. The argument passed to this parameter supersedes the `format` parameter of the [indicator](#fun_indicator), and [strategy](#fun_strategy) functions. Optional. The default is the `format` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function. Possible values: [format.price](#const_format.price), [format.percent](#const_format.percent), [format.volume](#const_format.volume).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "precision",
          "desc": "The number of digits after the decimal point the plot's values show on the chart pane's y-axis, the script's status line, and the Data Window. Accepts a non-negative integer less than or equal to 16. The argument passed to this parameter supersedes the `precision` parameter of the [indicator](#fun_indicator) and [strategy](#fun_strategy) functions. When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is the `precision` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"plot\")",
        "plot(high+low, title='Title', color=color.new(#00ffaa, 70), linewidth=2, style=plot.style_area, offset=15, trackprice=true)",
        "",
        "// You may fill the background between any two plots with a fill() function:",
        "p1 = plot(open)",
        "p2 = plot(close)",
        "fill(p1, p2, color=color.new(color.green, 90))"
      ],
      "returns": ["A plot object, that can be used in [fill](#fun_fill)"],
      "seeAlso": [
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)",
        "[fill](#fun_fill)"
      ],
      "syntax": [
        "plot(series, title, color, linewidth, style, trackprice, histbase, offset, join, editable, show_last, display, format, precision, force_overlay) → plot"
      ],
      "returnedTypes": ["plot"]
    },
    {
      "name": "plotshape",
      "desc": ["Plots visual shapes on the chart."],
      "args": [
        {
          "name": "series",
          "desc": "Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except [location.absolute](#const_location.absolute). Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ],
          "displayType": "series int/float/bool"
        },
        {
          "name": "title",
          "desc": "Title of the plot.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "style",
          "desc": "Type of plot. Possible values are: [shape.xcross](#const_shape.xcross), [shape.cross](#const_shape.cross), [shape.triangleup](#const_shape.triangleup), [shape.triangledown](#const_shape.triangledown), [shape.flag](#const_shape.flag), [shape.circle](#const_shape.circle), [shape.arrowup](#const_shape.arrowup), [shape.arrowdown](#const_shape.arrowdown), [shape.labelup](#const_shape.labelup), [shape.labeldown](#const_shape.labeldown), [shape.square](#const_shape.square), [shape.diamond](#const_shape.diamond). Default value is [shape.xcross](#const_shape.xcross).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "location",
          "desc": "Location of shapes on the chart. Possible values are: [location.abovebar](#const_location.abovebar), [location.belowbar](#const_location.belowbar), [location.top](#const_location.top), [location.bottom](#const_location.bottom), [location.absolute](#const_location.absolute). Default value is [location.abovebar](#const_location.abovebar).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "color",
          "desc": "Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "offset",
          "desc": "Shifts shapes to the left or to the right on the given number of bars. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "text",
          "desc": "Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence. Example: 'line one\\nline two'.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "textcolor",
          "desc": "Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "editable",
          "desc": "If true then plotshape style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "size",
          "desc": "Size of shapes on the chart. Possible values are: [size.auto](#const_size.auto), [size.tiny](#const_size.tiny), [size.small](#const_size.small), [size.normal](#const_size.normal), [size.large](#const_size.large), [size.huge](#const_size.huge). Default is [size.auto](#const_size.auto).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "display",
          "desc": "Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: [display.none](#const_display.none), [display.pane](#const_display.pane), [display.data_window](#const_display.data_window), [display.price_scale](#const_display.price_scale), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": [
            "input plot_display",
            "const plot_display",
            "input plot_simple_display",
            "const plot_simple_display"
          ],
          "displayType": "input plot_display"
        },
        {
          "name": "format",
          "desc": "Determines whether the script formats the plot's values as prices, percentages, or volume values. The argument passed to this parameter supersedes the `format` parameter of the [indicator](#fun_indicator), and [strategy](#fun_strategy) functions. Optional. The default is the `format` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function. Possible values: [format.price](#const_format.price), [format.percent](#const_format.percent), [format.volume](#const_format.volume).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "precision",
          "desc": "The number of digits after the decimal point the plot's values show on the chart pane's y-axis, the script's status line, and the Data Window. Accepts a non-negative integer less than or equal to 16. The argument passed to this parameter supersedes the `precision` parameter of the [indicator](#fun_indicator) and [strategy](#fun_strategy) functions. When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is the `precision` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"plotshape example 1\", overlay=true)",
        "data = close >= open",
        "plotshape(data, style=shape.xcross)"
      ],
      "remarks": [
        "Use [plotshape](#fun_plotshape) function in conjunction with 'overlay=true' [indicator](#fun_indicator) parameter!"
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotchar](#fun_plotchar)",
        "[plotarrow](#fun_plotarrow)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)"
      ],
      "syntax": [
        "plotshape(series, title, style, location, color, offset, text, textcolor, editable, size, show_last, display, format, precision, force_overlay) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "plotchar",
      "desc": ["Plots visual shapes using any given one Unicode character on the chart."],
      "args": [
        {
          "name": "series",
          "desc": "Series of data to be plotted as shapes. Series is treated as a series of boolean values for all location values except [location.absolute](#const_location.absolute). Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ],
          "displayType": "series int/float/bool"
        },
        {
          "name": "title",
          "desc": "Title of the plot.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "char",
          "desc": "Character to use as a visual shape.",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "location",
          "desc": "Location of shapes on the chart. Possible values are: [location.abovebar](#const_location.abovebar), [location.belowbar](#const_location.belowbar), [location.top](#const_location.top), [location.bottom](#const_location.bottom), [location.absolute](#const_location.absolute). Default value is [location.abovebar](#const_location.abovebar).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "color",
          "desc": "Color of the shapes. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "offset",
          "desc": "Shifts shapes to the left or to the right on the given number of bars. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "text",
          "desc": "Text to display with the shape. You can use multiline text, to separate lines use '\\n' escape sequence. Example: 'line one\\nline two'.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "textcolor",
          "desc": "Color of the text. You can use constants like 'textcolor=color.red' or 'textcolor=#ff001a' as well as complex expressions like 'textcolor = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "editable",
          "desc": "If true then plotchar style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "size",
          "desc": "Size of characters on the chart. Possible values are: [size.auto](#const_size.auto), [size.tiny](#const_size.tiny), [size.small](#const_size.small), [size.normal](#const_size.normal), [size.large](#const_size.large), [size.huge](#const_size.huge). Default is [size.auto](#const_size.auto).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "display",
          "desc": "Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: [display.none](#const_display.none), [display.pane](#const_display.pane), [display.data_window](#const_display.data_window), [display.price_scale](#const_display.price_scale), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": [
            "input plot_display",
            "const plot_display",
            "input plot_simple_display",
            "const plot_simple_display"
          ],
          "displayType": "input plot_display"
        },
        {
          "name": "format",
          "desc": "Determines whether the script formats the plot's values as prices, percentages, or volume values. The argument passed to this parameter supersedes the `format` parameter of the [indicator](#fun_indicator), and [strategy](#fun_strategy) functions. Optional. The default is the `format` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function. Possible values: [format.price](#const_format.price), [format.percent](#const_format.percent), [format.volume](#const_format.volume).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "precision",
          "desc": "The number of digits after the decimal point the plot's values show on the chart pane's y-axis, the script's status line, and the Data Window. Accepts a non-negative integer less than or equal to 16. The argument passed to this parameter supersedes the `precision` parameter of the [indicator](#fun_indicator) and [strategy](#fun_strategy) functions. When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is the `precision` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"plotchar example\", overlay=true)",
        "data = close >= open",
        "plotchar(data, char='❄')"
      ],
      "remarks": [
        "Use [plotchar](#fun_plotchar) function in conjunction with 'overlay=true' [indicator](#fun_indicator) parameter!"
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotarrow](#fun_plotarrow)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)"
      ],
      "syntax": [
        "plotchar(series, title, char, location, color, offset, text, textcolor, editable, size, show_last, display, format, precision, force_overlay) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "plotarrow",
      "desc": [
        "Plots up and down arrows on the chart. Up arrow is drawn at every indicator positive value, down arrow is drawn at every negative value. If indicator returns [na](#var_na) then no arrow is drawn. Arrows has different height, the more absolute indicator value the longer arrow is drawn."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of data to be plotted as arrows. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "title",
          "desc": "Title of the plot.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "colorup",
          "desc": "Color of the up arrows. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "colordown",
          "desc": "Color of the down arrows. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "offset",
          "desc": "Shifts arrows to the left or to the right on the given number of bars. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "minheight",
          "desc": "Minimal possible arrow height in pixels. Default is 5.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "maxheight",
          "desc": "Maximum possible arrow height in pixels. Default is 100.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "editable",
          "desc": "If true then plotarrow style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "display",
          "desc": "Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: [display.none](#const_display.none), [display.pane](#const_display.pane), [display.data_window](#const_display.data_window), [display.price_scale](#const_display.price_scale), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": [
            "input plot_display",
            "const plot_display",
            "input plot_simple_display",
            "const plot_simple_display"
          ],
          "displayType": "input plot_display"
        },
        {
          "name": "format",
          "desc": "Determines whether the script formats the plot's values as prices, percentages, or volume values. The argument passed to this parameter supersedes the `format` parameter of the [indicator](#fun_indicator), and [strategy](#fun_strategy) functions. Optional. The default is the `format` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function. Possible values: [format.price](#const_format.price), [format.percent](#const_format.percent), [format.volume](#const_format.volume).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "precision",
          "desc": "The number of digits after the decimal point the plot's values show on the chart pane's y-axis, the script's status line, and the Data Window. Accepts a non-negative integer less than or equal to 16. The argument passed to this parameter supersedes the `precision` parameter of the [indicator](#fun_indicator) and [strategy](#fun_strategy) functions. When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is the `precision` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"plotarrow example\", overlay=true)",
        "codiff = close - open",
        "plotarrow(codiff, colorup=color.new(color.teal,40), colordown=color.new(color.orange, 40))"
      ],
      "remarks": [
        "Use [plotarrow](#fun_plotarrow) function in conjunction with 'overlay=true' [indicator](#fun_indicator) parameter!"
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[plotshape](#fun_plotshape)",
        "[plotchar](#fun_plotchar)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)"
      ],
      "syntax": [
        "plotarrow(series, title, colorup, colordown, offset, minheight, maxheight, editable, show_last, display, format, precision, force_overlay) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "plotbar",
      "desc": ["Plots ohlc bars on the chart."],
      "args": [
        {
          "name": "open",
          "desc": "Open series of data to be used as open values of bars. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "high",
          "desc": "High series of data to be used as high values of bars. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "low",
          "desc": "Low series of data to be used as low values of bars. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "close",
          "desc": "Close series of data to be used as close values of bars. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "title",
          "desc": "Title of the plotbar. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "color",
          "desc": "Color of the ohlc bars. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "editable",
          "desc": "If true then plotbar style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "display",
          "desc": "Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: [display.none](#const_display.none), [display.pane](#const_display.pane), [display.data_window](#const_display.data_window), [display.price_scale](#const_display.price_scale), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": [
            "input plot_display",
            "const plot_display",
            "input plot_simple_display",
            "const plot_simple_display"
          ],
          "displayType": "input plot_display"
        },
        {
          "name": "format",
          "desc": "Determines whether the script formats the plot's values as prices, percentages, or volume values. The argument passed to this parameter supersedes the `format` parameter of the [indicator](#fun_indicator), and [strategy](#fun_strategy) functions. Optional. The default is the `format` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function. Possible values: [format.price](#const_format.price), [format.percent](#const_format.percent), [format.volume](#const_format.volume).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "precision",
          "desc": "The number of digits after the decimal point the plot's values show on the chart pane's y-axis, the script's status line, and the Data Window. Accepts a non-negative integer less than or equal to 16. The argument passed to this parameter supersedes the `precision` parameter of the [indicator](#fun_indicator) and [strategy](#fun_strategy) functions. When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is the `precision` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"plotbar example\", overlay=true)",
        "plotbar(open, high, low, close, title='Title', color = open < close ? color.green : color.red)"
      ],
      "remarks": [
        "Even if one value of open, high, low or close equal NaN then bar no draw.",
        "The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'."
      ],
      "seeAlso": ["[plotcandle](#fun_plotcandle)"],
      "syntax": [
        "plotbar(open, high, low, close, title, color, editable, show_last, display, format, precision, force_overlay) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "plotcandle",
      "desc": ["Plots candles on the chart."],
      "args": [
        {
          "name": "open",
          "desc": "Open series of data to be used as open values of candles. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "high",
          "desc": "High series of data to be used as high values of candles. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "low",
          "desc": "Low series of data to be used as low values of candles. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "close",
          "desc": "Close series of data to be used as close values of candles. Required argument.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "title",
          "desc": "Title of the plotcandles. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "color",
          "desc": "Color of the candles. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "wickcolor",
          "desc": "The color of the wick of candles. An optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "editable",
          "desc": "If true then plotcandle style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "bordercolor",
          "desc": "The border color of candles. An optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "display",
          "desc": "Controls where the plot's information is displayed. Display options support addition and subtraction, meaning that using `display.all - display.status_line` will display the plot's information everywhere except in the script's status line. `display.price_scale + display.status_line` will display the plot only in the price scale and status line. When `display` arguments such as `display.price_scale` have user-controlled chart settings equivalents, the relevant plot information will only appear when all settings allow for it. Possible values: [display.none](#const_display.none), [display.pane](#const_display.pane), [display.data_window](#const_display.data_window), [display.price_scale](#const_display.price_scale), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": [
            "input plot_display",
            "const plot_display",
            "input plot_simple_display",
            "const plot_simple_display"
          ],
          "displayType": "input plot_display"
        },
        {
          "name": "format",
          "desc": "Determines whether the script formats the plot's values as prices, percentages, or volume values. The argument passed to this parameter supersedes the `format` parameter of the [indicator](#fun_indicator), and [strategy](#fun_strategy) functions. Optional. The default is the `format` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function. Possible values: [format.price](#const_format.price), [format.percent](#const_format.percent), [format.volume](#const_format.volume).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "precision",
          "desc": "The number of digits after the decimal point the plot's values show on the chart pane's y-axis, the script's status line, and the Data Window. Accepts a non-negative integer less than or equal to 16. The argument passed to this parameter supersedes the `precision` parameter of the [indicator](#fun_indicator) and [strategy](#fun_strategy) functions. When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is the `precision` value used by the [indicator](#fun_indicator)/[strategy](#fun_strategy) function.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"plotcandle example\", overlay=true)",
        "plotcandle(open, high, low, close, title='Title', color = open < close ? color.green : color.red, wickcolor=color.black)"
      ],
      "remarks": [
        "Even if one value of open, high, low or close equal NaN then bar no draw.",
        "The maximal value of open, high, low or close will be set as 'high', and the minimal value will be set as 'low'."
      ],
      "seeAlso": ["[plotbar](#fun_plotbar)"],
      "syntax": [
        "plotcandle(open, high, low, close, title, color, wickcolor, editable, show_last, bordercolor, display, format, precision, force_overlay) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "barcolor",
      "desc": ["Set color of bars."],
      "args": [
        {
          "name": "color",
          "desc": "Color of bars. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'. Required argument.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "offset",
          "desc": "Shifts the color series to the left or to the right on the given number of bars. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "editable",
          "desc": "If true then barcolor style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "title",
          "desc": "Title of the barcolor. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the barcolor is displayed. Possible values are: [display.none](#const_display.none), [display.all](#const_display.all). Default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["input plot_simple_display", "const plot_simple_display"],
          "displayType": "input plot_simple_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"barcolor example\", overlay=true)",
        "barcolor(close < open ? color.black : color.white)"
      ],
      "seeAlso": ["[bgcolor](#fun_bgcolor)", "[plot](#fun_plot)", "[fill](#fun_fill)"],
      "syntax": ["barcolor(color, offset, editable, show_last, title, display) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "bgcolor",
      "desc": ["Fill background of bars with specified color."],
      "args": [
        {
          "name": "color",
          "desc": "Color of the filled background. You can use constants like 'red' or '#ff001a' as well as complex expressions like 'close >= open ? color.green : color.red'. Required argument.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "offset",
          "desc": "Shifts the color series to the left or to the right on the given number of bars. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "editable",
          "desc": "If true then bgcolor style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "title",
          "desc": "Title of the bgcolor. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the bgcolor is displayed. Possible values are: [display.none](#const_display.none), [display.all](#const_display.all). Default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["input plot_simple_display", "const plot_simple_display"],
          "displayType": "input plot_simple_display"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the plotted results will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"bgcolor example\", overlay=true)",
        "bgcolor(close < open ? color.new(color.red,70) : color.new(color.green, 70))"
      ],
      "seeAlso": ["[barcolor](#fun_barcolor)", "[plot](#fun_plot)", "[fill](#fun_fill)"],
      "syntax": [
        "bgcolor(color, offset, editable, show_last, title, display, force_overlay) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "color.new",
      "desc": ["Function color applies the specified transparency to the given color."],
      "args": [
        {
          "name": "color",
          "desc": "Color to apply transparency to.",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        },
        {
          "name": "transp",
          "desc": "Possible values are from 0 (not transparent) to 100 (invisible).",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.new\", overlay=true)",
        "plot(close, color=color.new(color.red, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.new(color, transp) → const color"],
      "returnedTypes": ["const color"]
    },
    {
      "name": "color.new",
      "desc": ["Function color applies the specified transparency to the given color."],
      "args": [
        {
          "name": "color",
          "desc": "Color to apply transparency to.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "transp",
          "desc": "Possible values are from 0 (not transparent) to 100 (invisible).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.new\", overlay=true)",
        "plot(close, color=color.new(color.red, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.new(color, transp) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "color.new",
      "desc": ["Function color applies the specified transparency to the given color."],
      "args": [
        {
          "name": "color",
          "desc": "Color to apply transparency to.",
          "required": true,
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        },
        {
          "name": "transp",
          "desc": "Possible values are from 0 (not transparent) to 100 (invisible).",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.new\", overlay=true)",
        "plot(close, color=color.new(color.red, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.new(color, transp) → input color"],
      "returnedTypes": ["input color"]
    },
    {
      "name": "color.new",
      "desc": ["Function color applies the specified transparency to the given color."],
      "args": [
        {
          "name": "color",
          "desc": "Color to apply transparency to.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        },
        {
          "name": "transp",
          "desc": "Possible values are from 0 (not transparent) to 100 (invisible).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.new\", overlay=true)",
        "plot(close, color=color.new(color.red, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.new(color, transp) → simple color"],
      "returnedTypes": ["simple color"]
    },
    {
      "name": "color.rgb",
      "desc": ["Creates a new color with transparency using the RGB color model."],
      "args": [
        {
          "name": "red",
          "desc": "Red color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "green",
          "desc": "Green color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "blue",
          "desc": "Blue color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "transp",
          "desc": "Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible). Default value is 0.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.rgb\", overlay=true)",
        "plot(close, color=color.rgb(255, 0, 0, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.rgb(red, green, blue, transp) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "color.rgb",
      "desc": ["Creates a new color with transparency using the RGB color model."],
      "args": [
        {
          "name": "red",
          "desc": "Red color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "green",
          "desc": "Green color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "blue",
          "desc": "Blue color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "transp",
          "desc": "Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible). Default value is 0.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.rgb\", overlay=true)",
        "plot(close, color=color.rgb(255, 0, 0, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.rgb(red, green, blue, transp) → const color"],
      "returnedTypes": ["const color"]
    },
    {
      "name": "color.rgb",
      "desc": ["Creates a new color with transparency using the RGB color model."],
      "args": [
        {
          "name": "red",
          "desc": "Red color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "green",
          "desc": "Green color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "blue",
          "desc": "Blue color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "transp",
          "desc": "Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible). Default value is 0.",
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.rgb\", overlay=true)",
        "plot(close, color=color.rgb(255, 0, 0, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.rgb(red, green, blue, transp) → input color"],
      "returnedTypes": ["input color"]
    },
    {
      "name": "color.rgb",
      "desc": ["Creates a new color with transparency using the RGB color model."],
      "args": [
        {
          "name": "red",
          "desc": "Red color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "green",
          "desc": "Green color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "blue",
          "desc": "Blue color component. Possible values are from 0 to 255.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "transp",
          "desc": "Optional. Color transparency. Possible values are from 0 (opaque) to 100 (invisible). Default value is 0.",
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.rgb\", overlay=true)",
        "plot(close, color=color.rgb(255, 0, 0, 50))"
      ],
      "returns": ["Color with specified transparency."],
      "remarks": [
        "Using arguments that are not constants (e.g., 'simple', 'input' or 'series') will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": ["color.rgb(red, green, blue, transp) → simple color"],
      "returnedTypes": ["simple color"]
    },
    {
      "name": "color.r",
      "desc": ["Retrieves the value of the color's red component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.r\", overlay=true)",
        "plot(color.r(color.red))"
      ],
      "returns": ["The value (0 to 255) of the color's red component."],
      "syntax": ["color.r(color) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "color.r",
      "desc": ["Retrieves the value of the color's red component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.r\", overlay=true)",
        "plot(color.r(color.red))"
      ],
      "returns": ["The value (0 to 255) of the color's red component."],
      "syntax": ["color.r(color) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "color.r",
      "desc": ["Retrieves the value of the color's red component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.r\", overlay=true)",
        "plot(color.r(color.red))"
      ],
      "returns": ["The value (0 to 255) of the color's red component."],
      "syntax": ["color.r(color) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "color.r",
      "desc": ["Retrieves the value of the color's red component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.r\", overlay=true)",
        "plot(color.r(color.red))"
      ],
      "returns": ["The value (0 to 255) of the color's red component."],
      "syntax": ["color.r(color) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "color.g",
      "desc": ["Retrieves the value of the color's green component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.g\", overlay=true)",
        "plot(color.g(color.green))"
      ],
      "returns": ["The value (0 to 255) of the color's green component."],
      "syntax": ["color.g(color) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "color.g",
      "desc": ["Retrieves the value of the color's green component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.g\", overlay=true)",
        "plot(color.g(color.green))"
      ],
      "returns": ["The value (0 to 255) of the color's green component."],
      "syntax": ["color.g(color) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "color.g",
      "desc": ["Retrieves the value of the color's green component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.g\", overlay=true)",
        "plot(color.g(color.green))"
      ],
      "returns": ["The value (0 to 255) of the color's green component."],
      "syntax": ["color.g(color) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "color.g",
      "desc": ["Retrieves the value of the color's green component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.g\", overlay=true)",
        "plot(color.g(color.green))"
      ],
      "returns": ["The value (0 to 255) of the color's green component."],
      "syntax": ["color.g(color) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "color.b",
      "desc": ["Retrieves the value of the color's blue component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.b\", overlay=true)",
        "plot(color.b(color.blue))"
      ],
      "returns": ["The value (0 to 255) of the color's blue component."],
      "syntax": ["color.b(color) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "color.b",
      "desc": ["Retrieves the value of the color's blue component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.b\", overlay=true)",
        "plot(color.b(color.blue))"
      ],
      "returns": ["The value (0 to 255) of the color's blue component."],
      "syntax": ["color.b(color) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "color.b",
      "desc": ["Retrieves the value of the color's blue component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.b\", overlay=true)",
        "plot(color.b(color.blue))"
      ],
      "returns": ["The value (0 to 255) of the color's blue component."],
      "syntax": ["color.b(color) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "color.b",
      "desc": ["Retrieves the value of the color's blue component."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.b\", overlay=true)",
        "plot(color.b(color.blue))"
      ],
      "returns": ["The value (0 to 255) of the color's blue component."],
      "syntax": ["color.b(color) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "color.t",
      "desc": ["Retrieves the color's transparency."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.t\", overlay=true)",
        "plot(color.t(color.new(color.red, 50)))"
      ],
      "returns": ["The value (0-100) of the color's transparency."],
      "syntax": ["color.t(color) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "color.t",
      "desc": ["Retrieves the color's transparency."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.t\", overlay=true)",
        "plot(color.t(color.new(color.red, 50)))"
      ],
      "returns": ["The value (0-100) of the color's transparency."],
      "syntax": ["color.t(color) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "color.t",
      "desc": ["Retrieves the color's transparency."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.t\", overlay=true)",
        "plot(color.t(color.new(color.red, 50)))"
      ],
      "returns": ["The value (0-100) of the color's transparency."],
      "syntax": ["color.t(color) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "color.t",
      "desc": ["Retrieves the color's transparency."],
      "args": [
        {
          "name": "color",
          "desc": "Color.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.t\", overlay=true)",
        "plot(color.t(color.new(color.red, 50)))"
      ],
      "returns": ["The value (0-100) of the color's transparency."],
      "syntax": ["color.t(color) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "color.from_gradient",
      "desc": [
        "Based on the relative position of value in the bottom_value to top_value range, the function returns a color from the gradient defined by bottom_color to top_color."
      ],
      "args": [
        {
          "name": "value",
          "desc": "Value to calculate the position-dependent color.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "bottom_value",
          "desc": "Bottom position value corresponding to bottom_color.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "top_value",
          "desc": "Top position value corresponding to top_color.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "bottom_color",
          "desc": "Bottom position color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "top_color",
          "desc": "Top position color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"color.from_gradient\", overlay=true)",
        "color1 = color.from_gradient(close, low, high, color.yellow, color.lime)",
        "color2 = color.from_gradient(ta.rsi(close, 7), 0, 100, color.rgb(255, 0, 0), color.rgb(0, 255, 0, 50))",
        "plot(close, color=color1)",
        "plot(ta.rsi(close,7), color=color2)"
      ],
      "returns": ["A color calculated from the linear gradient between bottom_color to top_color."],
      "remarks": [
        "Using this function will have an impact on the colors displayed in the script's \"Settings/Style\" tab. See the [User Manual](https://www.tradingview.com/pine-script-docs/concepts/colors/#color-selection-through-script-settings) for more information."
      ],
      "syntax": [
        "color.from_gradient(value, bottom_value, top_value, bottom_color, top_color) → series color"
      ],
      "returnedTypes": ["series color"]
    },
    {
      "name": "alertcondition",
      "desc": [
        "Creates alert condition, that is available in Create Alert dialog. Please note, that [alertcondition](#fun_alertcondition) does NOT create an alert, it just gives you more options in Create Alert dialog. Also, [alertcondition](#fun_alertcondition) effect is invisible on chart."
      ],
      "args": [
        {
          "name": "condition",
          "desc": "Series of boolean values that is used for alert. True values mean alert fire, false - no alert. Required argument.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "title",
          "desc": "Title of the alert condition. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "message",
          "desc": "Message to display when alert fires. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"alertcondition\", overlay=true)",
        "alertcondition(close >= open, title='Alert on Green Bar', message='Green Bar!')"
      ],
      "remarks": [
        "Please note that an alertcondition call generates an additional plot. All such calls are taken into account when we calculate the number of the output series per script."
      ],
      "seeAlso": ["[alert](#fun_alert)"],
      "syntax": ["alertcondition(condition, title, message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "input",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget."
      ],
      "args": [
        {
          "name": "defval",
          "displayType": "const int/float/bool/string/color or source-type built-ins",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
          "required": true,
          "allowedTypeIDs": ["const bool"]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default depends on the type of the value passed to `defval`: [display.none](#const_display.none) for [bool](#type_bool) and [color](#type_color) values, [display.all](#const_display.all) for everything else.",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input\", overlay=true)",
        "i_switch = input(true, \"On/Off\")",
        "plot(i_switch ? open : na)",
        "",
        "i_len = input(7, \"Length\")",
        "i_src = input(close, \"Source\")",
        "plot(ta.sma(i_src, i_len))",
        "",
        "i_border = input(142.50, \"Price Border\")",
        "hline(i_border)",
        "bgcolor(close > i_border ? color.green : color.red)",
        "",
        "i_col = input(color.red, \"Plot Color\")",
        "plot(close, color=i_col)",
        "",
        "i_text = input(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, text=i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input](#fun_input) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.color](#fun_input.color)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.text_area](#fun_input.text_area)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)"
      ],
      "syntax": ["input(defval, title, tooltip, inline, group, display) → input bool"],
      "returnedTypes": ["input bool"]
    },
    {
      "name": "input",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget."
      ],
      "args": [
        {
          "name": "defval",
          "displayType": "const int/float/bool/string/color or source-type built-ins",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
          "required": true,
          "allowedTypeIDs": ["const color"]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default depends on the type of the value passed to `defval`: [display.none](#const_display.none) for [bool](#type_bool) and [color](#type_color) values, [display.all](#const_display.all) for everything else.",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input\", overlay=true)",
        "i_switch = input(true, \"On/Off\")",
        "plot(i_switch ? open : na)",
        "",
        "i_len = input(7, \"Length\")",
        "i_src = input(close, \"Source\")",
        "plot(ta.sma(i_src, i_len))",
        "",
        "i_border = input(142.50, \"Price Border\")",
        "hline(i_border)",
        "bgcolor(close > i_border ? color.green : color.red)",
        "",
        "i_col = input(color.red, \"Plot Color\")",
        "plot(close, color=i_col)",
        "",
        "i_text = input(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, text=i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input](#fun_input) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.color](#fun_input.color)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.text_area](#fun_input.text_area)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)"
      ],
      "syntax": ["input(defval, title, tooltip, inline, group, display) → input color"],
      "returnedTypes": ["input color"]
    },
    {
      "name": "input",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget."
      ],
      "args": [
        {
          "name": "defval",
          "displayType": "const int/float/bool/string/color or source-type built-ins",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
          "required": true,
          "allowedTypeIDs": ["const int"]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default depends on the type of the value passed to `defval`: [display.none](#const_display.none) for [bool](#type_bool) and [color](#type_color) values, [display.all](#const_display.all) for everything else.",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input\", overlay=true)",
        "i_switch = input(true, \"On/Off\")",
        "plot(i_switch ? open : na)",
        "",
        "i_len = input(7, \"Length\")",
        "i_src = input(close, \"Source\")",
        "plot(ta.sma(i_src, i_len))",
        "",
        "i_border = input(142.50, \"Price Border\")",
        "hline(i_border)",
        "bgcolor(close > i_border ? color.green : color.red)",
        "",
        "i_col = input(color.red, \"Plot Color\")",
        "plot(close, color=i_col)",
        "",
        "i_text = input(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, text=i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input](#fun_input) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.color](#fun_input.color)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.text_area](#fun_input.text_area)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)"
      ],
      "syntax": ["input(defval, title, tooltip, inline, group, display) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "input",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget."
      ],
      "args": [
        {
          "name": "defval",
          "displayType": "const int/float/bool/string/color or source-type built-ins",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default depends on the type of the value passed to `defval`: [display.none](#const_display.none) for [bool](#type_bool) and [color](#type_color) values, [display.all](#const_display.all) for everything else.",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input\", overlay=true)",
        "i_switch = input(true, \"On/Off\")",
        "plot(i_switch ? open : na)",
        "",
        "i_len = input(7, \"Length\")",
        "i_src = input(close, \"Source\")",
        "plot(ta.sma(i_src, i_len))",
        "",
        "i_border = input(142.50, \"Price Border\")",
        "hline(i_border)",
        "bgcolor(close > i_border ? color.green : color.red)",
        "",
        "i_col = input(color.red, \"Plot Color\")",
        "plot(close, color=i_col)",
        "",
        "i_text = input(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, text=i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input](#fun_input) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.color](#fun_input.color)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.text_area](#fun_input.text_area)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)"
      ],
      "syntax": ["input(defval, title, tooltip, inline, group, display) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "input",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget."
      ],
      "args": [
        {
          "name": "defval",
          "displayType": "const int/float/bool/string/color or source-type built-ins",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
          "required": true,
          "allowedTypeIDs": ["const string"]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default depends on the type of the value passed to `defval`: [display.none](#const_display.none) for [bool](#type_bool) and [color](#type_color) values, [display.all](#const_display.all) for everything else.",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input\", overlay=true)",
        "i_switch = input(true, \"On/Off\")",
        "plot(i_switch ? open : na)",
        "",
        "i_len = input(7, \"Length\")",
        "i_src = input(close, \"Source\")",
        "plot(ta.sma(i_src, i_len))",
        "",
        "i_border = input(142.50, \"Price Border\")",
        "hline(i_border)",
        "bgcolor(close > i_border ? color.green : color.red)",
        "",
        "i_col = input(color.red, \"Plot Color\")",
        "plot(close, color=i_col)",
        "",
        "i_text = input(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, text=i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input](#fun_input) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.color](#fun_input.color)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.text_area](#fun_input.text_area)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)"
      ],
      "syntax": ["input(defval, title, tooltip, inline, group, display) → input string"],
      "returnedTypes": ["input string"]
    },
    {
      "name": "input",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function automatically detects the type of the argument used for 'defval' and uses the corresponding input widget."
      ],
      "args": [
        {
          "name": "defval",
          "displayType": "const int/float/bool/string/color or source-type built-ins",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. Source-type built-ins are built-in series float variables that specify the source of the calculation: `close`, `hlc3`, etc.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default depends on the type of the value passed to `defval`: [display.none](#const_display.none) for [bool](#type_bool) and [color](#type_color) values, [display.all](#const_display.all) for everything else.",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input\", overlay=true)",
        "i_switch = input(true, \"On/Off\")",
        "plot(i_switch ? open : na)",
        "",
        "i_len = input(7, \"Length\")",
        "i_src = input(close, \"Source\")",
        "plot(ta.sma(i_src, i_len))",
        "",
        "i_border = input(142.50, \"Price Border\")",
        "hline(i_border)",
        "bgcolor(close > i_border ? color.green : color.red)",
        "",
        "i_col = input(color.red, \"Plot Color\")",
        "plot(close, color=i_col)",
        "",
        "i_text = input(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, text=i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input](#fun_input) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.color](#fun_input.color)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.text_area](#fun_input.text_area)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)"
      ],
      "syntax": ["input(defval, title, inline, group, tooltip, display) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "input.bool",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a checkmark to the script's inputs."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it.",
          "required": true,
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.none](#const_display.none).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.bool\", overlay=true)",
        "i_switch = input.bool(true, \"On/Off\")",
        "plot(i_switch ? open : na)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.bool](#fun_input.bool) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.bool(defval, title, tooltip, inline, group, confirm, display) → input bool"
      ],
      "returnedTypes": ["input bool"]
    },
    {
      "name": "input.int",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for an integer input to the script's inputs."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "minval",
          "desc": "Minimal possible value of the input variable. Optional.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "maxval",
          "desc": "Maximum possible value of the input variable. Optional.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "step",
          "desc": "Step value used for incrementing/decrementing the input. Optional. The default is 1.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.int\", overlay=true)",
        "i_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)",
        "plot(ta.sma(close, i_len1))",
        "",
        "i_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])",
        "plot(ta.sma(close, i_len2))"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.int](#fun_input.int) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.int(defval, title, minval, maxval, step, tooltip, inline, group, confirm, display) → input int"
      ],
      "returnedTypes": ["input int"]
    },
    {
      "name": "input.int",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for an integer input to the script's inputs."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "options",
          "displayType": "tuple of const int values: [val1, val2, ...]",
          "desc": "A list of options to choose from a dropdown menu, separated by commas and enclosed in square brackets: [val1, val2, ...]. When using this parameter, the `minval`, `maxval` and `step` parameters cannot be used.",
          "allowedTypeIDs": ["[const int...]"]
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.int\", overlay=true)",
        "i_len1 = input.int(10, \"Length 1\", minval=5, maxval=21, step=1)",
        "plot(ta.sma(close, i_len1))",
        "",
        "i_len2 = input.int(10, \"Length 2\", options=[5, 10, 21])",
        "plot(ta.sma(close, i_len2))"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.int](#fun_input.int) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.int(defval, title, options, tooltip, inline, group, confirm, display) → input int"
      ],
      "returnedTypes": ["input int"]
    },
    {
      "name": "input.float",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a float input to the script's inputs."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "minval",
          "desc": "Minimal possible value of the input variable. Optional.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "maxval",
          "desc": "Maximum possible value of the input variable. Optional.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "step",
          "desc": "Step value used for incrementing/decrementing the input. Optional. The default is 1.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.float\", overlay=true)",
        "i_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)",
        "plot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)",
        "",
        "i_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])",
        "plot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.float](#fun_input.float) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.float(defval, title, minval, maxval, step, tooltip, inline, group, confirm, display) → input float"
      ],
      "returnedTypes": ["input float"]
    },
    {
      "name": "input.float",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a float input to the script's inputs."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where script users can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "options",
          "displayType": "tuple of const int/float values: [val1, val2, ...]",
          "desc": "A list of options to choose from a dropdown menu, separated by commas and enclosed in square brackets: [val1, val2, ...]. When using this parameter, the `minval`, `maxval` and `step` parameters cannot be used.",
          "allowedTypeIDs": ["[const float...]"]
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.float\", overlay=true)",
        "i_angle1 = input.float(0.5, \"Sin Angle\", minval=-3.14, maxval=3.14, step=0.02)",
        "plot(math.sin(i_angle1) > 0 ? close : open, \"sin\", color=color.green)",
        "",
        "i_angle2 = input.float(0, \"Cos Angle\", options=[-3.14, -1.57, 0, 1.57, 3.14])",
        "plot(math.cos(i_angle2) > 0 ? close : open, \"cos\", color=color.red)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.float](#fun_input.float) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.float(defval, title, options, tooltip, inline, group, confirm, display) → input float"
      ],
      "returnedTypes": ["input float"]
    },
    {
      "name": "input.string",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a string input to the script's inputs."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "options",
          "displayType": "tuple of const string values: [val1, val2, ...]",
          "desc": "A list of options to choose from.",
          "allowedTypeIDs": ["[const string...]"]
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.string\", overlay=true)",
        "i_text = input.string(\"Hello!\", \"Message\")",
        "l = label.new(bar_index, high, i_text)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.string](#fun_input.string) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.text_area](#fun_input.text_area)",
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.string(defval, title, options, tooltip, inline, group, confirm, display) → input string"
      ],
      "returnedTypes": ["input string"]
    },
    {
      "name": "input.text_area",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field for a multiline text input."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.none](#const_display.none).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.text_area\")",
        "i_text = input.text_area(defval = \"Hello \\nWorld!\", title = \"Message\")",
        "plot(close)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.text_area](#fun_input.text_area) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.string](#fun_input.string)",
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": ["input.text_area(defval, title, tooltip, group, confirm, display) → input string"],
      "returnedTypes": ["input string"]
    },
    {
      "name": "input.symbol",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a field that allows the user to select a specific symbol using the symbol search and returns that symbol, paired with its exchange prefix, as a string."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.symbol\", overlay=true)",
        "i_sym = input.symbol(\"DELL\", \"Symbol\")",
        "s = request.security(i_sym, 'D', close)",
        "plot(s)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.symbol](#fun_input.symbol) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.symbol(defval, title, tooltip, inline, group, confirm, display) → input string"
      ],
      "returnedTypes": ["input string"]
    },
    {
      "name": "input.timeframe",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a specific timeframe via the timeframe selector and returns it as a string. The selector includes the custom timeframes a user may have added using the chart's Timeframe dropdown."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "options",
          "displayType": "tuple of const string values: [val1, val2, ...]",
          "desc": "A list of options to choose from.",
          "allowedTypeIDs": ["[const string...]"]
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.timeframe\", overlay=true)",
        "i_res = input.timeframe('D', \"Resolution\", options=['D', 'W', 'M'])",
        "s = request.security(\"AAPL\", i_res, close)",
        "plot(s)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.timeframe](#fun_input.timeframe) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.timeframe(defval, title, options, tooltip, inline, group, confirm, display) → input string"
      ],
      "returnedTypes": ["input string"]
    },
    {
      "name": "input.session",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds two dropdowns that allow the user to specify the beginning and the end of a session using the session selector and returns the result as a string."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it. When a list of values is used with the `options` parameter, the value must be one of them.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "options",
          "displayType": "tuple of const string values: [val1, val2, ...]",
          "desc": "A list of options to choose from.",
          "allowedTypeIDs": ["[const string...]"]
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.session\", overlay=true)",
        "i_sess = input.session(\"1300-1700\", \"Session\", options=[\"0930-1600\", \"1300-1700\", \"1700-2100\"])",
        "t = time(timeframe.period, i_sess)",
        "bgcolor(time == t ? color.green : na)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.session](#fun_input.session) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.session(defval, title, options, tooltip, inline, group, confirm, display) → input string"
      ],
      "returnedTypes": ["input string"]
    },
    {
      "name": "input.source",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown that allows the user to select a source for the calculation, e.g. [close](#var_close), [hl2](#var_hl2), etc. The user can also select an output from another indicator on their chart as the source."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it.",
          "displayType": "open/high/low/close/hl2/hlc3/ohlc4/hlcc4",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ]
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.source\", overlay=true)",
        "i_src = input.source(close, \"Source\")",
        "plot(i_src)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.source](#fun_input.source) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.source(defval, title, tooltip, inline, group, display, confirm) → series float"
      ],
      "returnedTypes": ["series float"]
    },
    {
      "name": "input.color",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a color picker that allows the user to select a color and transparency, either from a palette or a hex value."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it.",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, then user will be asked to confirm input value before indicator is added to chart. Default value is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.none](#const_display.none).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.color\", overlay=true)",
        "i_col = input.color(color.red, \"Plot Color\")",
        "plot(close, color=i_col)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "Result of [input.color](#fun_input.color) function always should be assigned to a variable, see examples above."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.color(defval, title, tooltip, inline, group, confirm, display) → input color"
      ],
      "returnedTypes": ["input color"]
    },
    {
      "name": "input.time",
      "desc": [
        "Adds a time input to the script's \"Settings/Inputs\" tab. This function adds two input widgets on the same line: one for the date and one for the time. The function returns a date/time value in UNIX format. Using `confirm = true` activates the interactive input mode where a point in time is selected by clicking on the chart."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it. The value can be a [timestamp](#fun_timestamp) function, but only if it uses a date argument in const string format.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, the interactive input mode is enabled and the selection is done by clicking on the chart when the indicator is added to the chart, or by selecting the indicator and moving the selection after that. Optional. The default is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.none](#const_display.none).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.time\", overlay=true)",
        "i_date = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"Date\")",
        "l = label.new(i_date, high, \"Date\", xloc=xloc.bar_time)",
        "label.delete(l[1])"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "When using interactive mode, a price input can be combined with a time input if both function calls use the same argument for their `inline` parameter."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input](#fun_input)"
      ],
      "syntax": ["input.time(defval, title, tooltip, inline, group, confirm, display) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "input.price",
      "desc": [
        "Adds a price input to the script's \"Settings/Inputs\" tab. Using `confirm = true` activates the interactive input mode where a price is selected by clicking on the chart."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input variable proposed in the script's \"Settings/Inputs\" tab, from where the user can change it.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If true, the interactive input mode is enabled and the selection is done by clicking on the chart when the indicator is added to the chart, or by selecting the indicator and moving the selection after that. Optional. The default is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#const_display.none), [display.data_window](#const_display.data_window), [display.status_line](#const_display.status_line), [display.all](#const_display.all). Optional. The default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.price\", overlay=true)",
        "price1 = input.price(title=\"Date\", defval=42)",
        "plot(price1)",
        "",
        "price2 = input.price(54, title=\"Date\")",
        "plot(price2)"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "When using interactive mode, a time input can be combined with a price input if both function calls use the same argument for their `inline` parameter."
      ],
      "seeAlso": [
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.string](#fun_input.string)",
        "[input.text_area](#fun_input.text_area)",
        "[input.symbol](#fun_input.symbol)",
        "[input.resolution](#fun_input.resolution)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.price(defval, title, tooltip, inline, group, confirm, display) → input float"
      ],
      "returnedTypes": ["input float"]
    },
    {
      "name": "input.enum",
      "desc": [
        "Adds an input to the Inputs tab of your script's Settings, which allows you to provide configuration options to script users. This function adds a dropdown with options based on the [enum](#kw_enum) fields passed to its `defval` and `options` parameters.",
        "The text for each option in the resulting dropdown corresponds to the titles of the included fields. If a field's title is not specified in the enum declaration, its title is the string representation of its name."
      ],
      "args": [
        {
          "name": "defval",
          "desc": "Determines the default value of the input, which users can change in the script's \"Settings/Inputs\" tab. When the `options` parameter has a specified tuple of enum fields, the tuple must include the `defval`.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "const enum"
        },
        {
          "name": "title",
          "desc": "Title of the input. If not specified, the variable name is used as the input's title. If the title is specified, but it is empty, the name will be an empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "options",
          "desc": "A list of options to choose from. Optional. By default, the titles of all of the enum's fields are available in the dropdown. Passing a tuple as the `options` argument limits the list to only the included fields.",
          "displayType": "tuple of enum fields: [enumName.field1, enumName.field2, ...]",
          "allowedTypeIDs": ["[const enum...]"]
        },
        {
          "name": "tooltip",
          "desc": "The string that will be shown to the user when hovering over the tooltip icon.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "inline",
          "desc": "Combines all the input calls using the same argument in one line. The string used as an argument is not displayed. It is only used to identify inputs belonging to the same line.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "group",
          "desc": "Creates a header above all inputs using the same group argument string. The string is also used as the header's text.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "confirm",
          "desc": "If `true`, then user will be asked to confirm input value before indicator is added to chart. Default value is `false`.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the script will display the input's information, aside from within the script's settings. This option allows one to remove a specific input from the script's status line or the Data Window to ensure only the most necessary inputs are displayed there. Possible values: [display.none](#var_display.none), [display.data_window](#var_display.data_window), [display.status_line](#var_display.status_line), [display.all](#var_display.all). Optional. The default is [display.all](#var_display.all).",
          "allowedTypeIDs": ["const plot_display", "const plot_simple_display"],
          "displayType": "const plot_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Session highlight\", overlay = true)",
        "",
        "//@enum        Contains fields with popular timezones as titles.",
        "//@field exch  Has an empty string as the title to represent the chart timezone.",
        "enum tz",
        "\tutc  = \"UTC\"",
        "\texch = \"\"",
        "\tny   = \"America/New_York\"",
        "\tchi  = \"America/Chicago\"",
        "\tlon  = \"Europe/London\"",
        "\ttok  = \"Asia/Tokyo\"",
        "",
        "//@variable The session string.",
        "selectedSession = input.session(\"1200-1500\", \"Session\")",
        "//@variable The selected timezone. The input's dropdown contains the fields in the `tz` enum.",
        "selectedTimezone = input.enum(tz.utc, \"Session Timezone\")",
        "",
        "//@variable Is `true` if the current bar's time is in the specified session.",
        "bool inSession = false",
        "if not na(time(\"\", selectedSession, str.tostring(selectedTimezone)))",
        "\tinSession := true",
        "",
        "// Highlight the background when `inSession` is `true`.",
        "bgcolor(inSession ? color.new(color.green, 90) : na, title = \"Active session highlight\")"
      ],
      "returns": ["Value of input variable."],
      "remarks": [
        "All fields included in the `defval` and `options` arguments must belong to the same enum."
      ],
      "seeAlso": [
        "[input.text_area](#fun_input.text_area)",
        "[input.bool](#fun_input.bool)",
        "[input.int](#fun_input.int)",
        "[input.float](#fun_input.float)",
        "[input.symbol](#fun_input.symbol)",
        "[input.timeframe](#fun_input.timeframe)",
        "[input.session](#fun_input.session)",
        "[input.source](#fun_input.source)",
        "[input.color](#fun_input.color)",
        "[input.time](#fun_input.time)",
        "[input](#fun_input)"
      ],
      "syntax": [
        "input.enum(defval, title, options, tooltip, inline, group, confirm, display) → input enum"
      ],
      "returnedTypes": []
    },
    {
      "name": "hline",
      "desc": ["Renders a horizontal line at a given fixed price level."],
      "args": [
        {
          "name": "price",
          "desc": "Price value at which the object will be rendered. Required argument.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "title",
          "desc": "Title of the object.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "color",
          "desc": "Color of the rendered line. Must be a constant value (not an expression). Optional argument.",
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        },
        {
          "name": "linestyle",
          "desc": "Style of the rendered line. Possible values are: [hline.style_solid](#const_hline.style_solid), [hline.style_dotted](#const_hline.style_dotted), [hline.style_dashed](#const_hline.style_dashed). Optional argument.",
          "allowedTypeIDs": ["input hline_style", "const hline_style"],
          "displayType": "input hline_style"
        },
        {
          "name": "linewidth",
          "desc": "Width of the rendered line. Default value is 1.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "editable",
          "desc": "If true then hline style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "display",
          "desc": "Controls where the hline is displayed. Possible values are: [display.none](#const_display.none), [display.all](#const_display.all). Default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["input plot_simple_display", "const plot_simple_display"],
          "displayType": "input plot_simple_display"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"input.hline\", overlay=true)",
        "hline(3.14, title='Pi', color=color.blue, linestyle=hline.style_dotted, linewidth=2)",
        "",
        "// You may fill the background between any two hlines with a fill() function:",
        "h1 = hline(20)",
        "h2 = hline(10)",
        "fill(h1, h2, color=color.new(color.green, 90))"
      ],
      "returns": ["An hline object, that can be used in [fill](#fun_fill)"],
      "seeAlso": ["[fill](#fun_fill)"],
      "syntax": ["hline(price, title, color, linestyle, linewidth, editable, display) → hline"],
      "returnedTypes": ["hline"]
    },
    {
      "name": "fill",
      "desc": ["Fills background between two plots or hlines with a given color."],
      "args": [
        {
          "name": "plot1",
          "desc": "The first plot object. Required argument.",
          "required": true,
          "allowedTypeIDs": ["plot"],
          "displayType": "plot"
        },
        {
          "name": "plot2",
          "desc": "The second plot object. Required argument.",
          "required": true,
          "allowedTypeIDs": ["plot"],
          "displayType": "plot"
        },
        {
          "name": "top_value",
          "desc": "Value where the gradient uses the `top_color`.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "bottom_value",
          "desc": "Value where the gradient uses the `bottom_color`.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "top_color",
          "desc": "Color of the gradient at the topmost value.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "bottom_color",
          "desc": "Color of the gradient at the bottommost value.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "title",
          "desc": "Title of the created fill object. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "display",
          "desc": "Controls where the fill is displayed. Possible values are: [display.none](#const_display.none), [display.all](#const_display.all). Default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["input plot_simple_display", "const plot_simple_display"],
          "displayType": "input plot_simple_display"
        },
        {
          "name": "fillgaps",
          "desc": "Controls continuing fills on gaps, i.e., when one of the plot() calls returns an na value. When true, the last fill will continue on gaps. The default is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "editable",
          "desc": "If true then fill style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Fill between two horizontal lines"],
          "examples": [
            "//@version=6",
            "indicator(\"Fill between hlines\", overlay = false)",
            "h1 = hline(20)",
            "h2 = hline(10)",
            "fill(h1, h2, color = color.new(color.blue, 90))"
          ]
        },
        {
          "desc": ["Fill between two plots"],
          "examples": [
            "//@version=6",
            "indicator(\"Fill between plots\", overlay = true)",
            "p1 = plot(open)",
            "p2 = plot(close)",
            "fill(p1, p2, color = color.new(color.green, 90))"
          ]
        },
        {
          "desc": ["Gradient fill between two horizontal lines"],
          "examples": [
            "//@version=6",
            "indicator(\"Gradient Fill between hlines\", overlay = false)",
            "topVal = input.int(100)",
            "botVal = input.int(0)",
            "topCol = input.color(color.red)",
            "botCol = input.color(color.blue)",
            "topLine = hline(100, color = topCol, linestyle = hline.style_solid)",
            "botLine = hline(0,   color = botCol, linestyle = hline.style_solid)",
            "fill(topLine, botLine, topVal, botVal, topCol, botCol)"
          ]
        }
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)",
        "[hline](#fun_hline)",
        "[color.new](#fun_color.new)"
      ],
      "syntax": [
        "fill(plot1, plot2, top_value, bottom_value, top_color, bottom_color, title, display, fillgaps, editable) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "fill",
      "desc": ["Fills background between two plots or hlines with a given color."],
      "args": [
        {
          "name": "hline1",
          "desc": "The first hline object. Required argument.",
          "required": true,
          "allowedTypeIDs": ["hline"],
          "displayType": "hline"
        },
        {
          "name": "hline2",
          "desc": "The second hline object. Required argument.",
          "required": true,
          "allowedTypeIDs": ["hline"],
          "displayType": "hline"
        },
        {
          "name": "color",
          "desc": "Color of the background fill. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "title",
          "desc": "Title of the created fill object. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "editable",
          "desc": "If true then fill style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "fillgaps",
          "desc": "Controls continuing fills on gaps, i.e., when one of the plot() calls returns an na value. When true, the last fill will continue on gaps. The default is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the fill is displayed. Possible values are: [display.none](#const_display.none), [display.all](#const_display.all). Default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["input plot_simple_display", "const plot_simple_display"],
          "displayType": "input plot_simple_display"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Fill between two horizontal lines"],
          "examples": [
            "//@version=6",
            "indicator(\"Fill between hlines\", overlay = false)",
            "h1 = hline(20)",
            "h2 = hline(10)",
            "fill(h1, h2, color = color.new(color.blue, 90))"
          ]
        },
        {
          "desc": ["Fill between two plots"],
          "examples": [
            "//@version=6",
            "indicator(\"Fill between plots\", overlay = true)",
            "p1 = plot(open)",
            "p2 = plot(close)",
            "fill(p1, p2, color = color.new(color.green, 90))"
          ]
        },
        {
          "desc": ["Gradient fill between two horizontal lines"],
          "examples": [
            "//@version=6",
            "indicator(\"Gradient Fill between hlines\", overlay = false)",
            "topVal = input.int(100)",
            "botVal = input.int(0)",
            "topCol = input.color(color.red)",
            "botCol = input.color(color.blue)",
            "topLine = hline(100, color = topCol, linestyle = hline.style_solid)",
            "botLine = hline(0,   color = botCol, linestyle = hline.style_solid)",
            "fill(topLine, botLine, topVal, botVal, topCol, botCol)"
          ]
        }
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)",
        "[hline](#fun_hline)",
        "[color.new](#fun_color.new)"
      ],
      "syntax": ["fill(hline1, hline2, color, title, editable, fillgaps, display) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "fill",
      "desc": ["Fills background between two plots or hlines with a given color."],
      "args": [
        {
          "name": "plot1",
          "desc": "The first plot object. Required argument.",
          "required": true,
          "allowedTypeIDs": ["plot"],
          "displayType": "plot"
        },
        {
          "name": "plot2",
          "desc": "The second plot object. Required argument.",
          "required": true,
          "allowedTypeIDs": ["plot"],
          "displayType": "plot"
        },
        {
          "name": "color",
          "desc": "Color of the background fill. You can use constants like 'color=color.red' or 'color=#ff001a' as well as complex expressions like 'color = close >= open ? color.green : color.red'. Optional argument.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "title",
          "desc": "Title of the created fill object. Optional argument.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "editable",
          "desc": "If true then fill style will be editable in Format dialog. Default is true.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "show_last",
          "desc": "Optional. The number of bars, counting backwards from the most recent bar, on which the function can draw.",
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "fillgaps",
          "desc": "Controls continuing fills on gaps, i.e., when one of the plot() calls returns an na value. When true, the last fill will continue on gaps. The default is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "display",
          "desc": "Controls where the fill is displayed. Possible values are: [display.none](#const_display.none), [display.all](#const_display.all). Default is [display.all](#const_display.all).",
          "allowedTypeIDs": ["input plot_simple_display", "const plot_simple_display"],
          "displayType": "input plot_simple_display"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Fill between two horizontal lines"],
          "examples": [
            "//@version=6",
            "indicator(\"Fill between hlines\", overlay = false)",
            "h1 = hline(20)",
            "h2 = hline(10)",
            "fill(h1, h2, color = color.new(color.blue, 90))"
          ]
        },
        {
          "desc": ["Fill between two plots"],
          "examples": [
            "//@version=6",
            "indicator(\"Fill between plots\", overlay = true)",
            "p1 = plot(open)",
            "p2 = plot(close)",
            "fill(p1, p2, color = color.new(color.green, 90))"
          ]
        },
        {
          "desc": ["Gradient fill between two horizontal lines"],
          "examples": [
            "//@version=6",
            "indicator(\"Gradient Fill between hlines\", overlay = false)",
            "topVal = input.int(100)",
            "botVal = input.int(0)",
            "topCol = input.color(color.red)",
            "botCol = input.color(color.blue)",
            "topLine = hline(100, color = topCol, linestyle = hline.style_solid)",
            "botLine = hline(0,   color = botCol, linestyle = hline.style_solid)",
            "fill(topLine, botLine, topVal, botVal, topCol, botCol)"
          ]
        }
      ],
      "seeAlso": [
        "[plot](#fun_plot)",
        "[barcolor](#fun_barcolor)",
        "[bgcolor](#fun_bgcolor)",
        "[hline](#fun_hline)",
        "[color.new](#fun_color.new)"
      ],
      "syntax": ["fill(plot1, plot2, color, title, editable, show_last, fillgaps, display) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source) → simple color"],
      "returnedTypes": ["simple color"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "replacement",
          "desc": "Value that will replace all ‘na’ values in the `source` series.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source, replacement) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "replacement",
          "desc": "Value that will replace all ‘na’ values in the `source` series.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source, replacement) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        },
        {
          "name": "replacement",
          "desc": "Value that will replace all ‘na’ values in the `source` series.",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source, replacement) → simple color"],
      "returnedTypes": ["simple color"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "replacement",
          "desc": "Value that will replace all ‘na’ values in the `source` series.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source, replacement) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "replacement",
          "desc": "Value that will replace all ‘na’ values in the `source` series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source, replacement) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "nz",
      "desc": ["Replaces NaN values with zeros (or given value) in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "replacement",
          "desc": "Value that will replace all ‘na’ values in the `source` series.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"nz\", overlay=true)",
        "plot(nz(ta.sma(close, 100)))"
      ],
      "returns": [
        "The value of `source` if it is not `na`. If the value of `source` is `na`, returns zero, or the `replacement` argument when one is used."
      ],
      "seeAlso": ["[na](#var_na)", "[na](#fun_na)", "[fixnan](#fun_fixnan)"],
      "syntax": ["nz(source, replacement) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "na",
      "desc": ["Tests if `x` is [na](#var_na)."],
      "args": [
        {
          "name": "x",
          "desc": "Value to be tested.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"na\")",
        "// Use the `na()` function to test for `na`.",
        "plot(na(close[1]) ? close : close[1])",
        "// ALTERNATIVE",
        "// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.",
        "plot(nz(close[1], close))"
      ],
      "returns": [
        "Returns [true](#const_true) if `x` is [na](#var_na), [false](#const_false) otherwise."
      ],
      "seeAlso": ["[na](#var_na)", "[fixnan](#fun_fixnan)", "[nz](#fun_nz)"],
      "syntax": ["na(x) → simple bool"],
      "returnedTypes": ["simple bool"]
    },
    {
      "name": "na",
      "desc": ["Tests if `x` is [na](#var_na)."],
      "args": [
        {
          "name": "x",
          "desc": "Value to be tested.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series color",
            "simple color",
            "input color",
            "const color",
            "series string",
            "simple string",
            "input string",
            "const string",
            "series label",
            "series line",
            "series box",
            "series table",
            "series linefill",
            "series polyline",
            "array<>",
            "matrix<>"
          ],
          "displayType": "series int/float/color/string/label/line/box/table/linefill/polyline/array<>/matrix<>/map<>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"na\")",
        "// Use the `na()` function to test for `na`.",
        "plot(na(close[1]) ? close : close[1])",
        "// ALTERNATIVE",
        "// `nz()` also tests `close[1]` for `na`. It returns `close[1]` if it is not `na`, and `close` if it is.",
        "plot(nz(close[1], close))"
      ],
      "returns": [
        "Returns [true](#const_true) if `x` is [na](#var_na), [false](#const_false) otherwise."
      ],
      "seeAlso": ["[na](#var_na)", "[fixnan](#fun_fixnan)", "[nz](#fun_nz)"],
      "syntax": ["na(x) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.tr",
      "desc": [
        "Calculates the current bar's true range. Unlike a bar's actual range (`high - low`), true range accounts for potential gaps by taking the maximum of the current bar's actual range and the absolute distances from the previous bar's [close](#var_close) to the current bar's [high](#var_high) and [low](#var_low). The formula is: `math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1]))`"
      ],
      "args": [
        {
          "name": "handle_na",
          "desc": "Defines how the function calculates the result when the previous bar's [close](#var_close) is [na](#var_na). If [true](#const_true), the function returns the bar's `high - low` value. If [false](#const_false), it returns [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["simple bool", "input bool", "const bool"],
          "displayType": "simple bool"
        }
      ],
      "returns": [
        "True range. It is math.max(high - low, math.abs(high - close[1]), math.abs(low - close[1]))."
      ],
      "remarks": ["ta.tr(false) is exactly the same as [ta.tr](#var_ta.tr)."],
      "seeAlso": ["[ta.tr](#var_ta.tr)", "[ta.atr](#fun_ta.atr)"],
      "syntax": ["ta.tr(handle_na) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.pow",
      "desc": ["Mathematical power function."],
      "args": [
        {
          "name": "base",
          "desc": "Specify the base to use.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "exponent",
          "desc": "Specifies the exponent.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.pow\", overlay=true)",
        "plot(math.pow(close, 2))"
      ],
      "returns": [
        "`base` raised to the power of `exponent`. If `base` is a series, it is calculated elementwise."
      ],
      "seeAlso": ["[math.sqrt](#fun_math.sqrt)", "[math.exp](#fun_math.exp)"],
      "syntax": ["math.pow(base, exponent) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.pow",
      "desc": ["Mathematical power function."],
      "args": [
        {
          "name": "base",
          "desc": "Specify the base to use.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "exponent",
          "desc": "Specifies the exponent.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.pow\", overlay=true)",
        "plot(math.pow(close, 2))"
      ],
      "returns": [
        "`base` raised to the power of `exponent`. If `base` is a series, it is calculated elementwise."
      ],
      "seeAlso": ["[math.sqrt](#fun_math.sqrt)", "[math.exp](#fun_math.exp)"],
      "syntax": ["math.pow(base, exponent) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.pow",
      "desc": ["Mathematical power function."],
      "args": [
        {
          "name": "base",
          "desc": "Specify the base to use.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "exponent",
          "desc": "Specifies the exponent.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.pow\", overlay=true)",
        "plot(math.pow(close, 2))"
      ],
      "returns": [
        "`base` raised to the power of `exponent`. If `base` is a series, it is calculated elementwise."
      ],
      "seeAlso": ["[math.sqrt](#fun_math.sqrt)", "[math.exp](#fun_math.exp)"],
      "syntax": ["math.pow(base, exponent) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.pow",
      "desc": ["Mathematical power function."],
      "args": [
        {
          "name": "base",
          "desc": "Specify the base to use.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "exponent",
          "desc": "Specifies the exponent.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.pow\", overlay=true)",
        "plot(math.pow(close, 2))"
      ],
      "returns": [
        "`base` raised to the power of `exponent`. If `base` is a series, it is calculated elementwise."
      ],
      "seeAlso": ["[math.sqrt](#fun_math.sqrt)", "[math.exp](#fun_math.exp)"],
      "syntax": ["math.pow(base, exponent) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.min",
      "desc": ["Returns the smallest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.min\", overlay=true)",
        "plot(math.min(close, open))",
        "plot(math.min(close, math.min(open, 42)))"
      ],
      "returns": ["The smallest of multiple given values."],
      "seeAlso": ["[math.max](#fun_math.max)"],
      "syntax": ["math.min(number0, number1, ...) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.max",
      "desc": ["Returns the greatest of multiple values."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"math.max\", overlay=true)",
        "plot(math.max(close, open))",
        "plot(math.max(close, math.max(open, 42)))"
      ],
      "returns": ["The greatest of multiple given values."],
      "seeAlso": ["[math.min](#fun_math.min)"],
      "syntax": ["math.max(number0, number1, ...) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "str.format",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string. The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the str.format argument list."
      ],
      "args": [
        {
          "name": "formatString",
          "desc": "Format string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "arg0, arg1, ...",
          "desc": "Values to format.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float",
            "simple bool",
            "input bool",
            "const bool",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "simple int/float/bool/string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.format\", overlay=true)",
        "// The format specifier inside the curly braces accepts certain modifiers:",
        "// - Specify the number of decimals to display:",
        "s1 = str.format(\"{0,number,#.#}\", 1.34) // returns: 1.3",
        "label.new(bar_index, close, text=s1)",
        "// - Round a float value to an integer:",
        "s2 = str.format(\"{0,number,integer}\", 1.34) // returns: 1",
        "label.new(bar_index - 1, close, text=s2)",
        "// - Display a number in currency:",
        "s3 = str.format(\"{0,number,currency}\", 1.34) // returns: $1.34",
        "label.new(bar_index - 2, close, text=s3)",
        "// - Display a number as a percentage:",
        "s4 = str.format(\"{0,number,percent}\", 0.5) // returns: 50%",
        "label.new(bar_index - 3, close, text=s4)",
        "// EXAMPLES WITH SEVERAL ARGUMENTS",
        "// returns: Number 1 is not equal to 4",
        "s5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)",
        "label.new(bar_index - 4, close, text=s5)",
        "// returns: 1.34 != 1.3",
        "s6 = str.format(\"{0} != {0, number, #.#}\", 1.34)",
        "label.new(bar_index - 5, close, text=s6)",
        "// returns: 1 is equal to 1, but 2 is equal to 2",
        "s7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)",
        "label.new(bar_index - 6, close, text=s7)",
        "// returns: The cash turnover amounted to $1,340,000.00",
        "s8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)",
        "label.new(bar_index - 7, close, text=s8)",
        "// returns: Expected return is 10% - 20%",
        "s9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)",
        "label.new(bar_index - 8, close, text=s9)"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "By default, formatted numbers will display up to three decimals with no trailing zeros.",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not."
      ],
      "syntax": ["str.format(formatString, arg0, arg1, ...) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.format",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string. The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the str.format argument list."
      ],
      "args": [
        {
          "name": "formatString",
          "desc": "Format string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "arg0, arg1, ...",
          "desc": "Values to format.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series string",
            "simple string",
            "input string",
            "const string",
            "array<int>",
            "array<float>",
            "array<bool>",
            "array<string>"
          ],
          "displayType": "series int/float/bool/string/array<int/float/bool/string>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.format\", overlay=true)",
        "// The format specifier inside the curly braces accepts certain modifiers:",
        "// - Specify the number of decimals to display:",
        "s1 = str.format(\"{0,number,#.#}\", 1.34) // returns: 1.3",
        "label.new(bar_index, close, text=s1)",
        "// - Round a float value to an integer:",
        "s2 = str.format(\"{0,number,integer}\", 1.34) // returns: 1",
        "label.new(bar_index - 1, close, text=s2)",
        "// - Display a number in currency:",
        "s3 = str.format(\"{0,number,currency}\", 1.34) // returns: $1.34",
        "label.new(bar_index - 2, close, text=s3)",
        "// - Display a number as a percentage:",
        "s4 = str.format(\"{0,number,percent}\", 0.5) // returns: 50%",
        "label.new(bar_index - 3, close, text=s4)",
        "// EXAMPLES WITH SEVERAL ARGUMENTS",
        "// returns: Number 1 is not equal to 4",
        "s5 = str.format(\"Number {0} is not {1} to {2}\", 1, \"equal\", 4)",
        "label.new(bar_index - 4, close, text=s5)",
        "// returns: 1.34 != 1.3",
        "s6 = str.format(\"{0} != {0, number, #.#}\", 1.34)",
        "label.new(bar_index - 5, close, text=s6)",
        "// returns: 1 is equal to 1, but 2 is equal to 2",
        "s7 = str.format(\"{0, number, integer} is equal to 1, but {1, number, integer} is equal to 2\", 1.34, 1.52)",
        "label.new(bar_index - 6, close, text=s7)",
        "// returns: The cash turnover amounted to $1,340,000.00",
        "s8 = str.format(\"The cash turnover amounted to {0, number, currency}\", 1340000)",
        "label.new(bar_index - 7, close, text=s8)",
        "// returns: Expected return is 10% - 20%",
        "s9 = str.format(\"Expected return is {0, number, percent} - {1, number, percent}\", 0.1, 0.2)",
        "label.new(bar_index - 8, close, text=s9)"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "By default, formatted numbers will display up to three decimals with no trailing zeros.",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not."
      ],
      "syntax": ["str.format(formatString, arg0, arg1, ...) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.format_time",
      "desc": [
        "Converts the `time` timestamp into a string formatted according to `format` and `timezone`."
      ],
      "args": [
        {
          "name": "time",
          "desc": "UNIX time, in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "format",
          "desc": "A format string specifying the date/time representation of the `time` in the returned string. All letters used in the string, except those escaped by single quotation marks `'`, are considered formatting tokens and will be used as a formatting instruction. Refer to the Remarks section for a list of the most useful tokens. Optional. The default is \"yyyy-MM-dd'T'HH:mm:ssZ\", which represents the ISO 8601 standard.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an [IANA time zone database name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.format_time\")",
        "if timeframe.change(\"1D\")",
        "\tformattedTime = str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone)",
        "\tlabel.new(bar_index, high, formattedTime)"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "The `M`, `d`, `h`, `H`, `m` and `s` tokens can all be doubled to generate leading zeros. For example, the month of January will display as `1` with `M`, or `01` with `MM`.",
        "",
        "The most frequently used formatting tokens are:",
        "",
        "y - Year. Use `yy` to output the last two digits of the year or `yyyy` to output all four. Year 2000 will be `00` with `yy` or `2000` with `yyyy`.",
        "M - Month. Not to be confused with lowercase `m`, which stands for minute.",
        "d - Day of the month.",
        "a - AM/PM postfix.",
        "h - Hour in the 12-hour format. The last hour of the day will be `11` in this format.",
        "H - Hour in the 24-hour format. The last hour of the day will be `23` in this format.",
        "m - Minute.",
        "s - Second.",
        "S - Fractions of a second.",
        "Z - Timezone, the HHmm offset from UTC, preceded by either `+` or `-`."
      ],
      "syntax": ["str.format_time(time, format, timezone) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.abs",
      "desc": ["Absolute value of `number` is `number` if `number` >= 0, or -`number` otherwise."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The absolute value of `number`."],
      "syntax": ["math.abs(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.log",
      "desc": ["Natural logarithm of any `number` > 0 is the unique y such that e^y = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The natural logarithm of `number`."],
      "seeAlso": ["[math.log10](#fun_math.log10)"],
      "syntax": ["math.log(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.log",
      "desc": ["Natural logarithm of any `number` > 0 is the unique y such that e^y = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The natural logarithm of `number`."],
      "seeAlso": ["[math.log10](#fun_math.log10)"],
      "syntax": ["math.log(number) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.log",
      "desc": ["Natural logarithm of any `number` > 0 is the unique y such that e^y = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The natural logarithm of `number`."],
      "seeAlso": ["[math.log10](#fun_math.log10)"],
      "syntax": ["math.log(number) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.log",
      "desc": ["Natural logarithm of any `number` > 0 is the unique y such that e^y = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The natural logarithm of `number`."],
      "seeAlso": ["[math.log10](#fun_math.log10)"],
      "syntax": ["math.log(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.log10",
      "desc": [
        "The common (or base 10) logarithm of `number` is the power to which 10 must be raised to obtain the `number`. 10^y = `number`."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The base 10 logarithm of `number`."],
      "seeAlso": ["[math.log](#fun_math.log)"],
      "syntax": ["math.log10(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.log10",
      "desc": [
        "The common (or base 10) logarithm of `number` is the power to which 10 must be raised to obtain the `number`. 10^y = `number`."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The base 10 logarithm of `number`."],
      "seeAlso": ["[math.log](#fun_math.log)"],
      "syntax": ["math.log10(number) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.log10",
      "desc": [
        "The common (or base 10) logarithm of `number` is the power to which 10 must be raised to obtain the `number`. 10^y = `number`."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The base 10 logarithm of `number`."],
      "seeAlso": ["[math.log](#fun_math.log)"],
      "syntax": ["math.log10(number) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.log10",
      "desc": [
        "The common (or base 10) logarithm of `number` is the power to which 10 must be raised to obtain the `number`. 10^y = `number`."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The base 10 logarithm of `number`."],
      "seeAlso": ["[math.log](#fun_math.log)"],
      "syntax": ["math.log10(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.sqrt",
      "desc": ["Square root of any `number` >= 0 is the unique y >= 0 such that y^2 = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The square root of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.sqrt(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.sqrt",
      "desc": ["Square root of any `number` >= 0 is the unique y >= 0 such that y^2 = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The square root of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.sqrt(number) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.sqrt",
      "desc": ["Square root of any `number` >= 0 is the unique y >= 0 such that y^2 = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The square root of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.sqrt(number) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.sqrt",
      "desc": ["Square root of any `number` >= 0 is the unique y >= 0 such that y^2 = `number`."],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The square root of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.sqrt(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.sign",
      "desc": [
        "Sign (signum) of `number` is zero if `number` is zero, 1.0 if `number` is greater than zero, -1.0 if `number` is less than zero."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The sign of the argument."],
      "syntax": ["math.sign(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.sign",
      "desc": [
        "Sign (signum) of `number` is zero if `number` is zero, 1.0 if `number` is greater than zero, -1.0 if `number` is less than zero."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The sign of the argument."],
      "syntax": ["math.sign(number) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.sign",
      "desc": [
        "Sign (signum) of `number` is zero if `number` is zero, 1.0 if `number` is greater than zero, -1.0 if `number` is less than zero."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The sign of the argument."],
      "syntax": ["math.sign(number) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.sign",
      "desc": [
        "Sign (signum) of `number` is zero if `number` is zero, 1.0 if `number` is greater than zero, -1.0 if `number` is less than zero."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The sign of the argument."],
      "syntax": ["math.sign(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.exp",
      "desc": [
        "The exp function of `number` is e raised to the power of `number`, where e is Euler's number."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["A value representing e raised to the power of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.exp(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.exp",
      "desc": [
        "The exp function of `number` is e raised to the power of `number`, where e is Euler's number."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["A value representing e raised to the power of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.exp(number) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.exp",
      "desc": [
        "The exp function of `number` is e raised to the power of `number`, where e is Euler's number."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["A value representing e raised to the power of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.exp(number) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.exp",
      "desc": [
        "The exp function of `number` is e raised to the power of `number`, where e is Euler's number."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["A value representing e raised to the power of `number`."],
      "seeAlso": ["[math.pow](#fun_math.pow)"],
      "syntax": ["math.exp(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.sin",
      "desc": ["The sin function returns the trigonometric sine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The trigonometric sine of an angle."],
      "syntax": ["math.sin(angle) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.sin",
      "desc": ["The sin function returns the trigonometric sine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The trigonometric sine of an angle."],
      "syntax": ["math.sin(angle) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.sin",
      "desc": ["The sin function returns the trigonometric sine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The trigonometric sine of an angle."],
      "syntax": ["math.sin(angle) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.sin",
      "desc": ["The sin function returns the trigonometric sine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The trigonometric sine of an angle."],
      "syntax": ["math.sin(angle) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.cos",
      "desc": ["The cos function returns the trigonometric cosine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The trigonometric cosine of an angle."],
      "syntax": ["math.cos(angle) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.cos",
      "desc": ["The cos function returns the trigonometric cosine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The trigonometric cosine of an angle."],
      "syntax": ["math.cos(angle) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.cos",
      "desc": ["The cos function returns the trigonometric cosine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The trigonometric cosine of an angle."],
      "syntax": ["math.cos(angle) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.cos",
      "desc": ["The cos function returns the trigonometric cosine of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The trigonometric cosine of an angle."],
      "syntax": ["math.cos(angle) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.tan",
      "desc": ["The tan function returns the trigonometric tangent of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The trigonometric tangent of an angle."],
      "syntax": ["math.tan(angle) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.tan",
      "desc": ["The tan function returns the trigonometric tangent of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The trigonometric tangent of an angle."],
      "syntax": ["math.tan(angle) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.tan",
      "desc": ["The tan function returns the trigonometric tangent of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The trigonometric tangent of an angle."],
      "syntax": ["math.tan(angle) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.tan",
      "desc": ["The tan function returns the trigonometric tangent of an angle."],
      "args": [
        {
          "name": "angle",
          "desc": "Angle, in radians.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The trigonometric tangent of an angle."],
      "syntax": ["math.tan(angle) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.asin",
      "desc": [
        "The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": [
        "The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.asin(angle) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.asin",
      "desc": [
        "The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": [
        "The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.asin(angle) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.asin",
      "desc": [
        "The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": [
        "The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.asin(angle) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.asin",
      "desc": [
        "The asin function returns the arcsine (in radians) of number such that sin(asin(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": [
        "The arcsine of a value; the returned angle is in the range [-Pi/2, Pi/2], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.asin(angle) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.acos",
      "desc": [
        "The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": [
        "The arc cosine of a value; the returned angle is in the range [0, Pi], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.acos(angle) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.acos",
      "desc": [
        "The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": [
        "The arc cosine of a value; the returned angle is in the range [0, Pi], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.acos(angle) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.acos",
      "desc": [
        "The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": [
        "The arc cosine of a value; the returned angle is in the range [0, Pi], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.acos(angle) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.acos",
      "desc": [
        "The acos function returns the arccosine (in radians) of number such that cos(acos(y)) = y for y in range [-1, 1]."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": [
        "The arc cosine of a value; the returned angle is in the range [0, Pi], or [na](#var_na) if y is outside of range [-1, 1]."
      ],
      "syntax": ["math.acos(angle) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.atan",
      "desc": [
        "The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2]."],
      "syntax": ["math.atan(angle) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.atan",
      "desc": [
        "The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2]."],
      "syntax": ["math.atan(angle) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.atan",
      "desc": [
        "The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2]."],
      "syntax": ["math.atan(angle) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.atan",
      "desc": [
        "The atan function returns the arctangent (in radians) of number such that tan(atan(y)) = y for any y."
      ],
      "args": [
        {
          "name": "angle",
          "desc": "The value, in radians, to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The arc tangent of a value; the returned angle is in the range [-Pi/2, Pi/2]."],
      "syntax": ["math.atan(angle) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.ceil",
      "desc": [
        "Rounds the specified `number` up to the smallest whole number (\"int\" value) that is greater than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The smallest \"int\" value that is greater than or equal to the `number`."],
      "seeAlso": ["[math.floor](#fun_math.floor)", "[math.round](#fun_math.round)"],
      "syntax": ["math.ceil(number) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "math.ceil",
      "desc": [
        "Rounds the specified `number` up to the smallest whole number (\"int\" value) that is greater than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The smallest \"int\" value that is greater than or equal to the `number`."],
      "seeAlso": ["[math.floor](#fun_math.floor)", "[math.round](#fun_math.round)"],
      "syntax": ["math.ceil(number) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "math.ceil",
      "desc": [
        "Rounds the specified `number` up to the smallest whole number (\"int\" value) that is greater than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The smallest \"int\" value that is greater than or equal to the `number`."],
      "seeAlso": ["[math.floor](#fun_math.floor)", "[math.round](#fun_math.round)"],
      "syntax": ["math.ceil(number) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "math.ceil",
      "desc": [
        "Rounds the specified `number` up to the smallest whole number (\"int\" value) that is greater than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The smallest \"int\" value that is greater than or equal to the `number`."],
      "seeAlso": ["[math.floor](#fun_math.floor)", "[math.round](#fun_math.round)"],
      "syntax": ["math.ceil(number) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.floor",
      "desc": [
        "Rounds the specified `number` down to the largest whole number (\"int\" value) that is less than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The largest \"int\" value that is less than or equal to the `number`."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.round](#fun_math.round)"],
      "syntax": ["math.floor(number) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "math.floor",
      "desc": [
        "Rounds the specified `number` down to the largest whole number (\"int\" value) that is less than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The largest \"int\" value that is less than or equal to the `number`."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.round](#fun_math.round)"],
      "syntax": ["math.floor(number) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "math.floor",
      "desc": [
        "Rounds the specified `number` down to the largest whole number (\"int\" value) that is less than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The largest \"int\" value that is less than or equal to the `number`."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.round](#fun_math.round)"],
      "syntax": ["math.floor(number) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "math.floor",
      "desc": [
        "Rounds the specified `number` down to the largest whole number (\"int\" value) that is less than or equal to it."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The number to round.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The largest \"int\" value that is less than or equal to the `number`."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.round](#fun_math.round)"],
      "syntax": ["math.floor(number) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "precision",
          "desc": "Optional argument. Decimal places to which `number` will be rounded. When no argument is supplied, rounding is to the nearest integer.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number, precision) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        },
        {
          "name": "precision",
          "desc": "Optional argument. Decimal places to which `number` will be rounded. When no argument is supplied, rounding is to the nearest integer.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number, precision) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "precision",
          "desc": "Optional argument. Decimal places to which `number` will be rounded. When no argument is supplied, rounding is to the nearest integer.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number, precision) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "math.round",
      "desc": [
        "Returns the value of `number` rounded to the nearest integer, with ties rounding up. If the `precision` parameter is used, returns a float value rounded to that amount of decimal places."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "precision",
          "desc": "Optional argument. Decimal places to which `number` will be rounded. When no argument is supplied, rounding is to the nearest integer.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": [
        "The value of `number` rounded to the nearest integer, or according to precision."
      ],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round(number, precision) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.round_to_mintick",
      "desc": [
        "Returns the value rounded to the symbol's mintick, i.e. the nearest value that can be divided by [syminfo.mintick](#var_syminfo.mintick), without the remainder, with ties rounding up."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The `number` rounded to tick precision."],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round_to_mintick(number) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.round_to_mintick",
      "desc": [
        "Returns the value rounded to the symbol's mintick, i.e. the nearest value that can be divided by [syminfo.mintick](#var_syminfo.mintick), without the remainder, with ties rounding up."
      ],
      "args": [
        {
          "name": "number",
          "desc": "The value to be rounded.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The `number` rounded to tick precision."],
      "remarks": ["Note that for 'na' values function returns 'na'."],
      "seeAlso": ["[math.ceil](#fun_math.ceil)", "[math.floor](#fun_math.floor)"],
      "syntax": ["math.round_to_mintick(number) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.median",
      "desc": ["Returns the median of the series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["The median of the series."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.median(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.median",
      "desc": ["Returns the median of the series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["The median of the series."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.median(source, length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.max",
      "desc": [
        "Returns the all-time high value of `source` from the beginning of the chart up to the current bar."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": ["[na](#var_na) occurrences of `source` are ignored."],
      "syntax": ["ta.max(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.min",
      "desc": [
        "Returns the all-time low value of `source` from the beginning of the chart up to the current bar."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": ["[na](#var_na) occurrences of `source` are ignored."],
      "syntax": ["ta.min(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.mode",
      "desc": [
        "Returns the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the series. If there are several values with the same frequency, it returns the smallest value."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": [
        "The most frequently occurring value from the `source`. If none exists, returns the smallest value instead."
      ],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.mode(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.mode",
      "desc": [
        "Returns the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the series. If there are several values with the same frequency, it returns the smallest value."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": [
        "The most frequently occurring value from the `source`. If none exists, returns the smallest value instead."
      ],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.mode(source, length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.range",
      "desc": ["Returns the difference between the min and max values in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["The difference between the min and max values in the series."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.range(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.range",
      "desc": ["Returns the difference between the min and max values in a series."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["The difference between the min and max values in the series."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.range(source, length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "math.todegrees",
      "desc": [
        "Returns an approximately equivalent angle in degrees from an angle measured in radians."
      ],
      "args": [
        {
          "name": "radians",
          "desc": "Angle in radians.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The angle value in degrees."],
      "syntax": ["math.todegrees(radians) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.toradians",
      "desc": [
        "Returns an approximately equivalent angle in radians from an angle measured in degrees."
      ],
      "args": [
        {
          "name": "degrees",
          "desc": "Angle in degrees.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The angle value in radians."],
      "syntax": ["math.toradians(degrees) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.random",
      "desc": [
        "Returns a pseudo-random value. The function will generate a different sequence of values for each script execution. Using the same value for the optional seed argument will produce a repeatable sequence."
      ],
      "args": [
        {
          "name": "min",
          "desc": "The lower bound of the range of random values. The value is not included in the range. The default is 0.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "max",
          "desc": "The upper bound of the range of random values. The value is not included in the range. The default is 1.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "seed",
          "desc": "Optional argument. When the same seed is used, allows successive calls to the function to produce a repeatable set of values.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["A random value."],
      "syntax": ["math.random(min, max, seed) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "math.sum",
      "desc": ["The sum function returns the sliding sum of last y values of x."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Sum of `source` for `length` bars back."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.cum](#fun_ta.cum)", "[for](#kw_for)"],
      "syntax": ["math.sum(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.sma",
      "desc": [
        "The sma function returns the moving average, that is the sum of last y values of x, divided by y."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.sma\")",
        "plot(ta.sma(close, 15))",
        "",
        "// same on pine, but much less efficient",
        "pine_sma(x, y) =>",
        "    sum = 0.0",
        "    for i = 0 to y - 1",
        "        sum := sum + x[i] / y",
        "    sum",
        "plot(pine_sma(close, 15))"
      ],
      "returns": ["Simple moving average of `source` for `length` bars back."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": [
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.swma](#fun_ta.swma)",
        "[ta.alma](#fun_ta.alma)"
      ],
      "syntax": ["ta.sma(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.hma",
      "desc": ["The hma function returns the Hull Moving Average."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Hull Moving Average\")",
        "src = input(defval=close, title=\"Source\")",
        "length = input(defval=9, title=\"Length\")",
        "hmaBuildIn = ta.hma(src, length)",
        "plot(hmaBuildIn, title=\"Hull MA\", color=#674EA7)"
      ],
      "returns": ["Hull moving average of 'source' for 'length' bars back."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": [
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.sma](#fun_ta.sma)"
      ],
      "syntax": ["ta.hma(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.ema",
      "desc": [
        "The ema function returns the exponentially weighted moving average. In ema weighting factors decrease exponentially. It calculates by using a formula: `EMA = alpha * source + (1 - alpha) * EMA[1]`, where `alpha = 2 / (length + 1)`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.ema\")",
        "plot(ta.ema(close, 15))",
        "",
        "//the same on pine",
        "pine_ema(src, length) =>",
        "    alpha = 2 / (length + 1)",
        "    sum = 0.0",
        "    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])",
        "plot(pine_ema(close,15))"
      ],
      "returns": ["Exponential moving average of `source` with alpha = 2 / (length + 1)."],
      "remarks": [
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/).",
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.swma](#fun_ta.swma)",
        "[ta.alma](#fun_ta.alma)"
      ],
      "syntax": ["ta.ema(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.wma",
      "desc": [
        "The wma function returns weighted moving average of `source` for `length` bars back. In wma weighting factors decrease in arithmetical progression."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.wma\")",
        "plot(ta.wma(close, 15))",
        "",
        "// same on pine, but much less efficient",
        "pine_wma(x, y) =>",
        "    norm = 0.0",
        "    sum = 0.0",
        "    for i = 0 to y - 1",
        "        weight = (y - i) * y",
        "        norm := norm + weight",
        "        sum := sum + x[i] * weight",
        "    sum / norm",
        "plot(pine_wma(close, 15))"
      ],
      "returns": ["Weighted moving average of `source` for `length` bars back."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.swma](#fun_ta.swma)",
        "[ta.alma](#fun_ta.alma)"
      ],
      "syntax": ["ta.wma(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.vwma",
      "desc": [
        "The vwma function returns volume-weighted moving average of `source` for `length` bars back. It is the same as: sma(source * volume, length) / sma(volume, length)."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.vwma\")",
        "plot(ta.vwma(close, 15))",
        "",
        "// same on pine, but less efficient",
        "pine_vwma(x, y) =>",
        "    ta.sma(x * volume, y) / ta.sma(volume, y)",
        "plot(pine_vwma(close, 15))"
      ],
      "returns": ["Volume-weighted moving average of `source` for `length` bars back."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.swma](#fun_ta.swma)",
        "[ta.alma](#fun_ta.alma)"
      ],
      "syntax": ["ta.vwma(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.supertrend",
      "desc": ["The Supertrend Indicator. The Supertrend is a trend following indicator."],
      "args": [
        {
          "name": "factor",
          "desc": "The multiplier by which the ATR will get multiplied.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "atrPeriod",
          "desc": "Length of ATR.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Pine Script® Supertrend\")",
        "",
        "[supertrend, direction] = ta.supertrend(3, 10)",
        "plot(direction < 0 ? supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)",
        "plot(direction > 0 ? supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)",
        "",
        "// The same on Pine Script®",
        "pine_supertrend(factor, atrPeriod) =>",
        "\tsrc = hl2",
        "\tatr = ta.atr(atrPeriod)",
        "\tupperBand = src + factor * atr",
        "\tlowerBand = src - factor * atr",
        "\tprevLowerBand = nz(lowerBand[1])",
        "\tprevUpperBand = nz(upperBand[1])",
        "",
        "\tlowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand",
        "\tupperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand",
        "\tint _direction = na",
        "\tfloat superTrend = na",
        "\tprevSuperTrend = superTrend[1]",
        "\tif na(atr[1])",
        "\t\t_direction := 1",
        "\telse if prevSuperTrend == prevUpperBand",
        "\t\t_direction := close > upperBand ? -1 : 1",
        "\telse",
        "\t\t_direction := close < lowerBand ? 1 : -1",
        "\tsuperTrend := _direction == -1 ? lowerBand : upperBand",
        "\t[superTrend, _direction]",
        "",
        "[Pine_Supertrend, pineDirection] = pine_supertrend(3, 10)",
        "plot(pineDirection < 0 ? Pine_Supertrend : na, \"Up direction\", color = color.green, style=plot.style_linebr)",
        "plot(pineDirection > 0 ? Pine_Supertrend : na, \"Down direction\", color = color.red, style=plot.style_linebr)"
      ],
      "returns": [
        "[Tuple](https://www.tradingview.com/pine-script-docs/language/type-system/#tuples) of two supertrend series: supertrend line and direction of trend. Possible values are 1 (down direction) and -1 (up direction)."
      ],
      "seeAlso": ["[ta.macd](#fun_ta.macd)"],
      "syntax": ["ta.supertrend(factor, atrPeriod) → [series float, series float]"],
      "returnedTypes": ["[series float, series float]"]
    },
    {
      "name": "ta.macd",
      "desc": [
        "MACD (moving average convergence/divergence). It is supposed to reveal changes in the strength, direction, momentum, and duration of a trend in a stock's price."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "fastlen",
          "desc": "Fast Length parameter.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "slowlen",
          "desc": "Slow Length parameter.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "siglen",
          "desc": "Signal Length parameter.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"MACD\")",
            "[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)",
            "plot(macdLine, color=color.blue)",
            "plot(signalLine, color=color.orange)",
            "plot(histLine, color=color.red, style=plot.style_histogram)"
          ]
        },
        {
          "desc": ["If you need only one value, use placeholders '_' like this:"],
          "examples": [
            "//@version=6",
            "indicator(\"MACD\")",
            "[_, signalLine, _] = ta.macd(close, 12, 26, 9)",
            "plot(signalLine, color=color.orange)"
          ]
        }
      ],
      "returns": [
        "[Tuple](https://www.tradingview.com/pine-script-docs/language/type-system/#tuples) of three MACD series: MACD line, signal line and histogram line."
      ],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.sma](#fun_ta.sma)", "[ta.ema](#fun_ta.ema)"],
      "syntax": [
        "ta.macd(source, fastlen, slowlen, siglen) → [series float, series float, series float]"
      ],
      "returnedTypes": ["[series float, series float, series float]"]
    },
    {
      "name": "ta.lowest",
      "desc": ["Lowest value for a given number of bars back."],
      "args": [
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Lowest value in the series."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses low as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.valuewhen](#fun_ta.valuewhen)",
        "[ta.barssince](#fun_ta.barssince)"
      ],
      "syntax": ["ta.lowest(length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.lowest",
      "desc": ["Lowest value for a given number of bars back."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Lowest value in the series."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses low as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.valuewhen](#fun_ta.valuewhen)",
        "[ta.barssince](#fun_ta.barssince)"
      ],
      "syntax": ["ta.lowest(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.highest",
      "desc": ["Highest value for a given number of bars back."],
      "args": [
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Highest value in the series."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses high as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.lowest](#fun_ta.lowest)",
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.valuewhen](#fun_ta.valuewhen)",
        "[ta.barssince](#fun_ta.barssince)"
      ],
      "syntax": ["ta.highest(length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.highest",
      "desc": ["Highest value for a given number of bars back."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Highest value in the series."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses high as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.lowest](#fun_ta.lowest)",
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.valuewhen](#fun_ta.valuewhen)",
        "[ta.barssince](#fun_ta.barssince)"
      ],
      "syntax": ["ta.highest(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.lowestbars",
      "desc": ["Lowest value offset for a given number of bars back."],
      "args": [
        {
          "name": "length",
          "desc": "Number of bars back.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Offset to the lowest bar."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses low as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.lowest](#fun_ta.lowest)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.valuewhen](#fun_ta.valuewhen)"
      ],
      "syntax": ["ta.lowestbars(length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.lowestbars",
      "desc": ["Lowest value offset for a given number of bars back."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars back.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Offset to the lowest bar."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses low as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.lowest](#fun_ta.lowest)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.valuewhen](#fun_ta.valuewhen)"
      ],
      "syntax": ["ta.lowestbars(source, length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.highestbars",
      "desc": ["Highest value offset for a given number of bars back."],
      "args": [
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Offset to the highest bar."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses high as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.lowest](#fun_ta.lowest)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.valuewhen](#fun_ta.valuewhen)"
      ],
      "syntax": ["ta.highestbars(length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.highestbars",
      "desc": ["Highest value offset for a given number of bars back."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Offset to the highest bar."],
      "remarks": [
        "Two args version: `source` is a series and `length` is the number of bars back.",
        "One arg version: `length` is the number of bars back. Algorithm uses high as a `source` series.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.lowest](#fun_ta.lowest)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.valuewhen](#fun_ta.valuewhen)"
      ],
      "syntax": ["ta.highestbars(source, length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.barssince",
      "desc": ["Counts the number of bars since the last time the condition was true."],
      "args": [
        {
          "name": "condition",
          "desc": "The condition to check for.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.barssince\")",
        "// get number of bars since last color.green bar",
        "plot(ta.barssince(close >= open))"
      ],
      "returns": ["Number of bars since condition was true."],
      "remarks": [
        "If the condition has never been met prior to the current bar, the function returns na.",
        "Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.valuewhen](#fun_ta.valuewhen)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowest](#fun_ta.lowest)"
      ],
      "syntax": ["ta.barssince(condition) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.valuewhen",
      "desc": [
        "Returns the value of the `source` series on the bar where the `condition` was true on the nth most recent occurrence."
      ],
      "args": [
        {
          "name": "condition",
          "desc": "The condition to search for.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "source",
          "desc": "The value to be returned from the bar where the condition is met.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "occurrence",
          "desc": "The occurrence of the condition. The numbering starts from 0 and goes back in time, so '0' is the most recent occurrence of `condition`, '1' is the second most recent and so forth. Must be an integer >= 0.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.valuewhen\")",
        "slow = ta.sma(close, 7)",
        "fast = ta.sma(close, 14)",
        "// Get value of `close` on second most recent cross",
        "plot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
      ],
      "remarks": [
        "This function requires execution on every bar. It is not recommended to use it inside a [for](#kw_for) or [while](#kw_while) loop structure, where its behavior can be unexpected. Please note that using this function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowest](#fun_ta.lowest)"
      ],
      "syntax": ["ta.valuewhen(condition, source, occurrence) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.valuewhen",
      "desc": [
        "Returns the value of the `source` series on the bar where the `condition` was true on the nth most recent occurrence."
      ],
      "args": [
        {
          "name": "condition",
          "desc": "The condition to search for.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "source",
          "desc": "The value to be returned from the bar where the condition is met.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "occurrence",
          "desc": "The occurrence of the condition. The numbering starts from 0 and goes back in time, so '0' is the most recent occurrence of `condition`, '1' is the second most recent and so forth. Must be an integer >= 0.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.valuewhen\")",
        "slow = ta.sma(close, 7)",
        "fast = ta.sma(close, 14)",
        "// Get value of `close` on second most recent cross",
        "plot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
      ],
      "remarks": [
        "This function requires execution on every bar. It is not recommended to use it inside a [for](#kw_for) or [while](#kw_while) loop structure, where its behavior can be unexpected. Please note that using this function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowest](#fun_ta.lowest)"
      ],
      "syntax": ["ta.valuewhen(condition, source, occurrence) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.valuewhen",
      "desc": [
        "Returns the value of the `source` series on the bar where the `condition` was true on the nth most recent occurrence."
      ],
      "args": [
        {
          "name": "condition",
          "desc": "The condition to search for.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "source",
          "desc": "The value to be returned from the bar where the condition is met.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "occurrence",
          "desc": "The occurrence of the condition. The numbering starts from 0 and goes back in time, so '0' is the most recent occurrence of `condition`, '1' is the second most recent and so forth. Must be an integer >= 0.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.valuewhen\")",
        "slow = ta.sma(close, 7)",
        "fast = ta.sma(close, 14)",
        "// Get value of `close` on second most recent cross",
        "plot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
      ],
      "remarks": [
        "This function requires execution on every bar. It is not recommended to use it inside a [for](#kw_for) or [while](#kw_while) loop structure, where its behavior can be unexpected. Please note that using this function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowest](#fun_ta.lowest)"
      ],
      "syntax": ["ta.valuewhen(condition, source, occurrence) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.valuewhen",
      "desc": [
        "Returns the value of the `source` series on the bar where the `condition` was true on the nth most recent occurrence."
      ],
      "args": [
        {
          "name": "condition",
          "desc": "The condition to search for.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "source",
          "desc": "The value to be returned from the bar where the condition is met.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "occurrence",
          "desc": "The occurrence of the condition. The numbering starts from 0 and goes back in time, so '0' is the most recent occurrence of `condition`, '1' is the second most recent and so forth. Must be an integer >= 0.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.valuewhen\")",
        "slow = ta.sma(close, 7)",
        "fast = ta.sma(close, 14)",
        "// Get value of `close` on second most recent cross",
        "plot(ta.valuewhen(ta.cross(slow, fast), close, 1))"
      ],
      "remarks": [
        "This function requires execution on every bar. It is not recommended to use it inside a [for](#kw_for) or [while](#kw_while) loop structure, where its behavior can be unexpected. Please note that using this function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "seeAlso": [
        "[ta.lowestbars](#fun_ta.lowestbars)",
        "[ta.highestbars](#fun_ta.highestbars)",
        "[ta.barssince](#fun_ta.barssince)",
        "[ta.highest](#fun_ta.highest)",
        "[ta.lowest](#fun_ta.lowest)"
      ],
      "syntax": ["ta.valuewhen(condition, source, occurrence) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "ta.falling",
      "desc": ["Test if the `source` series is now falling for `length` bars long."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": [
        "true if current `source` value is less than any previous `source` value for `length` bars back, false otherwise."
      ],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.rising](#fun_ta.rising)"],
      "syntax": ["ta.falling(source, length) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.rising",
      "desc": ["Test if the `source` series is now rising for `length` bars long."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": [
        "true if current `source` is greater than any previous `source` for `length` bars back, false otherwise."
      ],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": ["[ta.falling](#fun_ta.falling)"],
      "syntax": ["ta.rising(source, length) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.roc",
      "desc": [
        "Calculates the percentage of change (rate of change) between the current value of `source` and its value `length` bars ago.",
        "It is calculated by the formula: 100 * change(src, length) / src[length]."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["The rate of change of `source` for `length` bars back."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "syntax": ["ta.roc(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.cci",
      "desc": [
        "The CCI (commodity channel index) is calculated as the difference between the typical price of a commodity and its simple moving average, divided by the mean absolute deviation of the typical price. The index is scaled by an inverse factor of 0.015 to provide more readable numbers."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Commodity channel index of source for length bars back."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "syntax": ["ta.cci(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.variance",
      "desc": [
        "Variance is the expectation of the squared deviation of a series from its mean ([ta.sma](#fun_ta.sma)), and it informally measures how far a set of numbers are spread out from their mean."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "returns": ["Variance of `source` for `length` bars back."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.dev](#fun_ta.dev)", "[ta.stdev](#fun_ta.stdev)"],
      "syntax": ["ta.variance(source, length, biased) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.dev",
      "desc": ["Measure of difference between the series and it's [ta.sma](#fun_ta.sma)"],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.dev\")",
        "plot(ta.dev(close, 10))",
        "",
        "// the same on pine",
        "pine_dev(source, length) =>",
        "    mean = ta.sma(source, length)",
        "    sum = 0.0",
        "    for i = 0 to length - 1",
        "        val = source[i]",
        "        sum := sum + math.abs(val - mean)",
        "    dev = sum/length",
        "plot(pine_dev(close, 10))"
      ],
      "returns": ["Deviation of `source` for `length` bars back."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": ["[ta.variance](#fun_ta.variance)", "[ta.stdev](#fun_ta.stdev)"],
      "syntax": ["ta.dev(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.stdev",
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.stdev\")",
        "plot(ta.stdev(close, 5))",
        "",
        "//the same on pine",
        "isZero(val, eps) => math.abs(val) <= eps",
        "",
        "SUM(fst, snd) =>",
        "    EPS = 1e-10",
        "    res = fst + snd",
        "    if isZero(res, EPS)",
        "        res := 0",
        "    else",
        "        if not isZero(res, 1e-4)",
        "            res := res",
        "        else",
        "            15",
        "",
        "pine_stdev(src, length) =>",
        "    avg = ta.sma(src, length)",
        "    sumOfSquareDeviations = 0.0",
        "    for i = 0 to length - 1",
        "        sum = SUM(src[i], -avg)",
        "        sumOfSquareDeviations := sumOfSquareDeviations + sum * sum",
        "",
        "    stdev = math.sqrt(sumOfSquareDeviations / length)",
        "plot(pine_stdev(close, 5))"
      ],
      "returns": ["Standard deviation."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample.",
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.dev](#fun_ta.dev)", "[ta.variance](#fun_ta.variance)"],
      "syntax": ["ta.stdev(source, length, biased) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.percentrank",
      "desc": [
        "Percent rank is the percents of how many previous values was less than or equal to the current value of given series."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Percent rank of `source` for `length` bars back."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "syntax": ["ta.percentrank(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.rma",
      "desc": [
        "Moving average used in RSI. It is the exponentially weighted moving average with alpha = 1 / length."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.rma\")",
        "plot(ta.rma(close, 15))",
        "",
        "//the same on pine",
        "pine_rma(src, length) =>",
        "\talpha = 1/length",
        "\tsum = 0.0",
        "\tsum := na(sum[1]) ? ta.sma(src, length) : alpha * src + (1 - alpha) * nz(sum[1])",
        "plot(pine_rma(close, 15))"
      ],
      "returns": ["Exponential moving average of `source` with alpha = 1 / `length`."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.swma](#fun_ta.swma)",
        "[ta.alma](#fun_ta.alma)",
        "[ta.rsi](#fun_ta.rsi)"
      ],
      "syntax": ["ta.rma(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.rsi",
      "desc": [
        "Relative strength index. It is calculated using the `ta.rma()` of upward and downward changes of `source` over the last `length` bars."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.rsi\")",
        "plot(ta.rsi(close, 7))",
        "",
        "// same on pine, but less efficient",
        "pine_rsi(x, y) => ",
        "    u = math.max(x - x[1], 0) // upward ta.change",
        "    d = math.max(x[1] - x, 0) // downward ta.change",
        "    rs = ta.rma(u, y) / ta.rma(d, y)",
        "    res = 100 - 100 / (1 + rs)",
        "    res",
        "",
        "plot(pine_rsi(close, 7))"
      ],
      "returns": ["Relative strength index."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.rma](#fun_ta.rma)"],
      "syntax": ["ta.rsi(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.rci",
      "desc": [
        "Calculates the Rank Correlation Index (RCI), which measures the directional consistency of price movements. It evaluates the monotonic relationship between a `source` series and the bar index over `length` bars using Spearman's rank correlation coefficient. The resulting value is scaled to a range of -100 to 100, where 100 indicates the `source` consistently increased over the period, and -100 indicates it consistently decreased. Values between -100 and 100 reflect varying degrees of upward or downward consistency."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": ["The Rank Correlation Index, a value between -100 to 100."],
      "seeAlso": [],
      "syntax": ["ta.rci(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "timeframe.in_seconds",
      "desc": ["Converts a timeframe string into seconds."],
      "args": [
        {
          "name": "timeframe",
          "desc": "Timeframe string in [timeframe string specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications) format. Optional. The default is [timeframe.period](#var_timeframe.period).",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`timeframe_in_seconds()`\")",
        "",
        "// Get a user-selected timeframe.",
        "tfInput = input.timeframe(\"1D\")",
        "",
        "// Convert it into an \"int\" number of seconds.",
        "secondsInTf = timeframe.in_seconds(tfInput)",
        "",
        "plot(secondsInTf)"
      ],
      "returns": ["The \"int\" representation of the number of seconds in the timeframe string."],
      "remarks": [
        "When the timeframe is \"1M\" or more, calculations use 2628003 as the number of seconds in one month, which represents 30.4167 (365/12) days."
      ],
      "seeAlso": [
        "[input.timeframe](#fun_input.timeframe)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.from_seconds](#fun_timeframe.from_seconds)"
      ],
      "syntax": ["timeframe.in_seconds(timeframe) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "timeframe.in_seconds",
      "desc": ["Converts a timeframe string into seconds."],
      "args": [
        {
          "name": "timeframe",
          "desc": "Timeframe string in [timeframe string specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications) format. Optional. The default is [timeframe.period](#var_timeframe.period).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`timeframe_in_seconds()`\")",
        "",
        "// Get a user-selected timeframe.",
        "tfInput = input.timeframe(\"1D\")",
        "",
        "// Convert it into an \"int\" number of seconds.",
        "secondsInTf = timeframe.in_seconds(tfInput)",
        "",
        "plot(secondsInTf)"
      ],
      "returns": ["The \"int\" representation of the number of seconds in the timeframe string."],
      "remarks": [
        "When the timeframe is \"1M\" or more, calculations use 2628003 as the number of seconds in one month, which represents 30.4167 (365/12) days."
      ],
      "seeAlso": [
        "[input.timeframe](#fun_input.timeframe)",
        "[timeframe.period](#var_timeframe.period)",
        "[timeframe.from_seconds](#fun_timeframe.from_seconds)"
      ],
      "syntax": ["timeframe.in_seconds(timeframe) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "timeframe.from_seconds",
      "desc": ["Converts a number of seconds into a valid timeframe string."],
      "args": [
        {
          "name": "seconds",
          "desc": "The number of seconds in the timeframe.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"HTF Close\", \"\", true)",
        "int chartTf = timeframe.in_seconds()",
        "string tfTimes5 = timeframe.from_seconds(chartTf * 5)",
        "float htfClose = request.security(syminfo.tickerid, tfTimes5, close)",
        "plot(htfClose)"
      ],
      "returns": [
        "A timeframe string compliant with [timeframe string specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications)."
      ],
      "remarks": [
        "If no valid timeframe exists for the quantity of seconds supplied, the next higher valid timeframe will be returned. Accordingly, one second or less will return \"1S\", 2-5 seconds will return \"5S\", and 604,799 seconds (one second less than 7 days) will return \"7D\".",
        "If the seconds exactly represent two or more valid timeframes, the one with the larger base unit will be used. Thus 604,800 seconds (7 days) returns \"1W\", not \"7D\".",
        "All values above 31,622,400 (366 days) return \"12M\"."
      ],
      "seeAlso": [
        "[timeframe.in_seconds](#fun_timeframe.in_seconds)",
        "[request.security](#var_request.security)",
        "[request.security_lower_tf](#var_request.security_lower_tf)"
      ],
      "syntax": ["timeframe.from_seconds(seconds) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "timeframe.from_seconds",
      "desc": ["Converts a number of seconds into a valid timeframe string."],
      "args": [
        {
          "name": "seconds",
          "desc": "The number of seconds in the timeframe.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"HTF Close\", \"\", true)",
        "int chartTf = timeframe.in_seconds()",
        "string tfTimes5 = timeframe.from_seconds(chartTf * 5)",
        "float htfClose = request.security(syminfo.tickerid, tfTimes5, close)",
        "plot(htfClose)"
      ],
      "returns": [
        "A timeframe string compliant with [timeframe string specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications)."
      ],
      "remarks": [
        "If no valid timeframe exists for the quantity of seconds supplied, the next higher valid timeframe will be returned. Accordingly, one second or less will return \"1S\", 2-5 seconds will return \"5S\", and 604,799 seconds (one second less than 7 days) will return \"7D\".",
        "If the seconds exactly represent two or more valid timeframes, the one with the larger base unit will be used. Thus 604,800 seconds (7 days) returns \"1W\", not \"7D\".",
        "All values above 31,622,400 (366 days) return \"12M\"."
      ],
      "seeAlso": [
        "[timeframe.in_seconds](#fun_timeframe.in_seconds)",
        "[request.security](#var_request.security)",
        "[request.security_lower_tf](#var_request.security_lower_tf)"
      ],
      "syntax": ["timeframe.from_seconds(seconds) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ta.dmi",
      "desc": ["The dmi function returns the directional movement index."],
      "args": [
        {
          "name": "diLength",
          "desc": "DI Period.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "adxSmoothing",
          "desc": "ADX Smoothing Period.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(title=\"Directional Movement Index\", shorttitle=\"DMI\", format=format.price, precision=4)",
        "len = input.int(17, minval=1, title=\"DI Length\")",
        "lensig = input.int(14, title=\"ADX Smoothing\", minval=1)",
        "[diplus, diminus, adx] = ta.dmi(len, lensig)",
        "plot(adx, color=color.red, title=\"ADX\")",
        "plot(diplus, color=color.blue, title=\"+DI\")",
        "plot(diminus, color=color.orange, title=\"-DI\")"
      ],
      "returns": [
        "[Tuple](https://www.tradingview.com/pine-script-docs/language/type-system/#tuples) of three DMI series: Positive Directional Movement (+DI), Negative Directional Movement (-DI) and Average Directional Movement Index (ADX)."
      ],
      "seeAlso": ["[ta.rsi](#fun_ta.rsi)", "[ta.tsi](#fun_ta.tsi)", "[ta.mfi](#fun_ta.mfi)"],
      "syntax": ["ta.dmi(diLength, adxSmoothing) → [series float, series float, series float]"],
      "returnedTypes": ["[series float, series float, series float]"]
    },
    {
      "name": "ta.correlation",
      "desc": [
        "Correlation coefficient. Describes the degree to which two series tend to deviate from their [ta.sma](#fun_ta.sma) values."
      ],
      "args": [
        {
          "name": "source1",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "source2",
          "desc": "Target series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Length (number of bars back).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Correlation coefficient."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[request.security](#fun_request.security)"],
      "syntax": ["ta.correlation(source1, source2, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.tsi",
      "desc": [
        "True strength index. It uses moving averages of the underlying momentum of a financial instrument."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "short_length",
          "desc": "Short length.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "long_length",
          "desc": "Long length.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": ["True strength index. A value in range [-1, 1]."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "syntax": ["ta.tsi(source, short_length, long_length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.linreg",
      "desc": [
        "Linear regression curve. A line that best fits the prices specified over a user-defined time period. It is calculated using the least squares method. The result of this function is calculated using the formula: linreg = intercept + slope * (length - 1 - offset), where intercept and slope are the values calculated with the least squares method on `source` series."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "offset",
          "desc": "Offset.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": ["Linear regression curve."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "syntax": ["ta.linreg(source, length, offset) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.stoch",
      "desc": [
        "Stochastic. It is calculated by a formula: 100 * (close - lowest(low, length)) / (highest(high, length) - lowest(low, length))."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "high",
          "desc": "Series of high.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "low",
          "desc": "Series of low.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Length (number of bars back).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Stochastic."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": ["[ta.cog](#fun_ta.cog)"],
      "syntax": ["ta.stoch(source, high, low, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.atr",
      "desc": [
        "Function atr (average true range) returns the RMA of true range. True range is max(high - low, abs(high - close[1]), abs(low - close[1]))."
      ],
      "args": [
        {
          "name": "length",
          "desc": "Length (number of bars back).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.atr\")",
        "plot(ta.atr(14))",
        "",
        "//the same on pine",
        "pine_atr(length) =>",
        "    trueRange = na(high[1])? high-low : math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))",
        "    //true range can be also calculated with ta.tr(true)",
        "    ta.rma(trueRange, length)",
        "",
        "plot(pine_atr(14))"
      ],
      "returns": ["Average true range."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.tr](#fun_ta.tr)", "[ta.rma](#fun_ta.rma)"],
      "syntax": ["ta.atr(length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "fixnan",
      "desc": ["For a given series replaces NaN values with previous nearest non-NaN value."],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["Series without na gaps."],
      "seeAlso": ["[na](#fun_na)", "[na](#var_na)", "[nz](#fun_nz)"],
      "syntax": ["fixnan(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "fixnan",
      "desc": ["For a given series replaces NaN values with previous nearest non-NaN value."],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the calculation.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Series without na gaps."],
      "seeAlso": ["[na](#fun_na)", "[na](#var_na)", "[nz](#fun_nz)"],
      "syntax": ["fixnan(source) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "fixnan",
      "desc": ["For a given series replaces NaN values with previous nearest non-NaN value."],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the calculation.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "returns": ["Series without na gaps."],
      "seeAlso": ["[na](#fun_na)", "[na](#var_na)", "[nz](#fun_nz)"],
      "syntax": ["fixnan(source) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "ta.cum",
      "desc": [
        "Cumulative (total) sum of `source`. In other words it's a sum of all elements of `source`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["Total sum series."],
      "seeAlso": ["[math.sum](#fun_math.sum)"],
      "syntax": ["ta.cum(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.change",
      "desc": [
        "Compares the current `source` value to its value `length` bars ago and returns the difference."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Day and Direction Change', overlay = true)",
        "dailyBarTime = time('1D')",
        "isNewDay = ta.change(dailyBarTime) != 0",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)",
        "",
        "isGreenBar = close >= open",
        "colorChange = ta.change(isGreenBar)",
        "plotshape(colorChange, 'Direction Change')"
      ],
      "returns": [
        "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source."
      ],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.mom](#fun_ta.mom)", "[ta.cross](#fun_ta.cross)"],
      "syntax": ["ta.change(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.change",
      "desc": [
        "Compares the current `source` value to its value `length` bars ago and returns the difference."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Day and Direction Change', overlay = true)",
        "dailyBarTime = time('1D')",
        "isNewDay = ta.change(dailyBarTime) != 0",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)",
        "",
        "isGreenBar = close >= open",
        "colorChange = ta.change(isGreenBar)",
        "plotshape(colorChange, 'Direction Change')"
      ],
      "returns": [
        "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source."
      ],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.mom](#fun_ta.mom)", "[ta.cross](#fun_ta.cross)"],
      "syntax": ["ta.change(source) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.change",
      "desc": [
        "Compares the current `source` value to its value `length` bars ago and returns the difference."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Day and Direction Change', overlay = true)",
        "dailyBarTime = time('1D')",
        "isNewDay = ta.change(dailyBarTime) != 0",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)",
        "",
        "isGreenBar = close >= open",
        "colorChange = ta.change(isGreenBar)",
        "plotshape(colorChange, 'Direction Change')"
      ],
      "returns": [
        "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source."
      ],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.mom](#fun_ta.mom)", "[ta.cross](#fun_ta.cross)"],
      "syntax": ["ta.change(source) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.change",
      "desc": [
        "Compares the current `source` value to its value `length` bars ago and returns the difference."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "How far the past `source` value is offset from the current one, in bars. Optional. The default is 1.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Day and Direction Change', overlay = true)",
        "dailyBarTime = time('1D')",
        "isNewDay = ta.change(dailyBarTime) != 0",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)",
        "",
        "isGreenBar = close >= open",
        "colorChange = ta.change(isGreenBar)",
        "plotshape(colorChange, 'Direction Change')"
      ],
      "returns": [
        "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source."
      ],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.mom](#fun_ta.mom)", "[ta.cross](#fun_ta.cross)"],
      "syntax": ["ta.change(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.change",
      "desc": [
        "Compares the current `source` value to its value `length` bars ago and returns the difference."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "length",
          "desc": "How far the past `source` value is offset from the current one, in bars. Optional. The default is 1.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Day and Direction Change', overlay = true)",
        "dailyBarTime = time('1D')",
        "isNewDay = ta.change(dailyBarTime) != 0",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)",
        "",
        "isGreenBar = close >= open",
        "colorChange = ta.change(isGreenBar)",
        "plotshape(colorChange, 'Direction Change')"
      ],
      "returns": [
        "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source."
      ],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.mom](#fun_ta.mom)", "[ta.cross](#fun_ta.cross)"],
      "syntax": ["ta.change(source, length) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.change",
      "desc": [
        "Compares the current `source` value to its value `length` bars ago and returns the difference."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "length",
          "desc": "How far the past `source` value is offset from the current one, in bars. Optional. The default is 1.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Day and Direction Change', overlay = true)",
        "dailyBarTime = time('1D')",
        "isNewDay = ta.change(dailyBarTime) != 0",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)",
        "",
        "isGreenBar = close >= open",
        "colorChange = ta.change(isGreenBar)",
        "plotshape(colorChange, 'Direction Change')"
      ],
      "returns": [
        "The difference between the values when they are numerical. When a 'bool' source is used, returns `true` when the current source is different from the previous source."
      ],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.mom](#fun_ta.mom)", "[ta.cross](#fun_ta.cross)"],
      "syntax": ["ta.change(source, length) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.mom",
      "desc": [
        "Momentum of `source` price and `source` price `length` bars ago. This is simply a difference: source - source[length]."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Offset from the current bar to the previous bar.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Momentum of `source` price and `source` price `length` bars ago."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.change](#fun_ta.change)"],
      "syntax": ["ta.mom(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.pivot_point_levels",
      "desc": ["Calculates the pivot point levels using the specified `type` and `anchor`."],
      "args": [
        {
          "name": "type",
          "desc": "The type of pivot point levels. Possible values: \"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\".",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "anchor",
          "desc": "The condition that triggers the reset of the pivot point calculations. When [true](#const_true), calculations reset; when [false](#const_false), results calculated at the last reset persist.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "developing",
          "desc": "If [false](#const_false), the values are those calculated the last time the anchor condition was [true](#const_true). They remain constant until the anchor condition becomes [true](#const_true) again. If [true](#const_true), the pivots are developing, i.e., they constantly recalculate on the data developing between the point of the last anchor (or bar zero if the anchor condition was never [true](#const_true)) and the current bar. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Weekly Pivots\", max_lines_count=500, overlay=true)",
        "timeframe = \"1W\"",
        "typeInput = input.string(\"Traditional\", \"Type\", options=[\"Traditional\", \"Fibonacci\", \"Woodie\", \"Classic\", \"DM\", \"Camarilla\"])",
        "weekChange = timeframe.change(timeframe)",
        "pivotPointsArray = ta.pivot_point_levels(typeInput, weekChange)",
        "if weekChange",
        "    for pivotLevel in pivotPointsArray",
        "        line.new(time, pivotLevel, time + timeframe.in_seconds(timeframe) * 1000, pivotLevel, xloc=xloc.bar_time)"
      ],
      "returns": [
        "An `array<float>` with numerical values representing 11 pivot point levels: [P, R1, S1, R2, S2, R3, S3, R4, S4, R5, S5]. Levels absent from the specified `type` return [na](#var_na) values (e.g., \"DM\" only calculates P, R1, and S1)."
      ],
      "remarks": [
        "The `developing` parameter cannot be `true` when `type` is set to \"Woodie\", because the Woodie calculation for a period depends on that period's open, which means that the pivot value is either available or unavailable, but never developing. If used together, the indicator will return a runtime error."
      ],
      "syntax": ["ta.pivot_point_levels(type, anchor, developing) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "ta.vwap",
      "desc": ["Volume weighted average price."],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the VWAP calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Simple VWAP\")",
            "vwap = ta.vwap(open)",
            "plot(vwap)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Advanced VWAP\")",
            "vwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])",
            "stdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")",
            "anchorTimeframe = switch vwapAnchorInput",
            "\t\"Daily\"   => \"1D\"",
            "\t\"Weekly\"  => \"1W\"",
            "\t\"Monthly\" => \"1M\"",
            "anchor = timeframe.change(anchorTimeframe)",
            "[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)",
            "plot(vwap)",
            "plot(upper, color = color.green)",
            "plot(lower, color = color.green)"
          ]
        }
      ],
      "returns": [
        "A VWAP series, or a tuple [vwap, upper_band, lower_band] if `stdev_mult` is specified."
      ],
      "remarks": [
        "Calculations only begin the first time the anchor condition becomes [true](#const_true). Until then, the function returns [na](#var_na)."
      ],
      "seeAlso": ["[ta.vwap](#var_ta.vwap) (variable)"],
      "syntax": ["ta.vwap(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.vwap",
      "desc": ["Volume weighted average price."],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the VWAP calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "anchor",
          "desc": "The condition that triggers the reset of VWAP calculations. When [true](#const_true), calculations reset; when [false](#const_false), calculations proceed using the values accumulated since the previous reset. Optional. The default is equivalent to passing [timeframe.change](#fun_timeframe.change) with \"1D\" as its argument.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Simple VWAP\")",
            "vwap = ta.vwap(open)",
            "plot(vwap)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Advanced VWAP\")",
            "vwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])",
            "stdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")",
            "anchorTimeframe = switch vwapAnchorInput",
            "\t\"Daily\"   => \"1D\"",
            "\t\"Weekly\"  => \"1W\"",
            "\t\"Monthly\" => \"1M\"",
            "anchor = timeframe.change(anchorTimeframe)",
            "[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)",
            "plot(vwap)",
            "plot(upper, color = color.green)",
            "plot(lower, color = color.green)"
          ]
        }
      ],
      "returns": [
        "A VWAP series, or a tuple [vwap, upper_band, lower_band] if `stdev_mult` is specified."
      ],
      "remarks": [
        "Calculations only begin the first time the anchor condition becomes [true](#const_true). Until then, the function returns [na](#var_na)."
      ],
      "seeAlso": ["[ta.vwap](#var_ta.vwap) (variable)"],
      "syntax": ["ta.vwap(source, anchor) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.vwap",
      "desc": ["Volume weighted average price."],
      "args": [
        {
          "name": "source",
          "desc": "Source used for the VWAP calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "anchor",
          "desc": "The condition that triggers the reset of VWAP calculations. When [true](#const_true), calculations reset; when [false](#const_false), calculations proceed using the values accumulated since the previous reset. Optional. The default is equivalent to passing [timeframe.change](#fun_timeframe.change) with \"1D\" as its argument.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "stdev_mult",
          "desc": "If specified, the function will calculate the standard deviation bands based on the main VWAP series and return a [vwap, upper_band, lower_band] tuple. The `upper_band`/`lower_band` values are calculated using the VWAP to which the standard deviation multiplied by this argument is added/subtracted. Optional. The default is [na](#var_na), in which case the function returns a single value, not a tuple.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Simple VWAP\")",
            "vwap = ta.vwap(open)",
            "plot(vwap)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Advanced VWAP\")",
            "vwapAnchorInput = input.string(\"Daily\", \"Anchor\", options = [\"Daily\", \"Weekly\", \"Monthly\"])",
            "stdevMultiplierInput = input.float(1.0, \"Standard Deviation Multiplier\")",
            "anchorTimeframe = switch vwapAnchorInput",
            "\t\"Daily\"   => \"1D\"",
            "\t\"Weekly\"  => \"1W\"",
            "\t\"Monthly\" => \"1M\"",
            "anchor = timeframe.change(anchorTimeframe)",
            "[vwap, upper, lower] = ta.vwap(open, anchor, stdevMultiplierInput)",
            "plot(vwap)",
            "plot(upper, color = color.green)",
            "plot(lower, color = color.green)"
          ]
        }
      ],
      "returns": [
        "A VWAP series, or a tuple [vwap, upper_band, lower_band] if `stdev_mult` is specified."
      ],
      "remarks": [
        "Calculations only begin the first time the anchor condition becomes [true](#const_true). Until then, the function returns [na](#var_na)."
      ],
      "seeAlso": ["[ta.vwap](#var_ta.vwap) (variable)"],
      "syntax": [
        "ta.vwap(source, anchor, stdev_mult) → [series float, series float, series float]"
      ],
      "returnedTypes": ["[series float, series float, series float]"]
    },
    {
      "name": "ta.swma",
      "desc": [
        "Symmetrically weighted moving average with fixed length: 4. Weights: [1/6, 2/6, 2/6, 1/6]."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.swma\")",
        "plot(ta.swma(close))",
        "",
        "// same on pine, but less efficient",
        "pine_swma(x) =>",
        "    x[3] * 1 / 6 + x[2] * 2 / 6 + x[1] * 2 / 6 + x[0] * 1 / 6",
        "plot(pine_swma(close))"
      ],
      "returns": ["Symmetrically weighted moving average."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.alma](#fun_ta.alma)"
      ],
      "syntax": ["ta.swma(source) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.sar",
      "desc": [
        "Parabolic SAR (parabolic stop and reverse) is a method devised by J. Welles Wilder, Jr., to find potential reversals in the market price direction of traded goods."
      ],
      "args": [
        {
          "name": "start",
          "desc": "Start.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "inc",
          "desc": "Increment.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "max",
          "desc": "Maximum.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.sar\")",
        "plot(ta.sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)",
        "",
        "// The same on Pine Script®",
        "pine_sar(start, inc, max) =>",
        "\tvar float result = na",
        "\tvar float maxMin = na",
        "\tvar float acceleration = na",
        "\tvar bool isBelow = false",
        "\tbool isFirstTrendBar = false",
        "\t",
        "\tif bar_index == 1",
        "\t\tif close > close[1]",
        "\t\t\tisBelow := true",
        "\t\t\tmaxMin := high",
        "\t\t\tresult := low[1]",
        "\t\telse",
        "\t\t\tisBelow := false",
        "\t\t\tmaxMin := low",
        "\t\t\tresult := high[1]",
        "\t\tisFirstTrendBar := true",
        "\t\tacceleration := start",
        "\t",
        "\tresult := result + acceleration * (maxMin - result)",
        "\t",
        "\tif isBelow",
        "\t\tif result > low",
        "\t\t\tisFirstTrendBar := true",
        "\t\t\tisBelow := false",
        "\t\t\tresult := math.max(high, maxMin)",
        "\t\t\tmaxMin := low",
        "\t\t\tacceleration := start",
        "\telse",
        "\t\tif result < high",
        "\t\t\tisFirstTrendBar := true",
        "\t\t\tisBelow := true",
        "\t\t\tresult := math.min(low, maxMin)",
        "\t\t\tmaxMin := high",
        "\t\t\tacceleration := start",
        "\t\t\t",
        "\tif not isFirstTrendBar",
        "\t\tif isBelow",
        "\t\t\tif high > maxMin",
        "\t\t\t\tmaxMin := high",
        "\t\t\t\tacceleration := math.min(acceleration + inc, max)",
        "\t\telse",
        "\t\t\tif low < maxMin",
        "\t\t\t\tmaxMin := low",
        "\t\t\t\tacceleration := math.min(acceleration + inc, max)",
        "\t",
        "\tif isBelow",
        "\t\tresult := math.min(result, low[1])",
        "\t\tif bar_index > 1",
        "\t\t\tresult := math.min(result, low[2])",
        "\t\t",
        "\telse",
        "\t\tresult := math.max(result, high[1])",
        "\t\tif bar_index > 1",
        "\t\t\tresult := math.max(result, high[2])",
        "\t",
        "\tresult",
        "\t",
        "plot(pine_sar(0.02, 0.02, 0.2), style=plot.style_cross, linewidth=3)"
      ],
      "returns": ["Parabolic SAR."],
      "syntax": ["ta.sar(start, inc, max) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "timeframe.change",
      "desc": ["Detects changes in the specified `timeframe`."],
      "args": [
        {
          "name": "timeframe",
          "desc": "String formatted according to the [User manual's timeframe string specifications](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "// Run this script on an intraday chart.",
        "indicator(\"New day started\", overlay = true)",
        "// Highlights the first bar of the new day.",
        "isNewDay = timeframe.change(\"1D\")",
        "bgcolor(isNewDay ? color.new(color.green, 80) : na)"
      ],
      "returns": [
        "Returns [true](#const_true) on the first bar of a new `timeframe`, [false](#const_false) otherwise."
      ],
      "syntax": ["timeframe.change(timeframe) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "math.avg",
      "desc": ["Calculates average of all given series (elementwise)."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["Average."],
      "seeAlso": ["[math.sum](#fun_math.sum)", "[ta.cum](#fun_ta.cum)", "[ta.sma](#fun_ta.sma)"],
      "syntax": ["math.avg(number0, number1, ...) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "math.avg",
      "desc": ["Calculates average of all given series (elementwise)."],
      "args": [
        {
          "name": "number0, number1, ...",
          "desc": "A sequence of numbers to use in the calculation.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["Average."],
      "seeAlso": ["[math.sum](#fun_math.sum)", "[ta.cum](#fun_ta.cum)", "[ta.sma](#fun_ta.sma)"],
      "syntax": ["math.avg(number0, number1, ...) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.currency_rate",
      "desc": [
        "Provides a daily rate that can be used to convert a value expressed in the `from` currency to another in the `to` currency."
      ],
      "args": [
        {
          "name": "from",
          "desc": "The currency in which the value to be converted is expressed. Possible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\"), or one of the built-in variables that return currency codes, like [syminfo.currency](#var_syminfo.currency) or [currency.USD](#const_currency.USD).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "to",
          "desc": "The currency in which the value is to be converted. Possible values: a three-letter string with the [currency code in the ISO 4217 format](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) (e.g. \"USD\"), or one of the built-in variables that return currency codes, like [syminfo.currency](#var_syminfo.currency) or [currency.USD](#const_currency.USD).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "ignore_invalid_currency",
          "desc": "Determines the behavior of the function if a conversion rate between the two currencies cannot be calculated: if [false](#const_false), the script will halt and return a runtime error; if [true](#const_true), the function will return [na](#var_na) and execution will continue. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Close in British Pounds\")",
        "rate = request.currency_rate(syminfo.currency, \"GBP\")",
        "plot(close * rate)"
      ],
      "remarks": [
        "If `from` and `to` arguments are equal, function returns 1. Please note that using this variable/function can cause [indicator repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/)."
      ],
      "syntax": ["request.currency_rate(from, to, ignore_invalid_currency) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.security",
      "desc": [
        "Requests the result of an expression from a specified context (symbol and timeframe)."
      ],
      "syntax": [
        "request.security(symbol, timeframe, expression, gaps, lookahead, ignore_invalid_symbol, currency, calc_bars_count) → series <type>"
      ],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol or ticker identifier of the requested data. Use an empty string or [syminfo.tickerid](#var_syminfo.tickerid) to request data using the chart's symbol. To retrieve data with additional modifiers (extended sessions, dividend adjustments, non-standard chart types like Heikin Ashi and Renko, etc.), create a custom ticker ID for the request using the functions in the `ticker.*` namespace.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "timeframe",
          "desc": "Timeframe of the requested data. Use an empty string or [timeframe.period](#var_timeframe.period) to request data from the chart's timeframe or the `timeframe` specified in the [indicator](#fun_indicator) function. To request data from a different timeframe, supply a valid timeframe string. See [here](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications) to learn about specifying timeframe strings.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "expression",
          "desc": "The expression to calculate and return from the requested context. It can accept a built-in variable like [close](#var_close), a user-defined variable, an expression such as `ta.change(close) / (high - low)`, a function call that does not use Pine Script® drawings, an [object](https://www.tradingview.com/pine-script-docs/language/objects/), a [collection](https://www.tradingview.com/pine-script-docs/language/type-system/#collections), or a tuple of expressions.",
          "displayType": "variable, function, object, array, matrix, or map of series int/float/bool/string/color/enum, or a tuple of these",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series color",
            "simple color",
            "input color",
            "const color",
            "series string",
            "simple string",
            "input string",
            "const string"
          ]
        },
        {
          "name": "gaps",
          "desc": "Specifies how the returned values are merged on chart bars. Possible values: [barmerge.gaps_on](#const_barmerge.gaps_on), [barmerge.gaps_off](#const_barmerge.gaps_off). With [barmerge.gaps_on](#const_barmerge.gaps_on) a value only appears on the current chart bar when it first becomes available from the function's context, otherwise [na](#var_na) is returned (thus a \"gap\" occurs). With [barmerge.gaps_off](#const_barmerge.gaps_off) what would otherwise be gaps are filled with the latest known value returned, avoiding [na](#var_na) values. Optional. The default is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "lookahead",
          "desc": "On historical bars only, returns data from the timeframe before it elapses. Possible values: [barmerge.lookahead_on](#const_barmerge.lookahead_on), [barmerge.lookahead_off](#const_barmerge.lookahead_off). Has no effect on realtime values. Optional. The default is [barmerge.lookahead_off](#const_barmerge.lookahead_off) starting from Pine Script® v3. The default is [barmerge.lookahead_on](#const_barmerge.lookahead_on) in v1 and v2. WARNING: Using [barmerge.lookahead_on](#const_barmerge.lookahead_on) at timeframes higher than the chart's without offsetting the `expression` argument like in `close[1]` will introduce future leak in scripts, as the function will then return the `close` price before it is actually known in the current context. As is explained in the User Manual's page on [Repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/#future-leak-with-request-security) this will produce misleading results.",
          "allowedTypeIDs": [
            "simple barmerge_lookahead",
            "input barmerge_lookahead",
            "const barmerge_lookahead"
          ],
          "displayType": "simple barmerge_lookahead"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#const_false), the script will halt and throw a runtime error; if [true](#const_true), the function will return [na](#var_na) and execution will continue. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "currency",
          "desc": "Optional. Specifies the target currency for converting values expressed in currency units (e.g., [open](#var_open), [high](#var_high), [low](#var_low), [close](#var_close)) or expressions involving such values. Literal values such as `200` are not converted. The conversion rate for monetary values depends on the previous daily value of a corresponding currency pair from the most popular exchange. A spread symbol is used if no exchange provides the rate directly. Possible values: a \"string\" representing a valid currency code (e.g., \"USD\" or \"USDT\") or a constant from the `currency.*` namespace (e.g., [currency.USD](#const_currency.USD) or [currency.USDT](#const_currency.USDT)). The default is [syminfo.currency](#var_syminfo.currency).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "calc_bars_count",
          "desc": "If specified, the function will only request this number of values from the end of the symbol's history and calculate `expression` as if these values are the only available data, which might improve calculation speed in some cases. Optional. The default is 100,000, which is the limit for all non-professional TradingView plans.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Simple `request.security()` calls\")",
            "// Returns 1D close of the current symbol.",
            "dailyClose = request.security(syminfo.tickerid, \"1D\", close)",
            "plot(dailyClose)",
            "",
            "// Returns the close of \"AAPL\" from the same timeframe as currently open on the chart.",
            "aaplClose = request.security(\"AAPL\", timeframe.period, close)",
            "plot(aaplClose)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Advanced `request.security()` calls\")",
            "// This calculates a 10-period moving average on the active chart.",
            "sma = ta.sma(close, 10)",
            "// This sends the `sma` calculation for execution in the context of the \"AAPL\" symbol at a \"240\" (4 hours) timeframe.",
            "aaplSma = request.security(\"AAPL\", \"240\", sma)",
            "plot(aaplSma)",
            "",
            "// To avoid differences on historical and realtime bars, you can use this technique, which only returns a value from the higher timeframe on the bar after it completes:",
            "indexHighTF = barstate.isrealtime ? 1 : 0",
            "indexCurrTF = barstate.isrealtime ? 0 : 1",
            "nonRepaintingClose = request.security(syminfo.tickerid, \"1D\", close[indexHighTF])[indexCurrTF]",
            "plot(nonRepaintingClose, \"Non-repainting close\")",
            "",
            "// Returns the 1H close of \"AAPL\", extended session included. The value is dividend-adjusted.",
            "extendedTicker = ticker.modify(\"NASDAQ:AAPL\", session = session.extended, adjustment = adjustment.dividends)",
            "aaplExtAdj = request.security(extendedTicker, \"60\", close)",
            "plot(aaplExtAdj)",
            "",
            "// Returns the result of a user-defined function.",
            "// The `max` variable is mutable, but we can pass it to `request.security()` because it is wrapped in a function.",
            "allTimeHigh(source) =>",
            "\tvar max = source",
            "\tmax := math.max(max, source)",
            "allTimeHigh1D = request.security(syminfo.tickerid, \"1D\", allTimeHigh(high))",
            "",
            "// By using a tuple `expression`, we obtain several values with only one `request.security()` call.",
            "[open1D, high1D, low1D, close1D, ema1D] = request.security(syminfo.tickerid, \"1D\", [open, high, low, close, ta.ema(close, 10)])",
            "plotcandle(open1D, high1D, low1D, close1D)",
            "plot(ema1D)",
            "",
            "// Returns an array containing the OHLC values of the chart's symbol from the 1D timeframe.",
            "ohlcArray = request.security(syminfo.tickerid, \"1D\", array.from(open, high, low, close))",
            "plotcandle(array.get(ohlcArray, 0), array.get(ohlcArray, 1), array.get(ohlcArray, 2), array.get(ohlcArray, 3))"
          ]
        }
      ],
      "returns": ["A result determined by `expression`."],
      "remarks": [
        "Scripts using this function might calculate differently on historical and realtime bars, leading to [repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/).",
        "A single script can contain no more than 40 unique `request.*()` function calls. A call is unique only if it does not call the same function with the same arguments.",
        "When using two calls to a `request.*()` function to evaluate the same expression from the same context with different `calc_bars_count` values, the second call requests the same number of historical bars as the first. For example, if a script calls `request.security(\"AAPL\", \"\", close, calc_bars_count = 3)` after it calls `request.security(\"AAPL\", \"\", close, calc_bars_count = 5)`, the second call also uses five bars of historical data, not three.",
        "The symbol of a `request.()` call can be *inherited* if it is not specified precisely, i.e., if the `symbol` argument is an empty string or [syminfo.tickerid](#var_syminfo.tickerid). Similarly, the timeframe of a `request.()` call can be inherited if the `timeframe` argument is an empty string or [timeframe.period](#var_timeframe.period). These values are normally taken from the chart on which the script is running. However, if `request.*()` function A is called from within the expression of `request.*()` function B, then function A can inherit the values from function B. See [here](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#nested-requests) for more information."
      ],
      "seeAlso": [
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[timeframe.period](#var_timeframe.period)",
        "[ticker.new](#fun_ticker.new)",
        "[ticker.modify](#fun_ticker.modify)",
        "[request.security_lower_tf](#fun_request.security_lower_tf)",
        "[request.dividends](#fun_request.dividends)",
        "[request.earnings](#fun_request.earnings)",
        "[request.splits](#fun_request.splits)",
        "[request.financial](#fun_request.financial)"
      ]
    },
    {
      "name": "request.security_lower_tf",
      "desc": [
        "Requests the results of an expression from a specified symbol on a timeframe lower than or equal to the chart's timeframe. It returns an [array](#type_array) containing one element for each lower-timeframe bar within the chart bar. On a 5-minute chart, requesting data using a `timeframe` argument of \"1\" typically returns an array with five elements representing the value of the `expression` on each 1-minute bar, ordered by time with the earliest value first."
      ],
      "syntax": [
        "request.security_lower_tf(symbol, timeframe, expression, ignore_invalid_symbol, currency, ignore_invalid_timeframe, calc_bars_count) → array<type>"
      ],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol or ticker identifier of the requested data. Use an empty string or [syminfo.tickerid](#var_syminfo.tickerid) to request data using the chart's symbol. To retrieve data with additional modifiers (extended sessions, dividend adjustments, non-standard chart types like Heikin Ashi and Renko, etc.), create a custom ticker ID for the request using the functions in the `ticker.*` namespace.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "timeframe",
          "desc": "Timeframe of the requested data. Use an empty string or [timeframe.period](#var_timeframe.period) to request data from the chart's timeframe or the `timeframe` specified in the [indicator](#fun_indicator) function. To request data from a different timeframe, supply a valid timeframe string. See [here](https://www.tradingview.com/pine-script-docs/concepts/timeframes/#timeframe-string-specifications) to learn about specifying timeframe strings.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "expression",
          "desc": "The expression to calculate and return from the requested context. It can accept a built-in variable like [close](#var_close), a user-defined variable, an expression such as `ta.change(close) / (high - low)`, a function call that does not use Pine Script® drawings, an [object](https://www.tradingview.com/pine-script-docs/language/objects/), or a tuple of expressions. [Collections](https://www.tradingview.com/pine-script-docs/language/type-system/#collections) are not allowed unless they are within the fields of an object",
          "displayType": "variable, object or function of series int/float/bool/string/color/enum, or a tuple of these",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series color",
            "simple color",
            "input color",
            "const color"
          ]
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#const_false), the script will halt and throw a runtime error; if [true](#const_true), the function will return [na](#var_na) and execution will continue. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "currency",
          "desc": "Optional. Specifies the target currency for converting values expressed in currency units (e.g., [open](#var_open), [high](#var_high), [low](#var_low), [close](#var_close)) or expressions involving such values. Literal values such as `200` are not converted. The conversion rate for monetary values depends on the previous daily value of a corresponding currency pair from the most popular exchange. A spread symbol is used if no exchange provides the rate directly. Possible values: a \"string\" representing a valid currency code (e.g., \"USD\" or \"USDT\") or a constant from the `currency.*` namespace (e.g., [currency.USD](#const_currency.USD) or [currency.USDT](#const_currency.USDT)). The default is [syminfo.currency](#var_syminfo.currency).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "ignore_invalid_timeframe",
          "desc": "Determines the behavior of the function when the chart's timeframe is smaller than the `timeframe` used in the function call. If [false](#const_false), the script will halt and throw a runtime error. If [true](#const_true), the function will return [na](#var_na) and execution will continue. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "calc_bars_count",
          "desc": "If specified, the function will only request this number of values from the end of the symbol's history and calculate `expression` as if these values are the only available data, which might improve calculation speed in some cases. Optional. The default is 100,000, which is the limit for all non-professional TradingView plans.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`request.security_lower_tf()` Example\", overlay = true)",
        "",
        "// If the current chart timeframe is set to 120 minutes, then the `arrayClose` array will contain two 'close' values from the 60 minute timeframe for each bar.",
        "arrClose = request.security_lower_tf(syminfo.tickerid, \"60\", close)",
        "",
        "if bar_index == last_bar_index - 1",
        "    label.new(bar_index, high, str.tostring(arrClose))"
      ],
      "returns": ["An array of a type determined by `expression`, or a tuple of these."],
      "remarks": [
        "Scripts using this function might calculate differently on historical and realtime bars, leading to [repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/).",
        "Please note that spreads (e.g., \"AAPL+MSFT*TSLA\") do not always return reliable data with this function.",
        "A single script can contain no more than 40 unique `request.*()` function calls. A call is unique only if it does not call the same function with the same arguments.",
        "When using two calls to a `request.*()` function to evaluate the same expression from the same context with different `calc_bars_count` values, the second call requests the same number of historical bars as the first. For example, if a script calls `request.security(\"AAPL\", \"\", close, calc_bars_count = 3)` after it calls `request.security(\"AAPL\", \"\", close, calc_bars_count = 5)`, the second call also uses five bars of historical data, not three.",
        "The symbol of a `request.()` call can be *inherited* if it is not specified precisely, i.e., if the `symbol` argument is an empty string or [syminfo.tickerid](#var_syminfo.tickerid). Similarly, the timeframe of a `request.()` call can be inherited if the `timeframe` argument is an empty string or [timeframe.period](#var_timeframe.period). These values are normally taken from the chart that the script is running on. However, if `request.*()` function A is called from within the expression of `request.*()` function B, then function A can inherit the values from function B. See [here](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#nested-requests) for more information."
      ],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[timeframe.period](#var_timeframe.period)",
        "[ticker.new](#fun_ticker.new)",
        "[request.dividends](#fun_request.dividends)",
        "[request.earnings](#fun_request.earnings)",
        "[request.splits](#fun_request.splits)",
        "[request.financial](#fun_request.financial)"
      ]
    },
    {
      "name": "request.financial",
      "desc": ["Requests financial series for symbol."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "financial_id",
          "desc": "Financial identifier. You can find the list of available ids via our [Help Center](https://www.tradingview.com/?solution=43000564727).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "period",
          "desc": "Reporting period. Possible values are \"TTM\", \"FY\", \"FQ\", \"FH\", \"D\".",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "gaps",
          "desc": "Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data). Possible values include: [barmerge.gaps_on](#const_barmerge.gaps_on), [barmerge.gaps_off](#const_barmerge.gaps_off). [barmerge.gaps_on](#const_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#const_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values. Default value is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "currency",
          "desc": "Optional. Currency into which the symbol's financial metrics (e.g. Net Income) are to be converted. The conversion rate depends on the previous daily value of a corresponding currency pair from the most popular exchange. A spread symbol is used if no exchange provides the rate directly. Possible values: a \"string\" representing a valid currency code (e.g., \"USD\" or \"USDT\") or a constant from the `currency.*` namespace (e.g., [currency.USD](#const_currency.USD) or [currency.USDT](#const_currency.USDT)). The default is [syminfo.currency](#var_syminfo.currency).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"request.financial\")",
        "f = request.financial(\"NASDAQ:MSFT\", \"ACCOUNTS_PAYABLE\", \"FY\")",
        "plot(f)"
      ],
      "returns": ["Requested series."],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ],
      "syntax": [
        "request.financial(symbol, financial_id, period, gaps, ignore_invalid_symbol, currency) → series float"
      ],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.quandl",
      "desc": [
        "*Note:* This function has been deprecated due to the API change from NASDAQ Data Link. Requests for \"QUANDL\" symbols are no longer valid and requests for them return a runtime error.",
        "Some of the data previously provided by this function is available on TradingView through other feeds, such as \"BCHAIN\" or \"FRED\". Use Symbol Search to look for such data based on its description. Commitment of Traders (COT) data can be requested using the official [LibraryCOT](https://www.tradingview.com/v/ysFf2OTq/) library.",
        "Requests [Nasdaq Data Link](https://data.nasdaq.com/) (formerly Quandl) data for a symbol."
      ],
      "args": [
        {
          "name": "ticker",
          "desc": "Symbol. Note that the name of a time series and Quandl data feed should be divided by a forward slash. For example: \"CFTC/SB_FO_ALL\".",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "gaps",
          "desc": "Merge strategy for the requested data (requested data automatically merges with the main series: OHLC data). Possible values include: [barmerge.gaps_on](#const_barmerge.gaps_on), [barmerge.gaps_off](#const_barmerge.gaps_off). [barmerge.gaps_on](#const_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#const_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous, nearest existing values. Default value is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "index",
          "desc": "A Quandl time-series column index.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"request.quandl\")",
        "f = request.quandl(\"CFTC/SB_FO_ALL\", barmerge.gaps_off, 0)",
        "plot(f)"
      ],
      "returns": ["Requested series."],
      "remarks": [
        "You can learn more about how to find ticker and index values in our [Help Center](https://www.tradingview.com/chart/?solution=43000568613)."
      ],
      "seeAlso": [
        "[request.security](#fun_request.security)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ],
      "syntax": ["request.quandl(ticker, gaps, index, ignore_invalid_symbol) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ticker.new",
      "desc": ["Creates a ticker identifier for requesting additional data for the script."],
      "args": [
        {
          "name": "prefix",
          "desc": "Exchange prefix. For example: 'BATS', 'NYSE', 'NASDAQ'. Exchange prefix of main series is [syminfo.prefix](#var_syminfo.prefix).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "ticker",
          "desc": "Ticker name. For example 'AAPL', 'MSFT', 'EURUSD'. Ticker name of the main series is [syminfo.ticker](#var_syminfo.ticker).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "session",
          "desc": "Session type. Optional argument. Possible values: [session.regular](#const_session.regular), [session.extended](#const_session.extended). Session type of the current chart is [syminfo.session](#var_syminfo.session). If session is not given, then [syminfo.session](#var_syminfo.session) value is used.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "adjustment",
          "desc": "Adjustment type. Optional argument. Possible values: [adjustment.none](#const_adjustment.none), [adjustment.splits](#const_adjustment.splits), [adjustment.dividends](#const_adjustment.dividends). If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.new\", overlay=true) ",
        "t = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)",
        "t2 = ticker.heikinashi(t)",
        "c = request.security(t2, timeframe.period, low, barmerge.gaps_on)",
        "plot(c, style=plot.style_linebr)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "remarks": [
        "You may use return value of [ticker.new](#fun_ticker.new) function as input argument for [ticker.heikinashi](#fun_ticker.heikinashi), [ticker.renko](#fun_ticker.renko), [ticker.linebreak](#fun_ticker.linebreak), [ticker.kagi](#fun_ticker.kagi), [ticker.pointfigure](#fun_ticker.pointfigure) functions."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.session](#var_syminfo.session)",
        "[session.extended](#const_session.extended)",
        "[session.regular](#const_session.regular)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[adjustment.none](#var_adjustment.none)",
        "[adjustment.splits](#var_adjustment.splits)",
        "[adjustment.dividends](#var_adjustment.dividends)",
        "[backadjustment.inherit](#const_backadjustment.inherit)",
        "[backadjustment.on](#const_backadjustment.on)",
        "[backadjustment.off](#const_backadjustment.off)",
        "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
        "[settlement_as_close.on](#const_settlement_as_close.on)",
        "[settlement_as_close.off](#const_settlement_as_close.off)"
      ],
      "syntax": ["ticker.new(prefix, ticker, session, adjustment) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.new",
      "desc": ["Creates a ticker identifier for requesting additional data for the script."],
      "args": [
        {
          "name": "prefix",
          "desc": "Exchange prefix. For example: 'BATS', 'NYSE', 'NASDAQ'. Exchange prefix of main series is [syminfo.prefix](#var_syminfo.prefix).",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "ticker",
          "desc": "Ticker name. For example 'AAPL', 'MSFT', 'EURUSD'. Ticker name of the main series is [syminfo.ticker](#var_syminfo.ticker).",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "session",
          "desc": "Session type. Optional argument. Possible values: [session.regular](#const_session.regular), [session.extended](#const_session.extended). Session type of the current chart is [syminfo.session](#var_syminfo.session). If session is not given, then [syminfo.session](#var_syminfo.session) value is used.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "adjustment",
          "desc": "Adjustment type. Optional argument. Possible values: [adjustment.none](#const_adjustment.none), [adjustment.splits](#const_adjustment.splits), [adjustment.dividends](#const_adjustment.dividends). If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "backadjustment",
          "desc": "Specifies whether past contract data on continuous futures symbols is back-adjusted. This setting only affects the data from symbols with this option available on their charts. Optional. The default is [backadjustment.inherit](#var_backadjustment.inherit), meaning that the new ticker ID inherits the symbol's default setting. Possible values: [backadjustment.inherit](#var_backadjustment.inherit), [backadjustment.on](#var_backadjustment.on), [backadjustment.off](#var_backadjustment.off).",
          "allowedTypeIDs": [
            "simple backadjustment",
            "input backadjustment",
            "const backadjustment"
          ],
          "displayType": "simple backadjustment"
        },
        {
          "name": "settlement_as_close",
          "desc": "Specifies whether a futures symbol's [close](#var_close) value represents the actual closing price or the settlement price on \"1D\" and higher timeframes. This setting only affects the data from symbols with this option available on their charts. Optional. The default is [settlement_as_close.inherit](#var_settlement_as_close.inherit), meaning that the new ticker ID inherits the chart symbol's default setting. Possible values: [settlement_as_close.inherit](#var_settlement_as_close.inherit), [settlement_as_close.on](#var_settlement_as_close.on), [settlement_as_close.off](#var_settlement_as_close.off).",
          "allowedTypeIDs": ["simple settlement", "input settlement", "const settlement"],
          "displayType": "simple settlement"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.new\", overlay=true) ",
        "t = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)",
        "t2 = ticker.heikinashi(t)",
        "c = request.security(t2, timeframe.period, low, barmerge.gaps_on)",
        "plot(c, style=plot.style_linebr)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "remarks": [
        "You may use return value of [ticker.new](#fun_ticker.new) function as input argument for [ticker.heikinashi](#fun_ticker.heikinashi), [ticker.renko](#fun_ticker.renko), [ticker.linebreak](#fun_ticker.linebreak), [ticker.kagi](#fun_ticker.kagi), [ticker.pointfigure](#fun_ticker.pointfigure) functions."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.session](#var_syminfo.session)",
        "[session.extended](#const_session.extended)",
        "[session.regular](#const_session.regular)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[adjustment.none](#var_adjustment.none)",
        "[adjustment.splits](#var_adjustment.splits)",
        "[adjustment.dividends](#var_adjustment.dividends)",
        "[backadjustment.inherit](#const_backadjustment.inherit)",
        "[backadjustment.on](#const_backadjustment.on)",
        "[backadjustment.off](#const_backadjustment.off)",
        "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
        "[settlement_as_close.on](#const_settlement_as_close.on)",
        "[settlement_as_close.off](#const_settlement_as_close.off)"
      ],
      "syntax": [
        "ticker.new(prefix, ticker, session, adjustment, backadjustment, settlement_as_close) → simple string"
      ],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.standard",
      "desc": [
        "Creates a ticker to request data from a standard chart that is unaffected by modifiers like extended session, dividend adjustment, currency conversion, and the calculations of non-standard chart types: Heikin Ashi, Renko, etc. Among other things, this makes it possible to retrieve standard chart values when the script is running on a non-standard chart."
      ],
      "args": [
        {
          "name": "symbol",
          "desc": "A ticker ID to be converted into its standard form. Optional. The default is [syminfo.tickerid](#var_syminfo.tickerid).",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.standard\", overlay = true)",
        "// This script should be run on a non-standard chart such as HA, Renko...",
        "",
        "// Requests data from the chart type the script is running on.",
        "chartTypeValue = request.security(syminfo.tickerid, \"1D\", close)",
        "",
        "// Request data from the standard chart type, regardless of the chart type the script is running on.",
        "standardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)",
        "",
        "// This will not use a standard ticker ID because the `symbol` argument contains only the ticker — not the prefix (exchange).",
        "standardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)",
        "",
        "plot(chartTypeValue)",
        "plot(standardChartValue, color = color.green)"
      ],
      "returns": [
        "A string representing the ticker of a standard chart in the \"prefix:ticker\" format. If the `symbol` argument does not contain the prefix and ticker information, the function returns the supplied argument as is."
      ],
      "seeAlso": ["[request.security](#fun_request.security)"],
      "syntax": ["ticker.standard(symbol) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.standard",
      "desc": [
        "Creates a ticker to request data from a standard chart that is unaffected by modifiers like extended session, dividend adjustment, currency conversion, and the calculations of non-standard chart types: Heikin Ashi, Renko, etc. Among other things, this makes it possible to retrieve standard chart values when the script is running on a non-standard chart."
      ],
      "args": [
        {
          "name": "symbol",
          "desc": "A ticker ID to be converted into its standard form. Optional. The default is [syminfo.tickerid](#var_syminfo.tickerid).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.standard\", overlay = true)",
        "// This script should be run on a non-standard chart such as HA, Renko...",
        "",
        "// Requests data from the chart type the script is running on.",
        "chartTypeValue = request.security(syminfo.tickerid, \"1D\", close)",
        "",
        "// Request data from the standard chart type, regardless of the chart type the script is running on.",
        "standardChartValue = request.security(ticker.standard(syminfo.tickerid), \"1D\", close)",
        "",
        "// This will not use a standard ticker ID because the `symbol` argument contains only the ticker — not the prefix (exchange).",
        "standardChartValue2 = request.security(ticker.standard(syminfo.ticker), \"1D\", close)",
        "",
        "plot(chartTypeValue)",
        "plot(standardChartValue, color = color.green)"
      ],
      "returns": [
        "A string representing the ticker of a standard chart in the \"prefix:ticker\" format. If the `symbol` argument does not contain the prefix and ticker information, the function returns the supplied argument as is."
      ],
      "seeAlso": ["[request.security](#fun_request.security)"],
      "syntax": ["ticker.standard(symbol) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "syminfo.prefix",
      "desc": ["Returns exchange prefix of the `symbol`, e.g. \"NASDAQ\"."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo.prefix fun\", overlay=true)",
        "i_sym = input.symbol(\"NASDAQ:AAPL\")",
        "pref = syminfo.prefix(i_sym)",
        "tick = syminfo.ticker(i_sym)",
        "t = ticker.new(pref, tick, session.extended)",
        "s = request.security(t, \"1D\", close)",
        "plot(s)"
      ],
      "returns": ["Returns exchange prefix of the `symbol`, e.g. \"NASDAQ\"."],
      "remarks": [
        "The result of the function is used in the [ticker.new](#fun_ticker.new)/[ticker.modify](#fun_ticker.modify) and [request.security](#fun_request.security)."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.prefix](#var_syminfo.prefix)",
        "[syminfo.ticker](#fun_syminfo.ticker)",
        "[ticker.new](#fun_ticker.new)"
      ],
      "syntax": ["syminfo.prefix(symbol) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "syminfo.prefix",
      "desc": ["Returns exchange prefix of the `symbol`, e.g. \"NASDAQ\"."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo.prefix fun\", overlay=true)",
        "i_sym = input.symbol(\"NASDAQ:AAPL\")",
        "pref = syminfo.prefix(i_sym)",
        "tick = syminfo.ticker(i_sym)",
        "t = ticker.new(pref, tick, session.extended)",
        "s = request.security(t, \"1D\", close)",
        "plot(s)"
      ],
      "returns": ["Returns exchange prefix of the `symbol`, e.g. \"NASDAQ\"."],
      "remarks": [
        "The result of the function is used in the [ticker.new](#fun_ticker.new)/[ticker.modify](#fun_ticker.modify) and [request.security](#fun_request.security)."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.prefix](#var_syminfo.prefix)",
        "[syminfo.ticker](#fun_syminfo.ticker)",
        "[ticker.new](#fun_ticker.new)"
      ],
      "syntax": ["syminfo.prefix(symbol) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "syminfo.ticker",
      "desc": ["Returns `symbol` name without exchange prefix, e.g. \"AAPL\"."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo.ticker fun\", overlay=true) ",
        "i_sym = input.symbol(\"NASDAQ:AAPL\")",
        "pref = syminfo.prefix(i_sym)",
        "tick = syminfo.ticker(i_sym)",
        "t = ticker.new(pref, tick, session.extended)",
        "s = request.security(t, \"1D\", close)",
        "plot(s)"
      ],
      "returns": ["Returns `symbol` name without exchange prefix, e.g. \"AAPL\"."],
      "remarks": [
        "The result of the function is used in the [ticker.new](#fun_ticker.new)/[ticker.modify](#fun_ticker.modify) and [request.security](#fun_request.security)."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.prefix](#var_syminfo.prefix)",
        "[syminfo.prefix](#fun_syminfo.prefix)",
        "[ticker.new](#fun_ticker.new)"
      ],
      "syntax": ["syminfo.ticker(symbol) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "syminfo.ticker",
      "desc": ["Returns `symbol` name without exchange prefix, e.g. \"AAPL\"."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\".",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"syminfo.ticker fun\", overlay=true) ",
        "i_sym = input.symbol(\"NASDAQ:AAPL\")",
        "pref = syminfo.prefix(i_sym)",
        "tick = syminfo.ticker(i_sym)",
        "t = ticker.new(pref, tick, session.extended)",
        "s = request.security(t, \"1D\", close)",
        "plot(s)"
      ],
      "returns": ["Returns `symbol` name without exchange prefix, e.g. \"AAPL\"."],
      "remarks": [
        "The result of the function is used in the [ticker.new](#fun_ticker.new)/[ticker.modify](#fun_ticker.modify) and [request.security](#fun_request.security)."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.prefix](#var_syminfo.prefix)",
        "[syminfo.prefix](#fun_syminfo.prefix)",
        "[ticker.new](#fun_ticker.new)"
      ],
      "syntax": ["syminfo.ticker(symbol) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.modify",
      "desc": ["Creates a ticker identifier for requesting additional data for the script."],
      "args": [
        {
          "name": "tickerid",
          "desc": "Symbol name with exchange prefix, e.g. 'BATS:MSFT', 'NASDAQ:MSFT' or tickerid with session and adjustment from the [ticker.new](#fun_ticker.new) function.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "session",
          "desc": "Session type. Optional argument. Possible values: [session.regular](#const_session.regular), [session.extended](#const_session.extended). Session type of the current chart is [syminfo.session](#var_syminfo.session). If session is not given, then [syminfo.session](#var_syminfo.session) value is used.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "adjustment",
          "desc": "Adjustment type. Optional argument. Possible values: [adjustment.none](#const_adjustment.none), [adjustment.splits](#const_adjustment.splits), [adjustment.dividends](#const_adjustment.dividends). If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker_modify\", overlay=true)",
        "t1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)",
        "c1 = request.security(t1, \"D\", close)",
        "t2 = ticker.modify(t1, session.extended)",
        "c2 = request.security(t2, \"2D\", close)",
        "plot(c1)",
        "plot(c2)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.session](#var_syminfo.session)",
        "[session.extended](#const_session.extended)",
        "[session.regular](#const_session.regular)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[adjustment.none](#const_adjustment.none)",
        "[adjustment.splits](#const_adjustment.splits)",
        "[adjustment.dividends](#const_adjustment.dividends)",
        "[backadjustment.inherit](#const_backadjustment.inherit)",
        "[backadjustment.on](#const_backadjustment.on)",
        "[backadjustment.off](#const_backadjustment.off)",
        "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
        "[settlement_as_close.on](#const_settlement_as_close.on)",
        "[settlement_as_close.off](#const_settlement_as_close.off)"
      ],
      "syntax": ["ticker.modify(tickerid, session, adjustment) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.modify",
      "desc": ["Creates a ticker identifier for requesting additional data for the script."],
      "args": [
        {
          "name": "tickerid",
          "desc": "Symbol name with exchange prefix, e.g. 'BATS:MSFT', 'NASDAQ:MSFT' or tickerid with session and adjustment from the [ticker.new](#fun_ticker.new) function.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "session",
          "desc": "Session type. Optional argument. Possible values: [session.regular](#const_session.regular), [session.extended](#const_session.extended). Session type of the current chart is [syminfo.session](#var_syminfo.session). If session is not given, then [syminfo.session](#var_syminfo.session) value is used.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "adjustment",
          "desc": "Adjustment type. Optional argument. Possible values: [adjustment.none](#const_adjustment.none), [adjustment.splits](#const_adjustment.splits), [adjustment.dividends](#const_adjustment.dividends). If adjustment is not given, then default adjustment value is used (can be different depending on particular instrument).",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "backadjustment",
          "desc": "Specifies whether past contract data on continuous futures symbols is back-adjusted. This setting only affects the data from symbols with this option available on their charts. Optional. The default is [backadjustment.inherit](#var_backadjustment.inherit), meaning that the modified ticker ID inherits the setting from the ticker ID passed to the `tickerid` parameter, or it inherits the symbol's default if the `tickerid` does not specify this setting. Possible values: [backadjustment.inherit](#var_backadjustment.inherit), [backadjustment.on](#var_backadjustment.on), [backadjustment.off](#var_backadjustment.off).",
          "allowedTypeIDs": [
            "simple backadjustment",
            "input backadjustment",
            "const backadjustment"
          ],
          "displayType": "simple backadjustment"
        },
        {
          "name": "settlement_as_close",
          "desc": "Specifies whether a futures symbol's [close](#var_close) value represents the actual closing price or the settlement price on \"1D\" and higher timeframes. This setting only affects the data from symbols with this option available on their charts. Optional. The default is [settlement_as_close.inherit](#var_settlement_as_close.inherit), meaning that the modified ticker ID inherits the setting from the `tickerid` passed into the function, or it inherits the chart symbol's default if the `tickerid` does not specify this setting. Possible values: [settlement_as_close.inherit](#var_settlement_as_close.inherit), [settlement_as_close.on](#var_settlement_as_close.on), [settlement_as_close.off](#var_settlement_as_close.off).",
          "allowedTypeIDs": ["simple settlement", "input settlement", "const settlement"],
          "displayType": "simple settlement"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker_modify\", overlay=true)",
        "t1 = ticker.new(syminfo.prefix, syminfo.ticker, session.regular, adjustment.splits)",
        "c1 = request.security(t1, \"D\", close)",
        "t2 = ticker.modify(t1, session.extended)",
        "c2 = request.security(t2, \"2D\", close)",
        "plot(c1)",
        "plot(c2)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[syminfo.session](#var_syminfo.session)",
        "[session.extended](#const_session.extended)",
        "[session.regular](#const_session.regular)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[adjustment.none](#const_adjustment.none)",
        "[adjustment.splits](#const_adjustment.splits)",
        "[adjustment.dividends](#const_adjustment.dividends)",
        "[backadjustment.inherit](#const_backadjustment.inherit)",
        "[backadjustment.on](#const_backadjustment.on)",
        "[backadjustment.off](#const_backadjustment.off)",
        "[settlement_as_close.inherit](#const_settlement_as_close.inherit)",
        "[settlement_as_close.on](#const_settlement_as_close.on)",
        "[settlement_as_close.off](#const_settlement_as_close.off)"
      ],
      "syntax": [
        "ticker.modify(tickerid, session, adjustment, backadjustment, settlement_as_close) → simple string"
      ],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.inherit",
      "desc": [
        "Constructs a ticker ID for the specified `symbol` with additional parameters inherited from the ticker ID passed into the function call, allowing the script to request a symbol's data using the same modifiers that the `from_tickerid` has, including extended session, dividend adjustment, currency conversion, non-standard chart types, back-adjustment, settlement-as-close, etc."
      ],
      "args": [
        {
          "name": "from_tickerid",
          "desc": "The ticker ID to inherit modifiers from.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "symbol",
          "desc": "The symbol to construct the new ticker ID for.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.inherit\")",
        "",
        "//@variable A \"NASDAQ:AAPL\" ticker ID with Extender Hours enabled.",
        "tickerExtHours = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)",
        "//@variable A Heikin Ashi ticker ID for \"NASDAQ:AAPL\" with Extended Hours enabled.",
        "HAtickerExtHours = ticker.heikinashi(tickerExtHours)",
        "//@variable The \"NASDAQ:MSFT\" symbol with no modifiers.",
        "testSymbol = \"NASDAQ:MSFT\"",
        "//@variable A ticker ID for \"NASDAQ:MSFT\" with inherited Heikin Ashi and Extended Hours modifiers.",
        "testSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)",
        "",
        "//@variable The `close` price requested using \"NASDAQ:MSFT\" with inherited modifiers. ",
        "secData = request.security(testSymbolHAtickerExtHours, \"60\", close, ignore_invalid_symbol = true)",
        "//@variable The `close` price requested using \"NASDAQ:MSFT\" without modifiers. ",
        "compareData = request.security(testSymbol, \"60\", close, ignore_invalid_symbol = true)",
        "",
        "plot(secData, color = color.green)",
        "plot(compareData)"
      ],
      "remarks": [
        "If the constructed ticker ID inherits a modifier that doesn't apply to the symbol (e.g., if the `from_tickerid` has Extended Hours enabled, but no such option is available for the `symbol`), the script will ignore the modifier when requesting data using the ID."
      ],
      "syntax": ["ticker.inherit(from_tickerid, symbol) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.inherit",
      "desc": [
        "Constructs a ticker ID for the specified `symbol` with additional parameters inherited from the ticker ID passed into the function call, allowing the script to request a symbol's data using the same modifiers that the `from_tickerid` has, including extended session, dividend adjustment, currency conversion, non-standard chart types, back-adjustment, settlement-as-close, etc."
      ],
      "args": [
        {
          "name": "from_tickerid",
          "desc": "The ticker ID to inherit modifiers from.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "symbol",
          "desc": "The symbol to construct the new ticker ID for.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.inherit\")",
        "",
        "//@variable A \"NASDAQ:AAPL\" ticker ID with Extender Hours enabled.",
        "tickerExtHours = ticker.new(\"NASDAQ\", \"AAPL\", session.extended)",
        "//@variable A Heikin Ashi ticker ID for \"NASDAQ:AAPL\" with Extended Hours enabled.",
        "HAtickerExtHours = ticker.heikinashi(tickerExtHours)",
        "//@variable The \"NASDAQ:MSFT\" symbol with no modifiers.",
        "testSymbol = \"NASDAQ:MSFT\"",
        "//@variable A ticker ID for \"NASDAQ:MSFT\" with inherited Heikin Ashi and Extended Hours modifiers.",
        "testSymbolHAtickerExtHours = ticker.inherit(HAtickerExtHours, testSymbol)",
        "",
        "//@variable The `close` price requested using \"NASDAQ:MSFT\" with inherited modifiers. ",
        "secData = request.security(testSymbolHAtickerExtHours, \"60\", close, ignore_invalid_symbol = true)",
        "//@variable The `close` price requested using \"NASDAQ:MSFT\" without modifiers. ",
        "compareData = request.security(testSymbol, \"60\", close, ignore_invalid_symbol = true)",
        "",
        "plot(secData, color = color.green)",
        "plot(compareData)"
      ],
      "remarks": [
        "If the constructed ticker ID inherits a modifier that doesn't apply to the symbol (e.g., if the `from_tickerid` has Extended Hours enabled, but no such option is available for the `symbol`), the script will ignore the modifier when requesting data using the ID."
      ],
      "syntax": ["ticker.inherit(from_tickerid, symbol) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.heikinashi",
      "desc": ["Creates a ticker identifier for requesting Heikin Ashi bar values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.heikinashi\", overlay=true) ",
        "heikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)",
        "",
        "heikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)",
        "plot(heikinashi_close)",
        "plot(heikinashi_aapl_60_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.kagi](#fun_ticker.kagi)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.heikinashi(symbol) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.heikinashi",
      "desc": ["Creates a ticker identifier for requesting Heikin Ashi bar values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.heikinashi\", overlay=true) ",
        "heikinashi_close = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)",
        "",
        "heikinashi_aapl_60_close = request.security(ticker.heikinashi(\"AAPL\"), \"60\", close)",
        "plot(heikinashi_close)",
        "plot(heikinashi_aapl_60_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.kagi](#fun_ticker.kagi)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.heikinashi(symbol) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.renko",
      "desc": ["Creates a ticker identifier for requesting Renko values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "style",
          "desc": "Box Size Assignment Method: 'ATR', 'Traditional'.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "param",
          "desc": "ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "request_wicks",
          "desc": "Specifies if wick values are returned for Renko bricks. When [true](#const_true), [high](#var_high) and [low](#var_low) values requested from a symbol using the ticker formed by this function will include wick values when they are present. When [false](#const_false), [high](#var_high) and [low](#var_low) will always be equal to either [open](#var_open) or [close](#var_close). Optional. The default is [false](#const_false). A detailed explanation of how Renko wicks are calculated can be found in our [Help Center](https://www.tradingview.com/support/solutions/43000481040-what-do-renko-wicks-mean/).",
          "allowedTypeIDs": ["simple bool", "input bool", "const bool"],
          "displayType": "simple bool"
        },
        {
          "name": "source",
          "desc": "The source used to calculate bricks. Optional. Possible values: \"Close\", \"OHLC\". The default is \"Close\".",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.renko\", overlay=true) ",
        "renko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)",
        "renko_close = request.security(renko_tickerid, timeframe.period, close)",
        "plot(renko_close)"
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Renko candles\", overlay=false)",
            "renko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)",
            "[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])",
            "plotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)"
          ]
        }
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.kagi](#fun_ticker.kagi)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.renko(symbol, style, param, request_wicks, source) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.renko",
      "desc": ["Creates a ticker identifier for requesting Renko values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "style",
          "desc": "Box Size Assignment Method: 'ATR', 'Traditional'.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "param",
          "desc": "ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "request_wicks",
          "desc": "Specifies if wick values are returned for Renko bricks. When [true](#const_true), [high](#var_high) and [low](#var_low) values requested from a symbol using the ticker formed by this function will include wick values when they are present. When [false](#const_false), [high](#var_high) and [low](#var_low) will always be equal to either [open](#var_open) or [close](#var_close). Optional. The default is [false](#const_false). A detailed explanation of how Renko wicks are calculated can be found in our [Help Center](https://www.tradingview.com/support/solutions/43000481040-what-do-renko-wicks-mean/).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "source",
          "desc": "The source used to calculate bricks. Optional. Possible values: \"Close\", \"OHLC\". The default is \"Close\".",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.renko\", overlay=true) ",
        "renko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)",
        "renko_close = request.security(renko_tickerid, timeframe.period, close)",
        "plot(renko_close)"
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Renko candles\", overlay=false)",
            "renko_tickerid = ticker.renko(syminfo.tickerid, \"ATR\", 10)",
            "[renko_open, renko_high, renko_low, renko_close] = request.security(renko_tickerid, timeframe.period, [open, high, low, close])",
            "plotcandle(renko_open, renko_high, renko_low, renko_close, color = renko_close > renko_open ? color.green : color.red)"
          ]
        }
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.kagi](#fun_ticker.kagi)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.renko(symbol, style, param, request_wicks, source) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.linebreak",
      "desc": ["Creates a ticker identifier for requesting Line Break values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "number_of_lines",
          "desc": "Number of line.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.linebreak\", overlay=true) ",
        "linebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)",
        "linebreak_close = request.security(linebreak_tickerid, timeframe.period, close)",
        "plot(linebreak_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.kagi](#fun_ticker.kagi)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.linebreak(symbol, number_of_lines) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.linebreak",
      "desc": ["Creates a ticker identifier for requesting Line Break values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "number_of_lines",
          "desc": "Number of line.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.linebreak\", overlay=true) ",
        "linebreak_tickerid = ticker.linebreak(syminfo.tickerid, 3)",
        "linebreak_close = request.security(linebreak_tickerid, timeframe.period, close)",
        "plot(linebreak_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.kagi](#fun_ticker.kagi)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.linebreak(symbol, number_of_lines) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.kagi",
      "desc": ["Creates a ticker identifier for requesting Kagi values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "reversal",
          "desc": "Reversal amount (absolute price value).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.kagi\", overlay=true) ",
        "kagi_tickerid = ticker.kagi(syminfo.tickerid, 3)",
        "kagi_close = request.security(kagi_tickerid, timeframe.period, close)",
        "plot(kagi_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.kagi(symbol, reversal) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.kagi",
      "desc": ["Creates a ticker identifier for requesting Kagi values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "reversal",
          "desc": "Reversal amount (absolute price value).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.kagi\", overlay=true) ",
        "kagi_tickerid = ticker.kagi(syminfo.tickerid, 3)",
        "kagi_close = request.security(kagi_tickerid, timeframe.period, close)",
        "plot(kagi_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.pointfigure](#fun_ticker.pointfigure)"
      ],
      "syntax": ["ticker.kagi(symbol, reversal) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "ticker.pointfigure",
      "desc": ["Creates a ticker identifier for requesting Point & Figure values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "source",
          "desc": "The source for calculating Point & Figure. Possible values are: 'hl', 'close'.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "style",
          "desc": "Box Size Assignment Method: 'ATR', 'Traditional'.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "param",
          "desc": "ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "reversal",
          "desc": "Reversal amount.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.pointfigure\", overlay=true) ",
        "pnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)",
        "pnf_close = request.security(pnf_tickerid, timeframe.period, close)",
        "plot(pnf_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.kagi](#fun_ticker.kagi)"
      ],
      "syntax": ["ticker.pointfigure(symbol, source, style, param, reversal) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "ticker.pointfigure",
      "desc": ["Creates a ticker identifier for requesting Point & Figure values."],
      "args": [
        {
          "name": "symbol",
          "desc": "Symbol ticker identifier.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "source",
          "desc": "The source for calculating Point & Figure. Possible values are: 'hl', 'close'.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "style",
          "desc": "Box Size Assignment Method: 'ATR', 'Traditional'.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "param",
          "desc": "ATR Length if `style` is equal to 'ATR', or Box Size if `style` is equal to 'Traditional'.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "reversal",
          "desc": "Reversal amount.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ticker.pointfigure\", overlay=true) ",
        "pnf_tickerid = ticker.pointfigure(syminfo.tickerid, \"hl\", \"Traditional\", 1, 3)",
        "pnf_close = request.security(pnf_tickerid, timeframe.period, close)",
        "plot(pnf_close)"
      ],
      "returns": [
        "String value of ticker id, that can be supplied to [request.security](#fun_request.security) function."
      ],
      "seeAlso": [
        "[syminfo.tickerid](#var_syminfo.tickerid)",
        "[syminfo.ticker](#var_syminfo.ticker)",
        "[request.security](#fun_request.security)",
        "[ticker.heikinashi](#fun_ticker.heikinashi)",
        "[ticker.renko](#fun_ticker.renko)",
        "[ticker.linebreak](#fun_ticker.linebreak)",
        "[ticker.kagi](#fun_ticker.kagi)"
      ],
      "syntax": ["ticker.pointfigure(symbol, source, style, param, reversal) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "time",
      "desc": [
        "The time function returns the UNIX time of the current bar for the specified timeframe and session or NaN if the time point is out of session."
      ],
      "args": [
        {
          "name": "timeframe",
          "desc": "Timeframe. An empty string is interpreted as the current timeframe of the chart.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bars_back",
          "desc": "Optional. The bar offset on the script's main timeframe. If the value is positive, the function retrieves the timestamp of the bar N bars back relative to the current bar on the main timeframe. If the value is a negative number from -1 to -500, the function retrieves the expected time of a future bar on that timeframe. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "// Try this on chart AAPL,1",
            "timeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0",
            "plot(timeinrange(\"1\", \"1300-1400\"), color=color.red)",
            "",
            "// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:",
            "newbar(res) => ta.change(time(res)) == 0 ? 0 : 1",
            "plot(newbar(\"10\"))"
          ]
        },
        {
          "desc": [
            "While setting up a session you can specify not just the hours and minutes but also the days of the week that will be included in that session.",
            "If the days aren't specified, the session is considered to have been set from Sunday (1) to Saturday (7), i.e. \"1100-2000\" is the same as \"1100-1200:1234567\".",
            "",
            "You can change that by specifying the days. For example, on a symbol that is traded seven days a week with the 24-hour trading session the following script will not color Saturdays and Sundays:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time(timeframe.period, \"0000-0000:23456\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        },
        {
          "desc": [
            "One `session` argument can include several different sessions, separated by commas. For example, the following script will highlight the bars from 10:00 to 11:00 and from 14:00 to 15:00 (workdays only):"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        }
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": ["[time](#var_time) (variable)"],
      "syntax": ["time(timeframe, bars_back) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "time",
      "desc": [
        "The time function returns the UNIX time of the current bar for the specified timeframe and session or NaN if the time point is out of session."
      ],
      "args": [
        {
          "name": "timeframe",
          "desc": "Timeframe. An empty string is interpreted as the current timeframe of the chart.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "session",
          "desc": "Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bars_back",
          "desc": "Optional. The bar offset on the script's main timeframe. If the value is positive, the function retrieves the timestamp of the bar N bars back relative to the current bar on the main timeframe. If the value is a negative number from -1 to -500, the function retrieves the expected time of a future bar on that timeframe. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "// Try this on chart AAPL,1",
            "timeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0",
            "plot(timeinrange(\"1\", \"1300-1400\"), color=color.red)",
            "",
            "// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:",
            "newbar(res) => ta.change(time(res)) == 0 ? 0 : 1",
            "plot(newbar(\"10\"))"
          ]
        },
        {
          "desc": [
            "While setting up a session you can specify not just the hours and minutes but also the days of the week that will be included in that session.",
            "If the days aren't specified, the session is considered to have been set from Sunday (1) to Saturday (7), i.e. \"1100-2000\" is the same as \"1100-1200:1234567\".",
            "",
            "You can change that by specifying the days. For example, on a symbol that is traded seven days a week with the 24-hour trading session the following script will not color Saturdays and Sundays:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time(timeframe.period, \"0000-0000:23456\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        },
        {
          "desc": [
            "One `session` argument can include several different sessions, separated by commas. For example, the following script will highlight the bars from 10:00 to 11:00 and from 14:00 to 15:00 (workdays only):"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        }
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": ["[time](#var_time) (variable)"],
      "syntax": ["time(timeframe, session, bars_back) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "time",
      "desc": [
        "The time function returns the UNIX time of the current bar for the specified timeframe and session or NaN if the time point is out of session."
      ],
      "args": [
        {
          "name": "timeframe",
          "desc": "Timeframe. An empty string is interpreted as the current timeframe of the chart.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "session",
          "desc": "Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "timezone",
          "desc": "Timezone of the `session` argument. Can only be used when a `session` is specified. Optional. The default is [syminfo.timezone](#var_syminfo.timezone). Can be specified in GMT notation (e.g. \"GMT-5\") or as an [IANA time zone database name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (e.g. \"America/New_York\").",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bars_back",
          "desc": "Optional. The bar offset on the script's main timeframe. If the value is positive, the function retrieves the timestamp of the bar N bars back relative to the current bar on the main timeframe. If the value is a negative number from -1 to -500, the function retrieves the expected time of a future bar on that timeframe. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "// Try this on chart AAPL,1",
            "timeinrange(res, sess) => not na(time(res, sess, \"America/New_York\")) ? 1 : 0",
            "plot(timeinrange(\"1\", \"1300-1400\"), color=color.red)",
            "",
            "// This plots 1.0 at every start of 10 minute bar on a 1 minute chart:",
            "newbar(res) => ta.change(time(res)) == 0 ? 0 : 1",
            "plot(newbar(\"10\"))"
          ]
        },
        {
          "desc": [
            "While setting up a session you can specify not just the hours and minutes but also the days of the week that will be included in that session.",
            "If the days aren't specified, the session is considered to have been set from Sunday (1) to Saturday (7), i.e. \"1100-2000\" is the same as \"1100-1200:1234567\".",
            "",
            "You can change that by specifying the days. For example, on a symbol that is traded seven days a week with the 24-hour trading session the following script will not color Saturdays and Sundays:"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time(timeframe.period, \"0000-0000:23456\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        },
        {
          "desc": [
            "One `session` argument can include several different sessions, separated by commas. For example, the following script will highlight the bars from 10:00 to 11:00 and from 14:00 to 15:00 (workdays only):"
          ],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time(timeframe.period, \"1000-1100,1400-1500:23456\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        }
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": ["[time](#var_time) (variable)"],
      "syntax": ["time(timeframe, session, timezone, bars_back) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "time_close",
      "desc": [
        "Returns the UNIX time of the current bar's close for the specified timeframe and session, or [na](#var_na) if the time point is outside the session. On non-standard price-based chart types (Renko, Line break, Kagi, Point & Figure, and Range), this function returns [na](#var_na) on the chart's realtime bars."
      ],
      "args": [
        {
          "name": "timeframe",
          "desc": "Resolution. An empty string is interpreted as the current resolution of the chart.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bars_back",
          "desc": "Optional. The bar offset on the script's main timeframe. If the value is positive, the function retrieves the timestamp of the bar N bars back relative to the current bar on the main timeframe. If the value is a negative number from -1 to -500, the function retrieves the expected time of a future bar on that timeframe. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        }
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": ["[time_close](#var_time_close) (variable)"],
      "syntax": ["time_close(timeframe, bars_back) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "time_close",
      "desc": [
        "Returns the UNIX time of the current bar's close for the specified timeframe and session, or [na](#var_na) if the time point is outside the session. On non-standard price-based chart types (Renko, Line break, Kagi, Point & Figure, and Range), this function returns [na](#var_na) on the chart's realtime bars."
      ],
      "args": [
        {
          "name": "timeframe",
          "desc": "Resolution. An empty string is interpreted as the current resolution of the chart.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "session",
          "desc": "Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bars_back",
          "desc": "Optional. The bar offset on the script's main timeframe. If the value is positive, the function retrieves the timestamp of the bar N bars back relative to the current bar on the main timeframe. If the value is a negative number from -1 to -500, the function retrieves the expected time of a future bar on that timeframe. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        }
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": ["[time_close](#var_time_close) (variable)"],
      "syntax": ["time_close(timeframe, session, bars_back) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "time_close",
      "desc": [
        "Returns the UNIX time of the current bar's close for the specified timeframe and session, or [na](#var_na) if the time point is outside the session. On non-standard price-based chart types (Renko, Line break, Kagi, Point & Figure, and Range), this function returns [na](#var_na) on the chart's realtime bars."
      ],
      "args": [
        {
          "name": "timeframe",
          "desc": "Resolution. An empty string is interpreted as the current resolution of the chart.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "session",
          "desc": "Session specification. Optional argument, session of the symbol is used by default. An empty string is interpreted as the session of the symbol.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "timezone",
          "desc": "Timezone of the `session` argument. Can only be used when a `session` is specified. Optional. The default is [syminfo.timezone](#var_syminfo.timezone). Can be specified in GMT notation (e.g. \"GMT-5\") or as an [IANA time zone database name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) (e.g. \"America/New_York\").",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bars_back",
          "desc": "Optional. The bar offset on the script's main timeframe. If the value is positive, the function retrieves the timestamp of the bar N bars back relative to the current bar on the main timeframe. If the value is a negative number from -1 to -500, the function retrieves the expected time of a future bar on that timeframe. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"Time\", overlay=true)",
            "t1 = time_close(timeframe.period, \"1200-1300\", \"America/New_York\")",
            "bgcolor(not na(t1) ? color.new(color.blue, 90) : na)"
          ]
        }
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": ["[time_close](#var_time_close) (variable)"],
      "syntax": ["time_close(timeframe, session, timezone, bars_back) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "timestamp",
      "desc": ["Function timestamp returns UNIX time of specified date and time."],
      "args": [
        {
          "name": "dateString",
          "desc": "A string containing the date and, optionally, the time and time zone. Its format must comply with either the [IETF RFC 2822](https://tools.ietf.org/html/rfc2822#section-3.3) or [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standards (\"DD MMM YYYY hh:mm:ss ±hhmm\" or \"YYYY-MM-DDThh:mm:ss±hh:mm\", so \"20 Feb 2020\" or \"2020-02-20\"). If no time is supplied, \"00:00\" is used. If no time zone is supplied, GMT+0 will be used. Note that this diverges from the usual behavior of the function where it returns time in the exchange's timezone.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"timestamp\")",
        "plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)",
        "plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)",
        "plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)",
        "plot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))",
        "plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)",
        "plot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)",
        "plot(timestamp(\"Feb 01 2020 22:10:05\"))",
        "plot(timestamp(\"2011-10-10T14:48:00\"))",
        "plot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[time](#fun_time) (function) [time](#var_time) (variable) [timenow](#var_timenow) (variable) [syminfo.timezone](#var_syminfo.timezone) (variable)"
      ],
      "syntax": ["timestamp(dateString) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "timestamp",
      "desc": ["Function timestamp returns UNIX time of specified date and time."],
      "args": [
        {
          "name": "year",
          "desc": "Year.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "month",
          "desc": "Month.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "day",
          "desc": "Day.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "hour",
          "desc": "(Optional argument) Hour. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "minute",
          "desc": "(Optional argument) Minute. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "second",
          "desc": "(Optional argument) Second. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"timestamp\")",
        "plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)",
        "plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)",
        "plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)",
        "plot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))",
        "plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)",
        "plot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)",
        "plot(timestamp(\"Feb 01 2020 22:10:05\"))",
        "plot(timestamp(\"2011-10-10T14:48:00\"))",
        "plot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[time](#fun_time) (function) [time](#var_time) (variable) [timenow](#var_timenow) (variable) [syminfo.timezone](#var_syminfo.timezone) (variable)"
      ],
      "syntax": ["timestamp(year, month, day, hour, minute, second) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "timestamp",
      "desc": ["Function timestamp returns UNIX time of specified date and time."],
      "args": [
        {
          "name": "year",
          "desc": "Year.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "month",
          "desc": "Month.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "day",
          "desc": "Day.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "hour",
          "desc": "(Optional argument) Hour. Default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "minute",
          "desc": "(Optional argument) Minute. Default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "second",
          "desc": "(Optional argument) Second. Default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"timestamp\")",
        "plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)",
        "plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)",
        "plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)",
        "plot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))",
        "plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)",
        "plot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)",
        "plot(timestamp(\"Feb 01 2020 22:10:05\"))",
        "plot(timestamp(\"2011-10-10T14:48:00\"))",
        "plot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[time](#fun_time) (function) [time](#var_time) (variable) [timenow](#var_timenow) (variable) [syminfo.timezone](#var_syminfo.timezone) (variable)"
      ],
      "syntax": ["timestamp(year, month, day, hour, minute, second) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "timestamp",
      "desc": ["Function timestamp returns UNIX time of specified date and time."],
      "args": [
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "year",
          "desc": "Year.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "month",
          "desc": "Month.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "day",
          "desc": "Day.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "hour",
          "desc": "(Optional argument) Hour. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "minute",
          "desc": "(Optional argument) Minute. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "second",
          "desc": "(Optional argument) Second. Default is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"timestamp\")",
        "plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)",
        "plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)",
        "plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)",
        "plot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))",
        "plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)",
        "plot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)",
        "plot(timestamp(\"Feb 01 2020 22:10:05\"))",
        "plot(timestamp(\"2011-10-10T14:48:00\"))",
        "plot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[time](#fun_time) (function) [time](#var_time) (variable) [timenow](#var_timenow) (variable) [syminfo.timezone](#var_syminfo.timezone) (variable)"
      ],
      "syntax": ["timestamp(timezone, year, month, day, hour, minute, second) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "timestamp",
      "desc": ["Function timestamp returns UNIX time of specified date and time."],
      "args": [
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "year",
          "desc": "Year.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "month",
          "desc": "Month.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "day",
          "desc": "Day.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "hour",
          "desc": "(Optional argument) Hour. Default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "minute",
          "desc": "(Optional argument) Minute. Default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "second",
          "desc": "(Optional argument) Second. Default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"timestamp\")",
        "plot(timestamp(2016, 01, 19, 09, 30), linewidth=3, color=color.green)",
        "plot(timestamp(syminfo.timezone, 2016, 01, 19, 09, 30), color=color.blue)",
        "plot(timestamp(2016, 01, 19, 09, 30), color=color.yellow)",
        "plot(timestamp(\"GMT+6\", 2016, 01, 19, 09, 30))",
        "plot(timestamp(2019, 06, 19, 09, 30, 15), color=color.lime)",
        "plot(timestamp(\"GMT+3\", 2019, 06, 19, 09, 30, 15), color=color.fuchsia)",
        "plot(timestamp(\"Feb 01 2020 22:10:05\"))",
        "plot(timestamp(\"2011-10-10T14:48:00\"))",
        "plot(timestamp(\"04 Dec 1995 00:12:00 GMT+5\"))"
      ],
      "returns": ["UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[time](#fun_time) (function) [time](#var_time) (variable) [timenow](#var_timenow) (variable) [syminfo.timezone](#var_syminfo.timezone) (variable)"
      ],
      "syntax": ["timestamp(timezone, year, month, day, hour, minute, second) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "year",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Year (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the year of the trading day."
      ],
      "seeAlso": [
        "[year](#var_year)",
        "[time](#fun_time)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["year(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "year",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Year (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the year based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the year of the trading day."
      ],
      "seeAlso": [
        "[year](#var_year)",
        "[time](#fun_time)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["year(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "month",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Month (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the month of the trading day."
      ],
      "seeAlso": [
        "[month](#var_month)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["month(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "month",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Month (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the month based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the month of the trading day."
      ],
      "seeAlso": [
        "[month](#var_month)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["month(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "weekofyear",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Week of year (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day."
      ],
      "seeAlso": [
        "[weekofyear](#var_weekofyear)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["weekofyear(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "weekofyear",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Week of year (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the week based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the week of the trading day."
      ],
      "seeAlso": [
        "[weekofyear](#var_weekofyear)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["weekofyear(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "dayofmonth",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Day of month (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the day of the trading day."
      ],
      "seeAlso": [
        "[dayofmonth](#var_dayofmonth)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["dayofmonth(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "dayofmonth",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Day of month (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970.",
        "Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00 UTC-4) this value can be lower by 1 than the day of the trading day."
      ],
      "seeAlso": [
        "[dayofmonth](#var_dayofmonth)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["dayofmonth(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "dayofweek",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Day of week (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[dayofweek](#var_dayofweek)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["dayofweek(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "dayofweek",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Day of week (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "Note that this function returns the day based on the time of the bar's open. For overnight sessions (e.g. EURUSD, where Monday session starts on Sunday, 17:00) this value can be lower by 1 than the day of the trading day.",
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[dayofweek](#var_dayofweek)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["dayofweek(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "hour",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Hour (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[hour](#var_hour)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["hour(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "hour",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Hour (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[hour](#var_hour)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[minute](#fun_minute)",
        "[second](#fun_second)"
      ],
      "syntax": ["hour(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "minute",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Minute (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[minute](#var_minute)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[second](#fun_second)"
      ],
      "syntax": ["minute(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "minute",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Minute (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[minute](#var_minute)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[second](#fun_second)"
      ],
      "syntax": ["minute(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "second",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "returns": ["Second (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[second](#var_second)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)"
      ],
      "syntax": ["second(time) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "second",
      "args": [
        {
          "name": "time",
          "desc": "UNIX time in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "timezone",
          "desc": "Allows adjusting the returned value to a time zone specified in either UTC/GMT notation (e.g., \"UTC-5\", \"GMT+0530\") or as an IANA time zone database name (e.g., \"America/New_York\"). Optional. The default is [syminfo.timezone](#var_syminfo.timezone).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Second (in exchange timezone) for provided UNIX time."],
      "remarks": [
        "UNIX time is the number of milliseconds that have elapsed since 00:00:00 UTC, 1 January 1970."
      ],
      "seeAlso": [
        "[second](#var_second)",
        "[time](#fun_time)",
        "[year](#fun_year)",
        "[month](#fun_month)",
        "[dayofmonth](#fun_dayofmonth)",
        "[dayofweek](#fun_dayofweek)",
        "[hour](#fun_hour)",
        "[minute](#fun_minute)"
      ],
      "syntax": ["second(time, timezone) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.cross",
      "args": [
        {
          "name": "source1",
          "desc": "First data series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "source2",
          "desc": "Second data series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["true if two series have crossed each other, otherwise false."],
      "seeAlso": ["[ta.change](#fun_ta.change)"],
      "syntax": ["ta.cross(source1, source2) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.cog",
      "desc": [
        "The cog (center of gravity) is an indicator based on statistics and the Fibonacci golden ratio."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.cog\", overlay=true) ",
        "plot(ta.cog(close, 10))",
        "",
        "// the same on pine",
        "pine_cog(source, length) =>",
        "    sum = math.sum(source, length)",
        "    num = 0.0",
        "    for i = 0 to length - 1",
        "        price = source[i]",
        "        num := num + price * (i + 1)",
        "    -num / sum",
        "",
        "plot(pine_cog(close, 10))"
      ],
      "returns": ["Center of Gravity."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": ["[ta.stoch](#fun_ta.stoch)"],
      "syntax": ["ta.cog(source, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.alma",
      "desc": [
        "Arnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "offset",
          "desc": "Controls tradeoff between smoothness (closer to 1) and responsiveness (closer to 0).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "sigma",
          "desc": "Changes the smoothness of ALMA. The larger sigma the smoother ALMA.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.alma\", overlay=true) ",
        "plot(ta.alma(close, 9, 0.85, 6))",
        "",
        "// same on pine, but much less efficient",
        "pine_alma(series, windowsize, offset, sigma) =>",
        "    m = offset * (windowsize - 1)",
        "    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true",
        "    s = windowsize / sigma",
        "    norm = 0.0",
        "    sum = 0.0",
        "    for i = 0 to windowsize - 1",
        "        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))",
        "        norm := norm + weight",
        "        sum := sum + series[windowsize - i - 1] * weight",
        "    sum / norm",
        "plot(pine_alma(close, 9, 0.85, 6))"
      ],
      "returns": ["Arnaud Legoux Moving Average."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.swma](#fun_ta.swma)"
      ],
      "syntax": ["ta.alma(series, length, offset, sigma) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.alma",
      "desc": [
        "Arnaud Legoux Moving Average. It uses Gaussian distribution as weights for moving average."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "offset",
          "desc": "Controls tradeoff between smoothness (closer to 1) and responsiveness (closer to 0).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "sigma",
          "desc": "Changes the smoothness of ALMA. The larger sigma the smoother ALMA.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "floor",
          "desc": "An optional parameter. Specifies whether the offset calculation is floored before ALMA is calculated. Default value is false.",
          "required": true,
          "allowedTypeIDs": ["simple bool", "input bool", "const bool"],
          "displayType": "simple bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.alma\", overlay=true) ",
        "plot(ta.alma(close, 9, 0.85, 6))",
        "",
        "// same on pine, but much less efficient",
        "pine_alma(series, windowsize, offset, sigma) =>",
        "    m = offset * (windowsize - 1)",
        "    //m = math.floor(offset * (windowsize - 1)) // Used as m when math.floor=true",
        "    s = windowsize / sigma",
        "    norm = 0.0",
        "    sum = 0.0",
        "    for i = 0 to windowsize - 1",
        "        weight = math.exp(-1 * math.pow(i - m, 2) / (2 * math.pow(s, 2)))",
        "        norm := norm + weight",
        "        sum := sum + series[windowsize - i - 1] * weight",
        "    sum / norm",
        "plot(pine_alma(close, 9, 0.85, 6))"
      ],
      "returns": ["Arnaud Legoux Moving Average."],
      "remarks": [
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": [
        "[ta.sma](#fun_ta.sma)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.rma](#fun_ta.rma)",
        "[ta.wma](#fun_ta.wma)",
        "[ta.vwma](#fun_ta.vwma)",
        "[ta.swma](#fun_ta.swma)"
      ],
      "syntax": ["ta.alma(series, length, offset, sigma, floor) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.cmo",
      "desc": [
        "Chande Momentum Oscillator. Calculates the difference between the sum of recent gains and the sum of recent losses and then divides the result by the sum of all price movement over the same period."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.cmo\")",
        "plot(ta.cmo(close, 5), color=color.yellow)",
        "",
        "// the same on pine",
        "f_cmo(src, length) =>",
        "    float mom = ta.change(src)",
        "    float sm1 = math.sum((mom >= 0) ? mom : 0.0, length)",
        "    float sm2 = math.sum((mom >= 0) ? 0.0 : -mom, length)",
        "    100 * (sm1 - sm2) / (sm1 + sm2)",
        "",
        "plot(f_cmo(close, 5))"
      ],
      "returns": ["Chande Momentum Oscillator."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": [
        "[ta.rsi](#fun_ta.rsi)",
        "[ta.stoch](#fun_ta.stoch)",
        "[math.sum](#fun_math.sum)"
      ],
      "syntax": ["ta.cmo(series, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.mfi",
      "desc": [
        "Money Flow Index. The Money Flow Index (MFI) is a technical oscillator that uses price and volume for identifying overbought or oversold conditions in an asset."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Money Flow Index\")",
        "",
        "plot(ta.mfi(hlc3, 14), color=color.yellow)",
        "",
        "// the same on pine",
        "pine_mfi(src, length) =>",
        "    float upper = math.sum(volume * (ta.change(src) <= 0.0 ? 0.0 : src), length)",
        "    float lower = math.sum(volume * (ta.change(src) >= 0.0 ? 0.0 : src), length)",
        "    mfi = 100.0 - (100.0 / (1.0 + upper / lower))",
        "    mfi",
        "",
        "plot(pine_mfi(hlc3, 14))"
      ],
      "returns": ["Money Flow Index."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.rsi](#fun_ta.rsi)", "[math.sum](#fun_math.sum)"],
      "syntax": ["ta.mfi(series, length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.wpr",
      "desc": [
        "Williams %R. The oscillator shows the current closing price in relation to the high and low of the past 'length' bars."
      ],
      "args": [
        {
          "name": "length",
          "desc": "Number of bars.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Williams %R\", shorttitle=\"%R\", format=format.price, precision=2)",
        "plot(ta.wpr(14), title=\"%R\", color=color.new(#ff6d00, 0))"
      ],
      "returns": ["Williams %R."],
      "remarks": ["`na` values in the `source` series are ignored."],
      "seeAlso": ["[ta.mfi](#fun_ta.mfi)", "[ta.cmo](#fun_ta.cmo)"],
      "syntax": ["ta.wpr(length) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.bb",
      "desc": [
        "Bollinger Bands. A Bollinger Band is a technical analysis tool defined by a set of lines plotted two standard deviations (positively and negatively) away from a simple moving average (SMA) of the security's price, but can be adjusted to user preferences."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "mult",
          "desc": "Standard deviation factor.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.bb\")",
        "",
        "[middle, upper, lower] = ta.bb(close, 5, 4)",
        "plot(middle, color=color.yellow)",
        "plot(upper, color=color.yellow)",
        "plot(lower, color=color.yellow)",
        "",
        "// the same on pine",
        "f_bb(src, length, mult) =>",
        "    float basis = ta.sma(src, length)",
        "    float dev = mult * ta.stdev(src, length)",
        "    [basis, basis + dev, basis - dev]",
        "",
        "[pineMiddle, pineUpper, pineLower] = f_bb(close, 5, 4)",
        "",
        "plot(pineMiddle)",
        "plot(pineUpper)",
        "plot(pineLower)"
      ],
      "returns": ["Bollinger Bands."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.sma](#fun_ta.sma)", "[ta.stdev](#fun_ta.stdev)", "[ta.kc](#fun_ta.kc)"],
      "syntax": ["ta.bb(series, length, mult) → [series float, series float, series float]"],
      "returnedTypes": ["[series float, series float, series float]"]
    },
    {
      "name": "ta.bbw",
      "desc": [
        "Bollinger Bands Width. The Bollinger Band Width is the difference between the upper and the lower Bollinger Bands divided by the middle band."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "mult",
          "desc": "Standard deviation factor.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.bbw\")",
        "",
        "plot(ta.bbw(close, 5, 4), color=color.yellow)",
        "",
        "// the same on pine",
        "f_bbw(src, length, mult) =>",
        "    float basis = ta.sma(src, length)",
        "    float dev = mult * ta.stdev(src, length)",
        "    (((basis + dev) - (basis - dev)) / basis) * 100",
        "",
        "plot(f_bbw(close, 5, 4))"
      ],
      "returns": ["Bollinger Bands Width."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.bb](#fun_ta.bb)", "[ta.sma](#fun_ta.sma)", "[ta.stdev](#fun_ta.stdev)"],
      "syntax": ["ta.bbw(series, length, mult) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.kc",
      "desc": [
        "Keltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "mult",
          "desc": "Standard deviation factor.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.kc\")",
        "",
        "[middle, upper, lower] = ta.kc(close, 5, 4)",
        "plot(middle, color=color.yellow)",
        "plot(upper, color=color.yellow)",
        "plot(lower, color=color.yellow)",
        "",
        "",
        "// the same on pine",
        "f_kc(src, length, mult, useTrueRange) =>",
        "    float basis = ta.ema(src, length)",
        "    float span = (useTrueRange) ? ta.tr : (high - low)",
        "    float rangeEma = ta.ema(span, length)",
        "    [basis, basis + rangeEma * mult, basis - rangeEma * mult]",
        "    ",
        "[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)",
        "",
        "plot(pineMiddle)",
        "plot(pineUpper)",
        "plot(pineLower)"
      ],
      "returns": ["Keltner Channels."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.ema](#fun_ta.ema)", "[ta.atr](#fun_ta.atr)", "[ta.bb](#fun_ta.bb)"],
      "syntax": ["ta.kc(series, length, mult) → [series float, series float, series float]"],
      "returnedTypes": ["[series float, series float, series float]"]
    },
    {
      "name": "ta.kc",
      "desc": [
        "Keltner Channels. Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "mult",
          "desc": "Standard deviation factor.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "useTrueRange",
          "desc": "An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low).",
          "required": true,
          "allowedTypeIDs": ["simple bool", "input bool", "const bool"],
          "displayType": "simple bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.kc\")",
        "",
        "[middle, upper, lower] = ta.kc(close, 5, 4)",
        "plot(middle, color=color.yellow)",
        "plot(upper, color=color.yellow)",
        "plot(lower, color=color.yellow)",
        "",
        "",
        "// the same on pine",
        "f_kc(src, length, mult, useTrueRange) =>",
        "    float basis = ta.ema(src, length)",
        "    float span = (useTrueRange) ? ta.tr : (high - low)",
        "    float rangeEma = ta.ema(span, length)",
        "    [basis, basis + rangeEma * mult, basis - rangeEma * mult]",
        "    ",
        "[pineMiddle, pineUpper, pineLower] = f_kc(close, 5, 4, true)",
        "",
        "plot(pineMiddle)",
        "plot(pineUpper)",
        "plot(pineLower)"
      ],
      "returns": ["Keltner Channels."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": ["[ta.ema](#fun_ta.ema)", "[ta.atr](#fun_ta.atr)", "[ta.bb](#fun_ta.bb)"],
      "syntax": [
        "ta.kc(series, length, mult, useTrueRange) → [series float, series float, series float]"
      ],
      "returnedTypes": ["[series float, series float, series float]"]
    },
    {
      "name": "ta.kcw",
      "desc": [
        "Keltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "mult",
          "desc": "Standard deviation factor.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.kcw\")",
        "",
        "plot(ta.kcw(close, 5, 4), color=color.yellow)",
        "",
        "// the same on pine",
        "f_kcw(src, length, mult, useTrueRange) =>",
        "    float basis = ta.ema(src, length)",
        "    float span = (useTrueRange) ? ta.tr : (high - low)",
        "    float rangeEma = ta.ema(span, length)",
        "    ",
        "    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis",
        "",
        "plot(f_kcw(close, 5, 4, true))"
      ],
      "returns": ["Keltner Channels Width."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": [
        "[ta.kc](#fun_ta.kc)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.atr](#fun_ta.atr)",
        "[ta.bb](#fun_ta.bb)"
      ],
      "syntax": ["ta.kcw(series, length, mult) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.kcw",
      "desc": [
        "Keltner Channels Width. The Keltner Channels Width is the difference between the upper and the lower Keltner Channels divided by the middle channel."
      ],
      "args": [
        {
          "name": "series",
          "desc": "Series of values to process.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars (length).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "mult",
          "desc": "Standard deviation factor.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "useTrueRange",
          "desc": "An optional parameter. Specifies if True Range is used; default is true. If the value is false, the range will be calculated with the expression (high - low).",
          "required": true,
          "allowedTypeIDs": ["simple bool", "input bool", "const bool"],
          "displayType": "simple bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"ta.kcw\")",
        "",
        "plot(ta.kcw(close, 5, 4), color=color.yellow)",
        "",
        "// the same on pine",
        "f_kcw(src, length, mult, useTrueRange) =>",
        "    float basis = ta.ema(src, length)",
        "    float span = (useTrueRange) ? ta.tr : (high - low)",
        "    float rangeEma = ta.ema(span, length)",
        "    ",
        "    ((basis + rangeEma * mult) - (basis - rangeEma * mult)) / basis",
        "",
        "plot(f_kcw(close, 5, 4, true))"
      ],
      "returns": ["Keltner Channels Width."],
      "remarks": [
        "`na` values in the `source` series are ignored; the function calculates on the `length` quantity of non-`na` values."
      ],
      "seeAlso": [
        "[ta.kc](#fun_ta.kc)",
        "[ta.ema](#fun_ta.ema)",
        "[ta.atr](#fun_ta.atr)",
        "[ta.bb](#fun_ta.bb)"
      ],
      "syntax": ["ta.kcw(series, length, mult, useTrueRange) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "float",
      "desc": ["Casts na to float"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The value of the argument after casting to float."],
      "seeAlso": [
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["float(x) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "float",
      "desc": ["Casts na to float"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The value of the argument after casting to float."],
      "seeAlso": [
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["float(x) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "float",
      "desc": ["Casts na to float"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The value of the argument after casting to float."],
      "seeAlso": [
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["float(x) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "float",
      "desc": ["Casts na to float"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The value of the argument after casting to float."],
      "seeAlso": [
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["float(x) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "int",
      "desc": ["Casts na or truncates float value to int"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["The value of the argument after casting to int."],
      "seeAlso": [
        "[float](#fun_float)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["int(x) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "int",
      "desc": ["Casts na or truncates float value to int"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["input int", "const int", "input float", "const float"],
          "displayType": "input int/float"
        }
      ],
      "returns": ["The value of the argument after casting to int."],
      "seeAlso": [
        "[float](#fun_float)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["int(x) → input int"],
      "returnedTypes": ["input int"]
    },
    {
      "name": "int",
      "desc": ["Casts na or truncates float value to int"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        }
      ],
      "returns": ["The value of the argument after casting to int."],
      "seeAlso": [
        "[float](#fun_float)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["int(x) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "int",
      "desc": ["Casts na or truncates float value to int"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["The value of the argument after casting to int."],
      "seeAlso": [
        "[float](#fun_float)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["int(x) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "bool",
      "desc": [
        "Converts the `x` value to a [bool](#type_bool) value. Returns [false](#const_false) if `x` is [na](#var_na), [false](#const_false), or an [int](#type_int)/[float](#type_float) value equal to 0. Returns [true](#const_true) for all other possible values."
      ],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float",
            "const bool"
          ],
          "displayType": "simple int/float/bool"
        }
      ],
      "returns": ["The value of the argument after casting to bool."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["bool(x) → const bool"],
      "returnedTypes": ["const bool"]
    },
    {
      "name": "bool",
      "desc": [
        "Converts the `x` value to a [bool](#type_bool) value. Returns [false](#const_false) if `x` is [na](#var_na), [false](#const_false), or an [int](#type_int)/[float](#type_float) value equal to 0. Returns [true](#const_true) for all other possible values."
      ],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        }
      ],
      "returns": ["The value of the argument after casting to bool."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["bool(x) → input bool"],
      "returnedTypes": ["input bool"]
    },
    {
      "name": "bool",
      "desc": [
        "Converts the `x` value to a [bool](#type_bool) value. Returns [false](#const_false) if `x` is [na](#var_na), [false](#const_false), or an [int](#type_int)/[float](#type_float) value equal to 0. Returns [true](#const_true) for all other possible values."
      ],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["simple bool", "input bool", "const bool"],
          "displayType": "simple bool"
        }
      ],
      "returns": ["The value of the argument after casting to bool."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["bool(x) → simple bool"],
      "returnedTypes": ["simple bool"]
    },
    {
      "name": "bool",
      "desc": [
        "Converts the `x` value to a [bool](#type_bool) value. Returns [false](#const_false) if `x` is [na](#var_na), [false](#const_false), or an [int](#type_int)/[float](#type_float) value equal to 0. Returns [true](#const_true) for all other possible values."
      ],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool"
          ],
          "displayType": "series int/float/bool"
        }
      ],
      "returns": ["The value of the argument after casting to bool."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["bool(x) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "color",
      "desc": ["Casts na to color"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["const color"],
          "displayType": "const color"
        }
      ],
      "returns": ["The value of the argument after casting to color."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["color(x) → const color"],
      "returnedTypes": ["const color"]
    },
    {
      "name": "color",
      "desc": ["Casts na to color"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["input color", "const color"],
          "displayType": "input color"
        }
      ],
      "returns": ["The value of the argument after casting to color."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["color(x) → input color"],
      "returnedTypes": ["input color"]
    },
    {
      "name": "color",
      "desc": ["Casts na to color"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["simple color", "input color", "const color"],
          "displayType": "simple color"
        }
      ],
      "returns": ["The value of the argument after casting to color."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["color(x) → simple color"],
      "returnedTypes": ["simple color"]
    },
    {
      "name": "color",
      "desc": ["Casts na to color"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "returns": ["The value of the argument after casting to color."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["color(x) → series color"],
      "returnedTypes": ["series color"]
    },
    {
      "name": "string",
      "desc": ["Casts na to string"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": ["The value of the argument after casting to string."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["string(x) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "string",
      "desc": ["Casts na to string"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        }
      ],
      "returns": ["The value of the argument after casting to string."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["string(x) → input string"],
      "returnedTypes": ["input string"]
    },
    {
      "name": "string",
      "desc": ["Casts na to string"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": ["The value of the argument after casting to string."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["string(x) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "string",
      "desc": ["Casts na to string"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["The value of the argument after casting to string."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["string(x) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "line",
      "desc": ["Casts na to line"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "returns": ["The value of the argument after casting to line."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[label](#fun_label)"
      ],
      "syntax": ["line(x) → series line"],
      "returnedTypes": ["series line"]
    },
    {
      "name": "label",
      "desc": ["Casts na to label"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "returns": ["The value of the argument after casting to label."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)"
      ],
      "syntax": ["label(x) → series label"],
      "returnedTypes": ["series label"]
    },
    {
      "name": "table",
      "desc": ["Casts na to table"],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        }
      ],
      "returns": ["The value of the argument after casting to table."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["table(x) → series table"],
      "returnedTypes": ["series table"]
    },
    {
      "name": "box",
      "desc": ["Casts na to box."],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "returns": ["The value of the argument after casting to box."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["box(x) → series box"],
      "returnedTypes": ["series box"]
    },
    {
      "name": "linefill",
      "desc": ["Casts na to linefill."],
      "args": [
        {
          "name": "x",
          "desc": "The value to convert to the specified type, usually [na](#var_na).",
          "required": true,
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        }
      ],
      "returns": ["The value of the argument after casting to linefill."],
      "seeAlso": [
        "[float](#fun_float)",
        "[int](#fun_int)",
        "[bool](#fun_bool)",
        "[color](#fun_color)",
        "[string](#fun_string)",
        "[line](#fun_line)",
        "[label](#fun_label)"
      ],
      "syntax": ["linefill(x) → series linefill"],
      "returnedTypes": ["series linefill"]
    },
    {
      "name": "str.tostring",
      "args": [
        {
          "name": "value",
          "desc": "Value or array ID whose elements are converted to a string.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series string",
            "simple string",
            "input string",
            "const string",
            "array<int>",
            "array<float>",
            "array<bool>",
            "array<string>",
            "matrix<int>",
            "matrix<float>",
            "matrix<bool>",
            "matrix<string>"
          ],
          "displayType": "series int/float/bool/string/array<int/float/bool/string>/matrix<int/float/bool/string>"
        }
      ],
      "returns": [
        "The string representation of the `value` argument.",
        "If the `value` argument is a string, it is returned as is.",
        "When the `value` is na, the function returns the string \"NaN\"."
      ],
      "remarks": [
        "The formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\".",
        "To display trailing zeros, use '0' instead of '#'. For example, '#.000'.",
        "When using [format.mintick](#const_format.mintick), the value will be rounded to the nearest number that can be divided by [syminfo.mintick](#var_syminfo.mintick) without the remainder. The string is returned with trailing zeros.",
        "If the x argument is a string, the same string value will be returned.",
        "Bool type arguments return \"true\" or \"false\".",
        "When x is na, the function returns \"NaN\"."
      ],
      "syntax": ["str.tostring(value) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.tostring",
      "args": [
        {
          "name": "value",
          "desc": "Value or array ID whose elements are converted to a string.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float",
            "simple bool",
            "input bool",
            "const bool",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "simple int/float/bool/string"
        }
      ],
      "returns": [
        "The string representation of the `value` argument.",
        "If the `value` argument is a string, it is returned as is.",
        "When the `value` is na, the function returns the string \"NaN\"."
      ],
      "remarks": [
        "The formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\".",
        "To display trailing zeros, use '0' instead of '#'. For example, '#.000'.",
        "When using [format.mintick](#const_format.mintick), the value will be rounded to the nearest number that can be divided by [syminfo.mintick](#var_syminfo.mintick) without the remainder. The string is returned with trailing zeros.",
        "If the x argument is a string, the same string value will be returned.",
        "Bool type arguments return \"true\" or \"false\".",
        "When x is na, the function returns \"NaN\"."
      ],
      "syntax": ["str.tostring(value) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.tostring",
      "args": [
        {
          "name": "value",
          "desc": "Value or array ID whose elements are converted to a string.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "array<int>",
            "array<float>",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/array<int/float>/matrix<int/float>"
        },
        {
          "name": "format",
          "desc": "Format string. Accepts these format.* constants: [format.mintick](#const_format.mintick), [format.percent](#const_format.percent), [format.volume](#const_format.volume). Optional. The default value is '#.##########'.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": [
        "The string representation of the `value` argument.",
        "If the `value` argument is a string, it is returned as is.",
        "When the `value` is na, the function returns the string \"NaN\"."
      ],
      "remarks": [
        "The formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\".",
        "To display trailing zeros, use '0' instead of '#'. For example, '#.000'.",
        "When using [format.mintick](#const_format.mintick), the value will be rounded to the nearest number that can be divided by [syminfo.mintick](#var_syminfo.mintick) without the remainder. The string is returned with trailing zeros.",
        "If the x argument is a string, the same string value will be returned.",
        "Bool type arguments return \"true\" or \"false\".",
        "When x is na, the function returns \"NaN\"."
      ],
      "syntax": ["str.tostring(value, format) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.tostring",
      "args": [
        {
          "name": "value",
          "desc": "Value or array ID whose elements are converted to a string.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "format",
          "desc": "Format string. Accepts these format.* constants: [format.mintick](#const_format.mintick), [format.percent](#const_format.percent), [format.volume](#const_format.volume). Optional. The default value is '#.##########'.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": [
        "The string representation of the `value` argument.",
        "If the `value` argument is a string, it is returned as is.",
        "When the `value` is na, the function returns the string \"NaN\"."
      ],
      "remarks": [
        "The formatting of float values will also round those values when necessary, e.g. str.tostring(3.99, '#') will return \"4\".",
        "To display trailing zeros, use '0' instead of '#'. For example, '#.000'.",
        "When using [format.mintick](#const_format.mintick), the value will be rounded to the nearest number that can be divided by [syminfo.mintick](#var_syminfo.mintick) without the remainder. The string is returned with trailing zeros.",
        "If the x argument is a string, the same string value will be returned.",
        "Bool type arguments return \"true\" or \"false\".",
        "When x is na, the function returns \"NaN\"."
      ],
      "syntax": ["str.tostring(value, format) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.tonumber",
      "desc": ["Converts a value represented in `string` to its \"float\" equivalent."],
      "args": [
        {
          "name": "string",
          "desc": "String containing the representation of an integer or floating point value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": [
        "A \"float\" equivalent of the value in `string`. If the value is not a properly formed integer or floating point value, the function returns [na](#var_na)."
      ],
      "syntax": ["str.tonumber(string) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "str.tonumber",
      "desc": ["Converts a value represented in `string` to its \"float\" equivalent."],
      "args": [
        {
          "name": "string",
          "desc": "String containing the representation of an integer or floating point value.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": [
        "A \"float\" equivalent of the value in `string`. If the value is not a properly formed integer or floating point value, the function returns [na](#var_na)."
      ],
      "syntax": ["str.tonumber(string) → const float"],
      "returnedTypes": ["const float"]
    },
    {
      "name": "str.tonumber",
      "desc": ["Converts a value represented in `string` to its \"float\" equivalent."],
      "args": [
        {
          "name": "string",
          "desc": "String containing the representation of an integer or floating point value.",
          "required": true,
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        }
      ],
      "returns": [
        "A \"float\" equivalent of the value in `string`. If the value is not a properly formed integer or floating point value, the function returns [na](#var_na)."
      ],
      "syntax": ["str.tonumber(string) → input float"],
      "returnedTypes": ["input float"]
    },
    {
      "name": "str.tonumber",
      "desc": ["Converts a value represented in `string` to its \"float\" equivalent."],
      "args": [
        {
          "name": "string",
          "desc": "String containing the representation of an integer or floating point value.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": [
        "A \"float\" equivalent of the value in `string`. If the value is not a properly formed integer or floating point value, the function returns [na](#var_na)."
      ],
      "syntax": ["str.tonumber(string) → simple float"],
      "returnedTypes": ["simple float"]
    },
    {
      "name": "str.trim",
      "desc": [
        "Constructs a new string with all consecutive whitespaces and other control characters (e.g., “\\n”, “\\t”, etc.) removed from the left and right of the `source`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to trim.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.trim\")",
        "trim = str.trim(\"    abc    \") // Returns \"abc\"",
        "label.new(bar_index,close,trim)"
      ],
      "remarks": [
        "Returns an empty string (\"\") if the result is empty after the trim or if the `source` is [na](#var_na)."
      ],
      "syntax": ["str.trim(source) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.trim",
      "desc": [
        "Constructs a new string with all consecutive whitespaces and other control characters (e.g., “\\n”, “\\t”, etc.) removed from the left and right of the `source`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to trim.",
          "required": true,
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.trim\")",
        "trim = str.trim(\"    abc    \") // Returns \"abc\"",
        "label.new(bar_index,close,trim)"
      ],
      "remarks": [
        "Returns an empty string (\"\") if the result is empty after the trim or if the `source` is [na](#var_na)."
      ],
      "syntax": ["str.trim(source) → input string"],
      "returnedTypes": ["input string"]
    },
    {
      "name": "str.trim",
      "desc": [
        "Constructs a new string with all consecutive whitespaces and other control characters (e.g., “\\n”, “\\t”, etc.) removed from the left and right of the `source`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to trim.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.trim\")",
        "trim = str.trim(\"    abc    \") // Returns \"abc\"",
        "label.new(bar_index,close,trim)"
      ],
      "remarks": [
        "Returns an empty string (\"\") if the result is empty after the trim or if the `source` is [na](#var_na)."
      ],
      "syntax": ["str.trim(source) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.trim",
      "desc": [
        "Constructs a new string with all consecutive whitespaces and other control characters (e.g., “\\n”, “\\t”, etc.) removed from the left and right of the `source`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to trim.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.trim\")",
        "trim = str.trim(\"    abc    \") // Returns \"abc\"",
        "label.new(bar_index,close,trim)"
      ],
      "remarks": [
        "Returns an empty string (\"\") if the result is empty after the trim or if the `source` is [na](#var_na)."
      ],
      "syntax": ["str.trim(source) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.repeat",
      "desc": [
        "Constructs a new string containing the `source` string repeated `repeat` times with the `separator` injected between each repeated instance."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to repeat.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "repeat",
          "desc": "Number of times to repeat the `source` string. Must be greater than or equal to 0.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "separator",
          "desc": "String to inject between repeated values. Optional. The default is empty string.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.repeat\")",
        "repeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"",
        "label.new(bar_index,close,repeat)"
      ],
      "remarks": ["Returns [na](#var_na) if the `source` is [na](#var_na)."],
      "syntax": ["str.repeat(source, repeat, separator) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.repeat",
      "desc": [
        "Constructs a new string containing the `source` string repeated `repeat` times with the `separator` injected between each repeated instance."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to repeat.",
          "required": true,
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "repeat",
          "desc": "Number of times to repeat the `source` string. Must be greater than or equal to 0.",
          "required": true,
          "allowedTypeIDs": ["input int", "const int"],
          "displayType": "input int"
        },
        {
          "name": "separator",
          "desc": "String to inject between repeated values. Optional. The default is empty string.",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.repeat\")",
        "repeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"",
        "label.new(bar_index,close,repeat)"
      ],
      "remarks": ["Returns [na](#var_na) if the `source` is [na](#var_na)."],
      "syntax": ["str.repeat(source, repeat, separator) → input string"],
      "returnedTypes": ["input string"]
    },
    {
      "name": "str.repeat",
      "desc": [
        "Constructs a new string containing the `source` string repeated `repeat` times with the `separator` injected between each repeated instance."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to repeat.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "repeat",
          "desc": "Number of times to repeat the `source` string. Must be greater than or equal to 0.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "separator",
          "desc": "String to inject between repeated values. Optional. The default is empty string.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.repeat\")",
        "repeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"",
        "label.new(bar_index,close,repeat)"
      ],
      "remarks": ["Returns [na](#var_na) if the `source` is [na](#var_na)."],
      "syntax": ["str.repeat(source, repeat, separator) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.repeat",
      "desc": [
        "Constructs a new string containing the `source` string repeated `repeat` times with the `separator` injected between each repeated instance."
      ],
      "args": [
        {
          "name": "source",
          "desc": "String to repeat.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "repeat",
          "desc": "Number of times to repeat the `source` string. Must be greater than or equal to 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "separator",
          "desc": "String to inject between repeated values. Optional. The default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.repeat\")",
        "repeat = str.repeat(\"?\", 3, \",\") // Returns \"?,?,?\"",
        "label.new(bar_index,close,repeat)"
      ],
      "remarks": ["Returns [na](#var_na) if the `source` is [na](#var_na)."],
      "syntax": ["str.repeat(source, repeat, separator) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.replace_all",
      "desc": [
        "Replaces each occurrence of the target string in the source string with the replacement string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "target",
          "desc": "String to be replaced.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "replacement",
          "desc": "String to be substituted for each occurrence of target string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": ["Processed string."],
      "syntax": ["str.replace_all(source, target, replacement) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.replace_all",
      "desc": [
        "Replaces each occurrence of the target string in the source string with the replacement string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "target",
          "desc": "String to be replaced.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "replacement",
          "desc": "String to be substituted for each occurrence of target string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Processed string."],
      "syntax": ["str.replace_all(source, target, replacement) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.contains",
      "desc": [
        "Returns true if the `source` string contains the `str` substring, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.contains\")",
        "// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.",
        "var isFutures = str.contains(syminfo.tickerid, \"!\")",
        "plot(isFutures ? 1 : 0)"
      ],
      "returns": ["True if the `str` was found in the `source` string, false otherwise."],
      "seeAlso": ["[str.pos](#fun_str.pos)", "[str.match](#fun_str.match)"],
      "syntax": ["str.contains(source, str) → const bool"],
      "returnedTypes": ["const bool"]
    },
    {
      "name": "str.contains",
      "desc": [
        "Returns true if the `source` string contains the `str` substring, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.contains\")",
        "// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.",
        "var isFutures = str.contains(syminfo.tickerid, \"!\")",
        "plot(isFutures ? 1 : 0)"
      ],
      "returns": ["True if the `str` was found in the `source` string, false otherwise."],
      "seeAlso": ["[str.pos](#fun_str.pos)", "[str.match](#fun_str.match)"],
      "syntax": ["str.contains(source, str) → simple bool"],
      "returnedTypes": ["simple bool"]
    },
    {
      "name": "str.contains",
      "desc": [
        "Returns true if the `source` string contains the `str` substring, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.contains\")",
        "// If the current chart is a continuous futures chart, e.g “BTC1!”, then the function will return true, false otherwise.",
        "var isFutures = str.contains(syminfo.tickerid, \"!\")",
        "plot(isFutures ? 1 : 0)"
      ],
      "returns": ["True if the `str` was found in the `source` string, false otherwise."],
      "seeAlso": ["[str.pos](#fun_str.pos)", "[str.match](#fun_str.match)"],
      "syntax": ["str.contains(source, str) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "str.substring",
      "desc": [
        "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string from which to extract the substring.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "begin_pos",
          "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.substring\", overlay = true)",
        "sym= input.symbol(\"NASDAQ:AAPL\")",
        "pos = str.pos(sym, \":\") // Get position of \":\" character",
        "tkr= str.substring(sym, pos+1) // \"AAPL\"",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tkr)"
      ],
      "returns": ["The substring extracted from the source string."],
      "remarks": [
        "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string."
      ],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.pos](#fun_str.pos)",
        "[str.match](#fun_str.match)"
      ],
      "syntax": ["str.substring(source, begin_pos) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.substring",
      "desc": [
        "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string from which to extract the substring.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "begin_pos",
          "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.substring\", overlay = true)",
        "sym= input.symbol(\"NASDAQ:AAPL\")",
        "pos = str.pos(sym, \":\") // Get position of \":\" character",
        "tkr= str.substring(sym, pos+1) // \"AAPL\"",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tkr)"
      ],
      "returns": ["The substring extracted from the source string."],
      "remarks": [
        "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string."
      ],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.pos](#fun_str.pos)",
        "[str.match](#fun_str.match)"
      ],
      "syntax": ["str.substring(source, begin_pos) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.substring",
      "desc": [
        "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string from which to extract the substring.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "begin_pos",
          "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.substring\", overlay = true)",
        "sym= input.symbol(\"NASDAQ:AAPL\")",
        "pos = str.pos(sym, \":\") // Get position of \":\" character",
        "tkr= str.substring(sym, pos+1) // \"AAPL\"",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tkr)"
      ],
      "returns": ["The substring extracted from the source string."],
      "remarks": [
        "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string."
      ],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.pos](#fun_str.pos)",
        "[str.match](#fun_str.match)"
      ],
      "syntax": ["str.substring(source, begin_pos) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.substring",
      "desc": [
        "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string from which to extract the substring.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "begin_pos",
          "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "end_pos",
          "desc": "The ending position. It is exclusive (the extracted string does NOT include that position's character). Optional. The default is the length of the `source` string.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.substring\", overlay = true)",
        "sym= input.symbol(\"NASDAQ:AAPL\")",
        "pos = str.pos(sym, \":\") // Get position of \":\" character",
        "tkr= str.substring(sym, pos+1) // \"AAPL\"",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tkr)"
      ],
      "returns": ["The substring extracted from the source string."],
      "remarks": [
        "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string."
      ],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.pos](#fun_str.pos)",
        "[str.match](#fun_str.match)"
      ],
      "syntax": ["str.substring(source, begin_pos, end_pos) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.substring",
      "desc": [
        "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string from which to extract the substring.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "begin_pos",
          "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "end_pos",
          "desc": "The ending position. It is exclusive (the extracted string does NOT include that position's character). Optional. The default is the length of the `source` string.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.substring\", overlay = true)",
        "sym= input.symbol(\"NASDAQ:AAPL\")",
        "pos = str.pos(sym, \":\") // Get position of \":\" character",
        "tkr= str.substring(sym, pos+1) // \"AAPL\"",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tkr)"
      ],
      "returns": ["The substring extracted from the source string."],
      "remarks": [
        "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string."
      ],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.pos](#fun_str.pos)",
        "[str.match](#fun_str.match)"
      ],
      "syntax": ["str.substring(source, begin_pos, end_pos) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.substring",
      "desc": [
        "Returns a new string that is a substring of the `source` string. The substring begins with the character at the index specified by `begin_pos` and extends to 'end_pos - 1' of the `source` string."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string from which to extract the substring.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "begin_pos",
          "desc": "The beginning position of the extracted substring. It is inclusive (the extracted substring includes the character at that position).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_pos",
          "desc": "The ending position. It is exclusive (the extracted string does NOT include that position's character). Optional. The default is the length of the `source` string.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.substring\", overlay = true)",
        "sym= input.symbol(\"NASDAQ:AAPL\")",
        "pos = str.pos(sym, \":\") // Get position of \":\" character",
        "tkr= str.substring(sym, pos+1) // \"AAPL\"",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tkr)"
      ],
      "returns": ["The substring extracted from the source string."],
      "remarks": [
        "Strings indexing starts from 0. If `begin_pos` is equal to `end_pos`, the function returns an empty string."
      ],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.pos](#fun_str.pos)",
        "[str.match](#fun_str.match)"
      ],
      "syntax": ["str.substring(source, begin_pos, end_pos) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.replace",
      "desc": [
        "Returns a new string with the Nth occurrence of the `target` string replaced by the `replacement` string, where N is specified in `occurrence`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "target",
          "desc": "String to be replaced.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "replacement",
          "desc": "String to be inserted instead of the target string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "occurrence",
          "desc": "N-th occurrence of the target string to replace. Indexing starts at 0 for the first match. Optional. Default value is 0.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.replace\")",
        "var source = \"FTX:BTCUSD / FTX:BTCEUR\"",
        "",
        "// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string",
        "var newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)",
        "",
        "if barstate.islastconfirmedhistory",
        "\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"",
        "\tlabel.new(bar_index, high, text = newSource)"
      ],
      "returns": ["Processed string."],
      "seeAlso": ["[str.replace_all](#fun_str.replace_all)", "[str.match](#fun_str.match)"],
      "syntax": ["str.replace(source, target, replacement, occurrence) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.replace",
      "desc": [
        "Returns a new string with the Nth occurrence of the `target` string replaced by the `replacement` string, where N is specified in `occurrence`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "target",
          "desc": "String to be replaced.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "replacement",
          "desc": "String to be inserted instead of the target string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "occurrence",
          "desc": "N-th occurrence of the target string to replace. Indexing starts at 0 for the first match. Optional. Default value is 0.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.replace\")",
        "var source = \"FTX:BTCUSD / FTX:BTCEUR\"",
        "",
        "// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string",
        "var newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)",
        "",
        "if barstate.islastconfirmedhistory",
        "\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"",
        "\tlabel.new(bar_index, high, text = newSource)"
      ],
      "returns": ["Processed string."],
      "seeAlso": ["[str.replace_all](#fun_str.replace_all)", "[str.match](#fun_str.match)"],
      "syntax": ["str.replace(source, target, replacement, occurrence) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.replace",
      "desc": [
        "Returns a new string with the Nth occurrence of the `target` string replaced by the `replacement` string, where N is specified in `occurrence`."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "target",
          "desc": "String to be replaced.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "replacement",
          "desc": "String to be inserted instead of the target string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "occurrence",
          "desc": "N-th occurrence of the target string to replace. Indexing starts at 0 for the first match. Optional. Default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.replace\")",
        "var source = \"FTX:BTCUSD / FTX:BTCEUR\"",
        "",
        "// Replace first occurrence of \"FTX\" with \"BINANCE\" replacement string",
        "var newSource = str.replace(source, \"FTX\", \"BINANCE\", 0)",
        "",
        "if barstate.islastconfirmedhistory",
        "\t// Display \"BINANCE:BTCUSD / FTX:BTCEUR\"",
        "\tlabel.new(bar_index, high, text = newSource)"
      ],
      "returns": ["Processed string."],
      "seeAlso": ["[str.replace_all](#fun_str.replace_all)", "[str.match](#fun_str.match)"],
      "syntax": ["str.replace(source, target, replacement, occurrence) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.lower",
      "desc": ["Returns a new string with all letters converted to lowercase."],
      "args": [
        {
          "name": "source",
          "desc": "String to be converted.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": ["A new string with all letters converted to lowercase."],
      "seeAlso": ["[str.upper](#fun_str.upper)"],
      "syntax": ["str.lower(source) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.lower",
      "desc": ["Returns a new string with all letters converted to lowercase."],
      "args": [
        {
          "name": "source",
          "desc": "String to be converted.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": ["A new string with all letters converted to lowercase."],
      "seeAlso": ["[str.upper](#fun_str.upper)"],
      "syntax": ["str.lower(source) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.lower",
      "desc": ["Returns a new string with all letters converted to lowercase."],
      "args": [
        {
          "name": "source",
          "desc": "String to be converted.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["A new string with all letters converted to lowercase."],
      "seeAlso": ["[str.upper](#fun_str.upper)"],
      "syntax": ["str.lower(source) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.upper",
      "desc": ["Returns a new string with all letters converted to uppercase."],
      "args": [
        {
          "name": "source",
          "desc": "String to be converted.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": ["A new string with all letters converted to uppercase."],
      "seeAlso": ["[str.lower](#fun_str.lower)"],
      "syntax": ["str.upper(source) → const string"],
      "returnedTypes": ["const string"]
    },
    {
      "name": "str.upper",
      "desc": ["Returns a new string with all letters converted to uppercase."],
      "args": [
        {
          "name": "source",
          "desc": "String to be converted.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": ["A new string with all letters converted to uppercase."],
      "seeAlso": ["[str.lower](#fun_str.lower)"],
      "syntax": ["str.upper(source) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.upper",
      "desc": ["Returns a new string with all letters converted to uppercase."],
      "args": [
        {
          "name": "source",
          "desc": "String to be converted.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["A new string with all letters converted to uppercase."],
      "seeAlso": ["[str.lower](#fun_str.lower)"],
      "syntax": ["str.upper(source) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.startswith",
      "desc": [
        "Returns true if the `source` string starts with the substring specified in `str`, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": [
        "True if the `source` string starts with the substring specified in `str`, false otherwise."
      ],
      "seeAlso": ["[str.endswith](#fun_str.endswith)"],
      "syntax": ["str.startswith(source, str) → const bool"],
      "returnedTypes": ["const bool"]
    },
    {
      "name": "str.startswith",
      "desc": [
        "Returns true if the `source` string starts with the substring specified in `str`, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": [
        "True if the `source` string starts with the substring specified in `str`, false otherwise."
      ],
      "seeAlso": ["[str.endswith](#fun_str.endswith)"],
      "syntax": ["str.startswith(source, str) → simple bool"],
      "returnedTypes": ["simple bool"]
    },
    {
      "name": "str.startswith",
      "desc": [
        "Returns true if the `source` string starts with the substring specified in `str`, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": [
        "True if the `source` string starts with the substring specified in `str`, false otherwise."
      ],
      "seeAlso": ["[str.endswith](#fun_str.endswith)"],
      "syntax": ["str.startswith(source, str) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "str.endswith",
      "desc": [
        "Returns true if the `source` string ends with the substring specified in `str`, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": [
        "True if the `source` string ends with the substring specified in `str`, false otherwise."
      ],
      "seeAlso": ["[str.startswith](#fun_str.startswith)"],
      "syntax": ["str.endswith(source, str) → const bool"],
      "returnedTypes": ["const bool"]
    },
    {
      "name": "str.endswith",
      "desc": [
        "Returns true if the `source` string ends with the substring specified in `str`, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": [
        "True if the `source` string ends with the substring specified in `str`, false otherwise."
      ],
      "seeAlso": ["[str.startswith](#fun_str.startswith)"],
      "syntax": ["str.endswith(source, str) → simple bool"],
      "returnedTypes": ["simple bool"]
    },
    {
      "name": "str.endswith",
      "desc": [
        "Returns true if the `source` string ends with the substring specified in `str`, false otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": [
        "True if the `source` string ends with the substring specified in `str`, false otherwise."
      ],
      "seeAlso": ["[str.startswith](#fun_str.startswith)"],
      "syntax": ["str.endswith(source, str) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "str.match",
      "desc": [
        "Returns the new substring of the `source` string if it matches a `regex` regular expression, an empty string otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "regex",
          "desc": "The regular expression to which this string is to be matched.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.match\")",
        "",
        "s = input.string(\"It's time to sell some NASDAQ:AAPL!\")",
        "",
        "// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"",
        "var string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")",
        "",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\""
      ],
      "returns": [
        "The new substring of the `source` string if it matches a `regex` regular expression, an empty string otherwise."
      ],
      "remarks": [
        "Function returns first occurrence of the [regular expression](https://en.wikipedia.org/wiki/Regular_expression#Perl_and_PCRE) in the `source` string.",
        "The backslash \"&#92;\" symbol in the`regex` string needs to be escaped with additional backslash, e.g. \"&#92;&#92;d\" stands for regular expression \"&#92;d\"."
      ],
      "seeAlso": ["[str.contains](#fun_str.contains)", "[str.substring](#fun_str.substring)"],
      "syntax": ["str.match(source, regex) → simple string"],
      "returnedTypes": ["simple string"]
    },
    {
      "name": "str.match",
      "desc": [
        "Returns the new substring of the `source` string if it matches a `regex` regular expression, an empty string otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "regex",
          "desc": "The regular expression to which this string is to be matched.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"str.match\")",
        "",
        "s = input.string(\"It's time to sell some NASDAQ:AAPL!\")",
        "",
        "// finding first substring that matches regular expression \"[\\w]+:[\\w]+\"",
        "var string tickerid = str.match(s, \"[\\\\w]+:[\\\\w]+\")",
        "",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, text = tickerid) // \"NASDAQ:AAPL\""
      ],
      "returns": [
        "The new substring of the `source` string if it matches a `regex` regular expression, an empty string otherwise."
      ],
      "remarks": [
        "Function returns first occurrence of the [regular expression](https://en.wikipedia.org/wiki/Regular_expression#Perl_and_PCRE) in the `source` string.",
        "The backslash \"&#92;\" symbol in the`regex` string needs to be escaped with additional backslash, e.g. \"&#92;&#92;d\" stands for regular expression \"&#92;d\"."
      ],
      "seeAlso": ["[str.contains](#fun_str.contains)", "[str.substring](#fun_str.substring)"],
      "syntax": ["str.match(source, regex) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "str.pos",
      "desc": [
        "Returns the position of the first occurrence of the `str` string in the `source` string, 'na' otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": ["Position of the `str` string in the `source` string."],
      "remarks": ["Strings indexing starts at 0."],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.match](#fun_str.match)",
        "[str.substring](#fun_str.substring)"
      ],
      "syntax": ["str.pos(source, str) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "str.pos",
      "desc": [
        "Returns the position of the first occurrence of the `str` string in the `source` string, 'na' otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": ["Position of the `str` string in the `source` string."],
      "remarks": ["Strings indexing starts at 0."],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.match](#fun_str.match)",
        "[str.substring](#fun_str.substring)"
      ],
      "syntax": ["str.pos(source, str) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "str.pos",
      "desc": [
        "Returns the position of the first occurrence of the `str` string in the `source` string, 'na' otherwise."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "str",
          "desc": "The substring to search for.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["Position of the `str` string in the `source` string."],
      "remarks": ["Strings indexing starts at 0."],
      "seeAlso": [
        "[str.contains](#fun_str.contains)",
        "[str.match](#fun_str.match)",
        "[str.substring](#fun_str.substring)"
      ],
      "syntax": ["str.pos(source, str) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "str.split",
      "desc": ["Divides a string into an array of substrings and returns its array id."],
      "args": [
        {
          "name": "string",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "separator",
          "desc": "The string separating each substring.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["The id of an array of strings."],
      "syntax": ["str.split(string, separator) → array<string>"],
      "returnedTypes": ["array<string>"]
    },
    {
      "name": "str.length",
      "desc": ["Returns an integer corresponding to the amount of chars in that string."],
      "args": [
        {
          "name": "string",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        }
      ],
      "returns": ["The number of chars in source string."],
      "syntax": ["str.length(string) → const int"],
      "returnedTypes": ["const int"]
    },
    {
      "name": "str.length",
      "desc": ["Returns an integer corresponding to the amount of chars in that string."],
      "args": [
        {
          "name": "string",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "returns": ["The number of chars in source string."],
      "syntax": ["str.length(string) → simple int"],
      "returnedTypes": ["simple int"]
    },
    {
      "name": "str.length",
      "desc": ["Returns an integer corresponding to the amount of chars in that string."],
      "args": [
        {
          "name": "string",
          "desc": "Source string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "returns": ["The number of chars in source string."],
      "syntax": ["str.length(string) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "ta.percentile_nearest_rank",
      "desc": ["Calculates percentile using method of Nearest Rank."],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process (source).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars back (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "percentage",
          "desc": "Percentage, a number from range 0..100.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["P-th percentile of `source` series for `length` bars back."],
      "remarks": [
        "Using the Nearest Rank method on lengths less than 100 bars back can result in the same number being used for more than one percentile.",
        "A percentile calculated using the Nearest Rank method will always be a member of the input data set.",
        "The 100th percentile is defined to be the largest value in the input data set.",
        "`na` values in the `source` series are ignored."
      ],
      "seeAlso": [
        "[ta.percentile_linear_interpolation](#fun_ta.percentile_linear_interpolation)",
        "http://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method"
      ],
      "syntax": ["ta.percentile_nearest_rank(source, length, percentage) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.percentile_linear_interpolation",
      "desc": [
        "Calculates percentile using method of linear interpolation between the two nearest ranks."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Series of values to process (source).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "length",
          "desc": "Number of bars back (length).",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "percentage",
          "desc": "Percentage, a number from range 0..100.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "returns": ["P-th percentile of `source` series for `length` bars back."],
      "remarks": [
        "Note that a percentile calculated using this method will NOT always be a member of the input data set.",
        "`na` values in the `source` series are included in calculations and will produce an `na` result."
      ],
      "seeAlso": ["[ta.percentile_nearest_rank](#fun_ta.percentile_nearest_rank)"],
      "syntax": ["ta.percentile_linear_interpolation(source, length, percentage) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.crossover",
      "desc": [
        "The `source1`-series is defined as having crossed over `source2`-series if, on the current bar, the value of `source1` is greater than the value of `source2`, and on the previous bar, the value of `source1` was less than or equal to the value of `source2`."
      ],
      "args": [
        {
          "name": "source1",
          "desc": "First data series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "source2",
          "desc": "Second data series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["true if `source1` crossed over `source2` otherwise false."],
      "syntax": ["ta.crossover(source1, source2) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "ta.crossunder",
      "desc": [
        "The `source1`-series is defined as having crossed under `source2`-series if, on the current bar, the value of `source1` is less than the value of `source2`, and on the previous bar, the value of `source1` was greater than or equal to the value of `source2`."
      ],
      "args": [
        {
          "name": "source1",
          "desc": "First data series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "source2",
          "desc": "Second data series.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "returns": ["true if `source1` crossed under `source2` otherwise false."],
      "syntax": ["ta.crossunder(source1, source2) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "strategy",
      "desc": [
        "This declaration statement designates the script as a strategy and sets a number of strategy-related properties."
      ],
      "args": [
        {
          "name": "title",
          "desc": "The title of the script. It is displayed on the chart when no `shorttitle` argument is used, and becomes the publication's default title when publishing the script.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "shorttitle",
          "desc": "The script's display name on charts. If specified, it will replace the `title` argument in most chart-related windows. Optional. The default is the argument used for `title`.",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "overlay",
          "desc": "If [true](#const_true), the strategy will be displayed over the chart. If [false](#const_false), it will be added in a separate pane. Strategy-specific labels that display entries and exits will be displayed over the main chart regardless of this setting. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "format",
          "desc": "Specifies the formatting of the script's displayed values. Possible values: [format.inherit](#const_format.inherit), [format.price](#const_format.price), [format.volume](#const_format.volume), [format.percent](#const_format.percent). Optional. The default is [format.inherit](#const_format.inherit).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "precision",
          "desc": "Specifies the number of digits after the floating point of the script's displayed values. Must be a non-negative integer no greater than 16. If `format` is set to [format.inherit](#const_format.inherit) and `precision` is specified, the format will instead be set to [format.price](#const_format.price). When the function's `format` parameter uses [format.volume](#const_format.volume), the `precision` parameter will not affect the result, as the decimal precision rules defined by [format.volume](#const_format.volume) supersede other precision settings. Optional. The default is inherited from the precision of the chart's symbol.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "scale",
          "desc": "The price scale used. Possible values: [scale.right](#const_scale.right), [scale.left](#const_scale.left), [scale.none](#const_scale.none). The [scale.none](#const_scale.none) value can only be applied in combination with `overlay = true`. Optional. By default, the script uses the same scale as the chart.",
          "allowedTypeIDs": ["const scale_type"],
          "displayType": "const scale_type"
        },
        {
          "name": "pyramiding",
          "desc": "The maximum number of entries allowed in the same direction. If the value is 0, only one entry order in the same direction can be opened, and additional entry orders are rejected. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is 0.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "calc_on_order_fills",
          "desc": "Specifies whether the strategy should be recalculated after an order is filled. If [true](#const_true), the strategy recalculates after an order is filled, as opposed to recalculating only when the bar closes. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "calc_on_every_tick",
          "desc": "Specifies whether the strategy should be recalculated on each realtime tick. If [true](#const_true), when the strategy is running on a realtime bar, it will recalculate on each chart update. If [false](#const_false), the strategy only calculates when the realtime bar closes. The argument used does not affect strategy calculation on historical data. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "max_bars_back",
          "desc": "The length of the historical buffer the script keeps for every variable and function, which determines how many past values can be referenced using the `[]` history-referencing operator. The required buffer size is automatically detected by the Pine Script® runtime. Using this parameter is only necessary when a runtime error occurs because automatic detection fails. More information on the underlying mechanics of the historical buffer can be found [in our Help Center](https://www.tradingview.com/chart/?solution=43000587849). Optional. The default is 0.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "backtest_fill_limits_assumption",
          "desc": "Limit order execution threshold in ticks. When it is used, limit orders are only filled if the market price exceeds the order's limit level by the specified number of ticks. Optional. The default is 0.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "default_qty_type",
          "desc": "Specifies the units used for `default_qty_value`. Possible values are: [strategy.fixed](#const_strategy.fixed) for contracts/shares/lots, [strategy.cash](#const_strategy.cash) for currency amounts, or [strategy.percent_of_equity](#const_strategy.percent_of_equity) for a percentage of available equity. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is [strategy.fixed](#const_strategy.fixed).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "default_qty_value",
          "desc": "The default quantity to trade, in units determined by the argument used with the `default_qty_type` parameter. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is 1.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "initial_capital",
          "desc": "The amount of funds initially available for the strategy to trade, in units of `currency`. Optional. The default is 1000000.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "currency",
          "desc": "Currency used by the strategy in currency-related calculations. Market positions are still opened by converting `currency` into the chart symbol's currency. The conversion rate depends on the previous daily value of a corresponding currency pair from the most popular exchange. A spread symbol is used if no exchange provides the rate directly. Possible values: a \"string\" representing a valid currency code (e.g., \"USD\" or \"USDT\") or a constant from the `currency.*` namespace (e.g., [currency.USD](#const_currency.USD) or [currency.USDT](#const_currency.USDT)). The default is [syminfo.currency](#var_syminfo.currency).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "slippage",
          "desc": "Slippage expressed in ticks. This value is added to or subtracted from the fill price of market/stop orders to make the fill price less favorable for the strategy. E.g., if [syminfo.mintick](#var_syminfo.mintick) is 0.01 and `slippage` is set to 5, a long market order will enter at 5 * 0.01 = 0.05 points above the actual price. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is 0.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "commission_type",
          "desc": "Determines what the number passed to the `commission_value` expresses: [strategy.commission.percent](#const_strategy.commission.percent) for a percentage of the cash volume of the order, [strategy.commission.cash_per_contract](#const_strategy.commission.cash_per_contract) for currency per contract, [strategy.commission.cash_per_order](#const_strategy.commission.cash_per_order) for currency per order. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is [strategy.commission.percent](#const_strategy.commission.percent).",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "commission_value",
          "desc": "Commission applied to the strategy's orders in units determined by the argument passed to the `commission_type` parameter. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is 0.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "process_orders_on_close",
          "desc": "When set to [true](#const_true), generates an additional attempt to execute orders after a bar closes and strategy calculations are completed. If the orders are market orders, the broker emulator executes them before the next bar's open. If the orders are price-dependent, they will only be filled if the price conditions are met. This option is useful if you wish to close positions on the current bar. This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "close_entries_rule",
          "desc": "Determines the order in which trades are closed. Possible values are: \"FIFO\" (First-In, First-Out) if the earliest exit order must close the earliest entry order, or \"ANY\" if the orders are closed based on the `from_entry` parameter of the [strategy.exit](#fun_strategy.exit) function. \"FIFO\" can only be used with stocks, futures and US forex (NFA Compliance Rule 2-43b), while \"ANY\" is allowed in non-US forex. Optional. The default is \"FIFO\".",
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "margin_long",
          "desc": "Margin long is the percentage of the purchase price of a security that must be covered by cash or collateral for long positions. Must be a non-negative number. The logic used to simulate margin calls is explained in the [Help Center](https://www.tradingview.com/chart/?solution=43000628599). This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. If the value is 0, the strategy does not enforce any limits on position size. The default is 100, in which case the strategy only uses its own funds and the long positions cannot be margin called.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "margin_short",
          "desc": "Margin short is the percentage of the purchase price of a security that must be covered by cash or collateral for short positions. Must be a non-negative number. The logic used to simulate margin calls is explained in the [Help Center](https://www.tradingview.com/chart/?solution=43000628599). This setting can also be changed in the strategy's \"Settings/Properties\" tab. Optional. If the value is 0, the strategy does not enforce any limits on position size. The default is 100, in which case the strategy only uses its own funds. Note that even with no margin used, short positions *can* be margin called if the loss exceeds available funds.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "explicit_plot_zorder",
          "desc": "Specifies the order in which the script's plots, fills, and hlines are rendered. If [true](#const_true), plots are drawn in the order in which they appear in the script's code, each newer plot being drawn above the previous ones. This only applies to `plot*()` functions, [fill](#fun_fill), and [hline](#fun_hline). Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "max_lines_count",
          "desc": "The number of last [line](#type_line) drawings displayed. Possible values: 1-500. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "max_labels_count",
          "desc": "The number of last [label](#type_label) drawings displayed. Possible values: 1-500. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "max_boxes_count",
          "desc": "The number of last [box](#type_box) drawings displayed. Possible values: 1-500. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "calc_bars_count",
          "desc": "Limits the initial calculation of a script to the last number of bars specified. When specified, a \"Calculated bars\" field will be included in the \"Calculation\" section of the script's \"Settings/Inputs\" tab. Optional. The default is 0, in which case the script executes on all available bars.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "risk_free_rate",
          "desc": "The risk-free rate of return is the annual percentage change in the value of an investment with minimal or zero risk. It is used to calculate the [Sharpe](https://www.tradingview.com/support/solutions/43000681694) and [Sortino](https://www.tradingview.com/support/solutions/43000681697) ratios. Optional. The default is 2.",
          "allowedTypeIDs": ["const int", "const float"],
          "displayType": "const int/float"
        },
        {
          "name": "use_bar_magnifier",
          "desc": "Optional. When [true](#const_true), the [Broker Emulator](https://www.tradingview.com/pine-script-docs/concepts/strategies/#broker-emulator) uses lower timeframe data during backtesting on historical bars to achieve more realistic results. The default is [false](#const_false). Only [Premium](https://www.tradingview.com/gopro/) and higher-tier plans have access to this feature.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "fill_orders_on_standard_ohlc",
          "desc": "When [true](#const_true), forces strategies running on Heikin Ashi charts to fill orders using actual OHLC prices, for more realistic results. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "max_polylines_count",
          "desc": "The number of last [polyline](#type_polyline) drawings displayed. Possible values: 1-100. The count is approximate; more drawings than the specified count may be displayed. Optional. The default is 50.",
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        },
        {
          "name": "dynamic_requests",
          "desc": "Specifies whether the script can dynamically call functions from the `request.*()` namespace. Dynamic `request.*()` calls are allowed within the local scopes of conditional structures (e.g., [if](#kw_if)), loops (e.g., [for](#kw_for)), and exported functions. Additionally, such calls allow \"series\" arguments for many of their parameters. Optional. The default is [true](#const_true). See the User Manual's [Dynamic requests](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#dynamic-requests) section for more information.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "behind_chart",
          "desc": "Controls whether the script's plots and drawings in the main chart pane appear behind the chart display (if [true](#const_true)), or in front of it (if [false](#const_false)). Optional. The default is [true](#const_true).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true)",
        "",
        "// Enter long by market if current open is greater than previous high.",
        "if open > high[1]",
        "\tstrategy.entry(\"Long\", strategy.long, 1)",
        "// Generate a full exit bracket (profit 10 points, loss 5 points per contract) from the entry named \"Long\".",
        "strategy.exit(\"Exit\", \"Long\", profit = 10, loss = 5)"
      ],
      "remarks": [
        "You can learn more about strategies in our [User Manual](https://www.tradingview.com/pine-script-docs/concepts/strategies/).",
        "Every strategy script must have one [strategy](#fun_strategy) call.",
        "Strategies using `calc_on_every_tick = true` parameter may calculate differently on historical and realtime bars, which causes [repainting](https://www.tradingview.com/pine-script-docs/concepts/repainting/).",
        "Strategies always use the chart's prices to enter and exit positions. Using them on non-standard chart types (Heikin Ashi, Renko, etc.) will produce misleading results, as their prices are synthetic. Backtesting on non-standard charts is thus not recommended.",
        "The maximum number of orders a strategy can open, unless it uses Deep Backtesting mode, is 9000. If the strategy exceeds this limit, it removes the oldest order's information when a new entry appears in the \"List of Trades\" tab. The `strategy.closedtrades.*()` functions return [na](#var_na) for trades opened or closed by removed orders. To retrieve the index of the oldest available closed trade, use the [strategy.closedtrades.first_index](#var_strategy.closedtrades.first_index) variable."
      ],
      "seeAlso": ["[indicator](#fun_indicator)", "[library](#fun_library)"],
      "syntax": [
        "strategy(title, shorttitle, overlay, format, precision, scale, pyramiding, calc_on_order_fills, calc_on_every_tick, max_bars_back, backtest_fill_limits_assumption, default_qty_type, default_qty_value, initial_capital, currency, slippage, commission_type, commission_value, process_orders_on_close, close_entries_rule, margin_long, margin_short, explicit_plot_zorder, max_lines_count, max_labels_count, max_boxes_count, calc_bars_count, risk_free_rate, use_bar_magnifier, fill_orders_on_standard_ohlc, max_polylines_count, dynamic_requests, behind_chart) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.entry",
      "desc": [
        "Creates a new order to open or add to a position. If an unfilled order with the same `id` exists, a call to this command modifies that order.",
        "The resulting order's type depends on the `limit` and `stop` parameters. If the call does not contain `limit` or `stop` arguments, it creates a [market order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders) that executes on the next tick. If the call specifies a `limit` value but no `stop` value, it places a [limit order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#limit-orders) that executes after the market price reaches the `limit` value or a better price (lower for buy orders and higher for sell orders). If the call specifies a `stop` value but no `limit` value, it places a [stop order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#stop-and-stop-limit-orders) that executes after the market price reaches the `stop` value or a worse price (higher for buy orders and lower for sell orders). If the call contains `limit` and `stop` arguments, it creates a [stop-limit](https://www.tradingview.com/pine-script-docs/concepts/strategies/#stop-and-stop-limit-orders) order, which generates a limit order at the `limit` price only after the market price reaches the `stop` value or a worse price.",
        "Orders from this command, unlike those from [strategy.order](#fun_strategy.order), are affected by the `pyramiding` parameter of the [strategy](#fun_strategy) declaration statement. Pyramiding specifies the number of concurrent open entries allowed per position. For example, with `pyramiding = 3`, the strategy can have up to three open trades, and the command cannot create orders to open additional trades until at least one existing trade closes.",
        "By default, when a strategy executes an order from this command in the opposite direction of the current market position, it reverses that position. For example, if there is an open long position of five shares, an order from this command with a `qty` of 5 and a `direction` of [strategy.short](#const_strategy.short) triggers the sale of 10 shares to close the long position and open a new five-share short position. Users can change this behavior by specifying an allowed direction with the [strategy.risk_allow_entry_in](#fun_strategy.risk_allow_entry_in) function."
      ],
      "args": [
        {
          "name": "id",
          "desc": "The identifier of the order, which corresponds to an entry ID in the strategy's trades after the order fills. If the strategy opens a new position after filling the order, the order's ID becomes the [strategy.position_entry_name](#var_strategy.position_entry_name) value. Strategy commands can reference the order ID to cancel or modify pending orders and generate exit orders for specific open trades. The Strategy Tester and the chart display the order ID unless the command specifies a `comment` value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "direction",
          "desc": "The direction of the trade. Possible values: [strategy.long](#const_strategy.long) for a long trade, [strategy.short](#const_strategy.short) for a short one.",
          "required": true,
          "allowedTypeIDs": [
            "series strategy_direction",
            "simple strategy_direction",
            "input strategy_direction",
            "const strategy_direction"
          ],
          "displayType": "series strategy_direction"
        },
        {
          "name": "qty",
          "desc": "Optional. The number of contracts/shares/lots/units in the resulting open trade when the order fills. The default is [na](#var_na), which means that the command uses the `default_qty_type` and `default_qty_value` parameters of the [strategy](#fun_strategy) declaration statement to determine the quantity.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "limit",
          "desc": "Optional. The limit price of the order. If specified, the command creates a limit or stop-limit order, depending on whether the `stop` value is also specified. The default is [na](#var_na), which means the resulting order is not of the limit or stop-limit type.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "stop",
          "desc": "Optional. The stop price of the order. If specified, the command creates a stop or stop-limit order, depending on whether the `limit` value is also specified. The default is [na](#var_na), which means the resulting order is not of the stop or stop-limit type.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "oca_name",
          "desc": "Optional. The name of the order's One-Cancels-All (OCA) group. When a pending order with the same `oca_name` and `oca_type` parameters executes, that order affects all unfilled orders in the group. The default is an empty string, which means the order does not belong to an OCA group.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "oca_type",
          "desc": "Optional. Specifies how an unfilled order behaves when another pending order with the same `oca_name` and `oca_type` values executes. Possible values: [strategy.oca.cancel](#const_strategy.oca.cancel), [strategy.oca.reduce](#const_strategy.oca.reduce), [strategy.oca.none](#const_strategy.oca.none). The default is [strategy.oca.none](#const_strategy.oca.none).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "comment",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the specified `id`. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_message",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "disable_alert",
          "desc": "Optional. If [true](#const_true) when the command creates an order, the strategy does not trigger an alert when that order fills. This parameter accepts a \"series\" value, meaning users can control which orders trigger alerts when they execute. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"Market order strategy\", overlay = true)",
            "",
            "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
            "float sma14 = ta.sma(close, 14)",
            "float sma28 = ta.sma(close, 28)",
            "",
            "// Place a market order to close the short trade and enter a long position when `sma14` crosses over `sma28`.",
            "if ta.crossover(sma14, sma28)",
            "    strategy.entry(\"My Long Entry ID\", strategy.long)",
            "",
            "// Place a market order to close the long trade and enter a short position when `sma14` crosses under `sma28`.",
            "if ta.crossunder(sma14, sma28)",
            "    strategy.entry(\"My Short Entry ID\", strategy.short)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"Limit order strategy\", overlay=true, margin_long=100, margin_short=100)",
            "",
            "//@variable The distance from the `close` price for each limit order.",
            "float limitOffsetInput = input.int(100, \"Limit offset, in ticks\", 1) * syminfo.mintick",
            "",
            "//@function Draws a label and line at the specified `price` to visualize a limit order's level. ",
            "drawLimit(float price, bool isLong) =>",
            "    color col = isLong ? color.blue : color.red",
            "    label.new(",
            "         bar_index, price, (isLong ? \"Long\" : \"Short\") + \" limit order created\", ",
            "         style = label.style_label_right, color = col, textcolor = color.white",
            "     )",
            "    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)",
            "",
            "//@function Stops the `l` line from extending further.",
            "method stopExtend(line l) =>",
            "    l.set_x2(bar_index)",
            "    l.set_extend(extend.none)",
            "",
            "// Initialize two `line` variables to reference limit line IDs.",
            "var line longLimit  = na",
            "var line shortLimit = na",
            "",
            "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
            "float sma14 = ta.sma(close, 14)",
            "float sma28 = ta.sma(close, 28)",
            "",
            "if ta.crossover(sma14, sma28)",
            "    // Cancel any unfilled sell orders with the specified ID.",
            "    strategy.cancel(\"My Short Entry ID\")",
            "    //@variable The limit price level. Its value is `limitOffsetInput` ticks below the current `close`.",
            "    float limitLevel = close - limitOffsetInput",
            "    // Place a long limit order to close the short trade and enter a long position at the `limitLevel`.",
            "    strategy.entry(\"My Long Entry ID\", strategy.long, limit = limitLevel)",
            "    // Make new drawings for the long limit and stop extending the `shortLimit` line.",
            "    longLimit := drawLimit(limitLevel, isLong = true)",
            "    shortLimit.stopExtend()",
            "    ",
            "if ta.crossunder(sma14, sma28)",
            "    // Cancel any unfilled buy orders with the specified ID.",
            "    strategy.cancel(\"My Long Entry ID\")",
            "    //@variable The limit price level. Its value is `limitOffsetInput` ticks above the current `close`.",
            "    float limitLevel = close + limitOffsetInput",
            "    // Place a short limit order to close the long trade and enter a short position at the `limitLevel`.",
            "    strategy.entry(\"My Short Entry ID\", strategy.short, limit = limitLevel)",
            "    // Make new drawings for the short limit and stop extending the `shortLimit` line.",
            "    shortLimit := drawLimit(limitLevel, isLong = false)",
            "    longLimit.stopExtend()"
          ]
        }
      ],
      "syntax": [
        "strategy.entry(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.order",
      "desc": [
        "Creates a new order to open, add to, or exit from a position. If an unfilled order with the same `id` exists, a call to this command modifies that order.",
        "The resulting order's type depends on the `limit` and `stop` parameters. If the call does not contain `limit` or `stop` arguments, it creates a [market order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders) that executes on the next tick. If the call specifies a `limit` value but no `stop` value, it places a [limit order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#limit-orders) that executes after the market price reaches the `limit` value or a better price (lower for buy orders and higher for sell orders). If the call specifies a `stop` value but no `limit` value, it places a [stop order](https://www.tradingview.com/pine-script-docs/concepts/strategies/#stop-and-stop-limit-orders) that executes after the market price reaches the `stop` value or a worse price (higher for buy orders and lower for sell orders). If the call contains `limit` and `stop` arguments, it creates a [stop-limit](https://www.tradingview.com/pine-script-docs/concepts/strategies/#stop-and-stop-limit-orders) order, which generates a limit order at the `limit` price only after the market price reaches the `stop` value or a worse price.",
        "Orders from this command, unlike those from [strategy.entry](#fun_strategy.entry), are not affected by the `pyramiding` parameter of the [strategy](#fun_strategy) declaration statement. Strategies can open any number of trades in the same direction with calls to this function.",
        "This command does not automatically reverse open positions because it does not exclusively create entry orders like [strategy.entry](#fun_strategy.entry) does. For example, if there is an open long position of five shares, an order from this command with a `qty` of 5 and a `direction` of [strategy.short](#const_strategy.short) triggers the sale of five shares, which closes the position."
      ],
      "args": [
        {
          "name": "id",
          "desc": "The identifier of the order, which corresponds to an entry or exit ID in the strategy's trades after the order fills. If the strategy opens a new position after filling the order, the order's ID becomes the [strategy.position_entry_name](#var_strategy.position_entry_name) value. Strategy commands can reference the order ID to cancel or modify pending orders and generate exit orders for specific open trades. The Strategy Tester and the chart display the order ID unless the command specifies a `comment` value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "direction",
          "desc": "The direction of the trade. Possible values: [strategy.long](#const_strategy.long) for a long trade, [strategy.short](#const_strategy.short) for a short one.",
          "required": true,
          "allowedTypeIDs": [
            "series strategy_direction",
            "simple strategy_direction",
            "input strategy_direction",
            "const strategy_direction"
          ],
          "displayType": "series strategy_direction"
        },
        {
          "name": "qty",
          "desc": "Optional. The number of contracts/shares/lots/units to trade when the order fills. The default is [na](#var_na), which means that the command uses the `default_qty_type` and `default_qty_value` parameters of the [strategy](#fun_strategy) declaration statement to determine the quantity.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "limit",
          "desc": "Optional. The limit price of the order. If specified, the command creates a limit or stop-limit order, depending on whether the `stop` value is also specified. The default is [na](#var_na), which means the resulting order is not of the limit or stop-limit type.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "stop",
          "desc": "Optional. The stop price of the order. If specified, the command creates a stop or stop-limit order, depending on whether the `limit` value is also specified. The default is [na](#var_na), which means the resulting order is not of the stop or stop-limit type.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "oca_name",
          "desc": "Optional. The name of the order's One-Cancels-All (OCA) group. When a pending order with the same `oca_name` and `oca_type` parameters executes, that order affects all unfilled orders in the group. The default is an empty string, which means the order does not belong to an OCA group.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "oca_type",
          "desc": "Optional. Specifies how an unfilled order behaves when another pending order with the same `oca_name` and `oca_type` values executes. Possible values: [strategy.oca.cancel](#const_strategy.oca.cancel), [strategy.oca.reduce](#const_strategy.oca.reduce), [strategy.oca.none](#const_strategy.oca.none). The default is [strategy.oca.none](#const_strategy.oca.none).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        },
        {
          "name": "comment",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the specified `id`. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_message",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "disable_alert",
          "desc": "Optional. If [true](#const_true) when the command creates an order, the strategy does not trigger an alert when that order fills. This parameter accepts a \"series\" value, meaning users can control which orders trigger alerts when they execute. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"Market order strategy\", overlay = true)",
            "",
            "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
            "float sma14 = ta.sma(close, 14)",
            "float sma28 = ta.sma(close, 28)",
            "",
            "// Place a market order to enter a long position when `sma14` crosses over `sma28`.",
            "if ta.crossover(sma14, sma28) and strategy.position_size == 0",
            "    strategy.order(\"My Long Entry ID\", strategy.long)",
            "",
            "// Place a market order to sell the same quantity as the long trade when `sma14` crosses under `sma28`, ",
            "// effectively closing the long position.",
            "if ta.crossunder(sma14, sma28) and strategy.position_size > 0",
            "    strategy.order(\"My Long Exit ID\", strategy.short)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"Limit and stop exit strategy\", overlay = true)",
            "",
            "//@variable The distance from the long entry price for each short limit order.",
            "float shortOffsetInput = input.int(200, \"Sell limit/stop offset, in ticks\", 1) * syminfo.mintick",
            "",
            "//@function Draws a label and line at the specified `price` to visualize a limit order's level. ",
            "drawLimit(float price, bool isLong, bool isStop = false) =>",
            "    color col = isLong ? color.blue : color.red",
            "    label.new(",
            "         bar_index, price, (isLong ? \"Long \" : \"Short \") + (isStop ? \"stop\" : \"limit\") + \" order created\", ",
            "         style = label.style_label_right, color = col, textcolor = color.white",
            "     )",
            "    line.new(bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = col)",
            "",
            "//@function Stops the `l` line from extending further.",
            "method stopExtend(line l) =>",
            "    l.set_x2(bar_index)",
            "    l.set_extend(extend.none)",
            "",
            "// Initialize two `line` variables to reference limit and stop line IDs.",
            "var line profitLimit = na",
            "var line lossStop    = na",
            "",
            "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
            "float sma14 = ta.sma(close, 14)",
            "float sma28 = ta.sma(close, 28)",
            "",
            "if ta.crossover(sma14, sma28) and strategy.position_size == 0",
            "    // Place a market order to enter a long position.",
            "    strategy.order(\"My Long Entry ID\", strategy.long)",
            "    ",
            "if strategy.position_size > 0 and strategy.position_size[1] == 0",
            "    //@variable The entry price of the long trade. ",
            "    float entryPrice = strategy.opentrades.entry_price(0)",
            "    // Calculate short limit and stop levels above and below the `entryPrice`.",
            "    float profitLevel = entryPrice + shortOffsetInput",
            "    float lossLevel   = entryPrice - shortOffsetInput",
            "    // Place short limit and stop orders at the `profitLevel` and `lossLevel`. ",
            "    strategy.order(\"Profit\", strategy.short, limit = profitLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)",
            "    strategy.order(\"Loss\", strategy.short, stop = lossLevel, oca_name = \"Bracket\", oca_type = strategy.oca.cancel)",
            "    // Make new drawings for the `profitLimit` and `lossStop` lines.",
            "    profitLimit := drawLimit(profitLevel, isLong = false)",
            "    lossStop    := drawLimit(lossLevel, isLong = false, isStop = true)",
            "",
            "if ta.change(strategy.closedtrades) > 0",
            "    // Stop extending the `profitLimit` and `lossStop` lines.",
            "    profitLimit.stopExtend()",
            "    lossStop.stopExtend()"
          ]
        }
      ],
      "syntax": [
        "strategy.order(id, direction, qty, limit, stop, oca_name, oca_type, comment, alert_message, disable_alert) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.exit",
      "desc": [
        "Creates price-based orders to exit from an open position. If unfilled exit orders with the same `id` exist, calls to this command modify those orders. This command can generate more than one type of exit order, depending on the specified parameters. However, it does not create [market orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders). To exit from a position with a market order, use [strategy.close](#fun_strategy.close) or [strategy.close_all](#fun_strategy.close_all).",
        "If a call to this command contains a `profit` or `limit` argument, it creates [take-profit](https://www.tradingview.com/pine-script-docs/concepts/strategies/#take-profit-and-stop-loss) orders to exit from applicable trades at the determined price levels or better values (higher for long trades and lower for short ones). If the call contains `loss` or `stop` arguments, it creates [stop-loss](https://www.tradingview.com/pine-script-docs/concepts/strategies/#take-profit-and-stop-loss) orders to exit from applicable trades at the determined levels or worse values (lower for long trades and higher for short ones). Calling this command with `profit` or `limit` and `loss` or `stop` arguments creates an order bracket with both order types.",
        "This command can create [trailing stop](https://www.tradingview.com/pine-script-docs/concepts/strategies/#trailing-stops) orders when its call specifies a `trail_price` or `trail_points` argument and a `trail_offset` argument. A trailing stop order activates when the price moves `trail_points` ticks past the entry price or touches the `trail_price` level. Once activated, the stop follows `trail_offset` ticks behind the market price each time the trade's profit reaches a new high. The stop does not move when the trade does not achieve a new best value.",
        "Each call to this command reserves a portion of the position to close until the strategy fills or cancels its orders. For example, if there is an open position of 50 contracts and a [strategy.exit](#fun_strategy.exit) call specifies a `qty` of 20, that call's orders reserve 20 contracts out of the position. A second call can close a maximum of 30 contracts, even if its `qty` is 50 and one of its orders executes first. This behavior does not affect the orders from other commands, such as [strategy.close](#fun_strategy.close) or [strategy.order](#fun_strategy.order).",
        "If a call to this command occurs before a created entry order's execution, the strategy waits and does not create the exit orders until after the entry order executes."
      ],
      "args": [
        {
          "name": "id",
          "desc": "The identifier of the orders, which corresponds to an exit ID in the strategy's trades after an order fills. Strategy commands can reference the order ID to cancel or modify pending exit orders. The Strategy Tester and the chart display the order ID unless the command includes a `comment*` argument that applies to the filled order.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "from_entry",
          "desc": "Optional. The entry order ID of the trade to exit from. If there is more than one open trade with the specified entry ID, the command generates exit orders for all the entries from before or at the time of the call. The default is an empty string, which means the command generates exit orders for all open trades until the position closes.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "qty",
          "desc": "Optional. The number of contracts/lots/shares/units to close when an exit order fills. If specified, the command uses this value instead of `qty_percent` to determine the order size. The exit orders reserve this quantity from the position, meaning other calls to this command cannot close this portion until the strategy fills or cancels those orders. The default is [na](#var_na), which means the order size depends on the `qty_percent` value.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "qty_percent",
          "desc": "Optional. A value between 0 and 100 representing the percentage of the open trade quantity to close when an exit order fills. The exit orders reserve this percentage from the applicable open trades, meaning other calls to this command cannot close this portion until the strategy fills or cancels those orders. The percentage calculation depends on the total size of the applicable open trades without considering the reserved amount from other [strategy.exit](#fun_strategy.exit) calls. The command ignores this parameter if the `qty` value is not [na](#var_na). The default is 100.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "profit",
          "desc": "Optional. The take-profit distance, expressed in ticks. If specified, the command creates a limit order to exit the trade `profit` ticks away from the entry price in the favorable direction. The order executes at the calculated price or a better value. If this parameter and `limit` are not [na](#var_na), the command places a take-profit order only at the price level expected to trigger an exit first. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "limit",
          "desc": "Optional. The take-profit price. If this parameter and `profit` are not [na](#var_na), the command places a take-profit order only at the price level expected to trigger an exit first. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "loss",
          "desc": "Optional. The stop-loss distance, expressed in ticks. If specified, the command creates a stop order to exit the trade `loss` ticks away from the entry price in the unfavorable direction. The order executes at the calculated price or a worse value. If this parameter and `stop` are not [na](#var_na), the command places a stop-loss order only at the price level expected to trigger an exit first. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "stop",
          "desc": "Optional. The stop-loss price. If this parameter and `loss` are not [na](#var_na), the command places a stop-loss order only at the price level expected to trigger an exit first. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "trail_price",
          "desc": "Optional. The price of the trailing stop activation level. If the value is more favorable than the entry price, the command creates a trailing stop when the market price reaches that value. If less favorable than the entry price, the command creates the trailing stop immediately when the current market price is equal to or more favorable than the value. If this parameter and `trail_points` are not [na](#var_na), the command sets the activation level using the value expected to activate the stop first. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "trail_points",
          "desc": "Optional. The trailing stop activation distance, expressed in ticks. If the value is positive, the command creates a trailing stop order when the market price moves `trail_points` ticks away from the trade's entry price in the favorable direction. If the value is negative, the command creates the trailing stop immediately when the market price is equal to or more favorable than the level `trail_points` ticks away from the entry price in the unfavorable direction. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "trail_offset",
          "desc": "Optional. The trailing stop offset. When the market price reaches the activation level determined by the `trail_price` or `trail_points` parameter, or exceeds the level in the favorable direction, the command creates a trailing stop with an initial value `trail_offset` ticks away from that level in the unfavorable direction. After activation, the trailing stop moves toward the market price each time the trade's profit reaches a better value, maintaining the specified distance behind the best price. The default is [na](#var_na).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "oca_name",
          "desc": "Optional. The name of the One-Cancels-All (OCA) group that the command's take-profit, stop-loss, and trailing stop orders belong to. All orders from this command are of the [strategy.oca.reduce](#const_strategy.oca.reduce) OCA type. When an order of this OCA type with the same `oca_name` executes, the strategy reduces the sizes of other unfilled orders in the OCA group by the filled quantity. The default is an empty string, which means the strategy assigns the OCA name automatically, and the resulting orders cannot reduce or be reduced by the orders from other commands.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "comment",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the specified `id`. The command ignores this value if the call includes an argument for a `comment_*` parameter that applies to the order. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "comment_profit",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the specified `id` or `comment`. This comment applies only to the command's take-profit orders created using the `profit` or `limit` parameter. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "comment_loss",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the specified `id` or `comment`. This comment applies only to the command's stop-loss orders created using the `loss` or `stop` parameter. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "comment_trailing",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the specified `id` or `comment`. This comment applies only to the command's trailing stop orders created using the `trail_price` or `trail_points` and `trail_offset` parameters. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_message",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. The command ignores this value if the call includes an argument for the other `alert_*` parameter that applies to the order. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_profit",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. This message applies only to the command's take-profit orders created using the `profit` or `limit` parameter. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_loss",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. This message applies only to the command's stop-loss orders created using the `loss` or `stop` parameter. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_trailing",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. This message applies only to the command's trailing stop orders created using the `trail_price` or `trail_points` and `trail_offset` parameters. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "disable_alert",
          "desc": "Optional. If [true](#const_true) when the command creates an order, the strategy does not trigger an alert when that order fills. This parameter accepts a \"series\" value, meaning users can control which orders trigger alerts when they execute. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"Exit bracket strategy\", overlay = true)",
            "",
            "// Inputs that define the profit and loss amount of each trade as a tick distance from the entry price.",
            "int profitDistanceInput = input.int(100, \"Profit distance, in ticks\", 1)",
            "int lossDistanceInput   = input.int(100, \"Loss distance, in ticks\", 1)",
            "",
            "// Variables to track the take-profit and stop-loss price. ",
            "var float takeProfit = na",
            "var float stopLoss   = na",
            "",
            "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
            "float sma14 = ta.sma(close, 14)",
            "float sma28 = ta.sma(close, 28)",
            "",
            "if ta.crossover(sma14, sma28) and strategy.opentrades == 0",
            "    // Place a market order to enter a long position.",
            "    strategy.entry(\"My Long Entry ID\", strategy.long)",
            "    // Place a take-profit and stop-loss order when the entry order fills. ",
            "    strategy.exit(\"My Long Exit ID\", \"My Long Entry ID\", profit = profitDistanceInput, loss = lossDistanceInput)",
            "",
            "if ta.change(strategy.opentrades) == 1",
            "    //@variable The long entry price.",
            "    float entryPrice = strategy.opentrades.entry_price(0)",
            "    // Update the `takeProfit` and `stopLoss` values.",
            "    takeProfit := entryPrice + profitDistanceInput * syminfo.mintick",
            "    stopLoss   := entryPrice - lossDistanceInput * syminfo.mintick",
            "",
            "if ta.change(strategy.closedtrades) == 1",
            "    // Reset the `takeProfit` and `stopLoss`.",
            "    takeProfit := na",
            "    stopLoss   := na",
            "",
            "// Plot the `takeProfit` and `stopLoss`.",
            "plot(takeProfit, \"Take-profit level\", color.green, 2, plot.style_linebr)",
            "plot(stopLoss, \"Stop-loss level\", color.red, 2, plot.style_linebr)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"Trailing stop strategy\", overlay = true)",
            "",
            "//@variable The distance required to activate the trailing stop.",
            "float activationDistanceInput = input.int(100, \"Trail activation distance, in ticks\") * syminfo.mintick ",
            "//@variable The number of ticks the trailing stop follows behind the price as it reaches new peaks. ",
            "int trailDistanceInput = input.int(100, \"Trail distance, in ticks\")",
            "",
            "//@function Draws a label and line at the specified `price` to visualize a trailing stop order's activation level. ",
            "drawActivation(float price) =>",
            "    label.new(",
            "         bar_index, price, \"Activation level\", style = label.style_label_right, ",
            "         color = color.gray, textcolor = color.white",
            "     )",
            "    line.new(",
            "         bar_index, price, bar_index + 1, price, extend = extend.right, style = line.style_dashed, color = color.gray",
            "     )",
            "",
            "//@function Stops the `l` line from extending further.",
            "method stopExtend(line l) =>",
            "    l.set_x2(bar_index)",
            "    l.set_extend(extend.none)",
            "",
            "// The activation line, active trailing stop price, and active trailing stop flag. ",
            "var line activationLine     = na",
            "var float trailingStopPrice = na",
            "var bool isActive           = false",
            "",
            "if bar_index % 100 == 0 and strategy.opentrades == 0",
            "    trailingStopPrice := na",
            "    isActive          := false",
            "    // Place a market order to enter a long position.",
            "    strategy.entry(\"My Long Entry ID\", strategy.long)",
            "    //@variable The activation level's price. ",
            "    float activationPrice = close + activationDistanceInput",
            "    // Create a trailing stop order that activates the defined number of ticks above the entry price.",
            "    strategy.exit(",
            "         \"My Long Exit ID\", \"My Long Entry ID\", trail_price = activationPrice, trail_offset = trailDistanceInput,",
            "         oca_name = \"Exit\"",
            "     )",
            "    // Create new drawings at the `activationPrice`.",
            "    activationLine := drawActivation(activationPrice)",
            "",
            "// Logic for trailing stop visualization. ",
            "if strategy.opentrades == 1",
            "    // Stop extending the `activationLine` when the stop activates.",
            "    if not isActive and high > activationLine.get_price(bar_index)",
            "        isActive := true",
            "        activationLine.stopExtend()",
            "    // Update the `trailingStopPrice` while the trailing stop is active. ",
            "    if isActive",
            "        float offsetPrice = high - trailDistanceInput * syminfo.mintick",
            "        trailingStopPrice := math.max(nz(trailingStopPrice, offsetPrice), offsetPrice)",
            "",
            "// Close the trade with a market order if the trailing stop does not activate before the next 300th bar. ",
            "if not isActive and bar_index % 300 == 0",
            "    strategy.close_all(\"Market close\")",
            "",
            "// Reset the `trailingStopPrice` and `isActive` flags when the trade closes, and stop extending the `activationLine`.",
            "if ta.change(strategy.closedtrades) > 0",
            "    if not isActive",
            "        activationLine.stopExtend()",
            "    trailingStopPrice := na",
            "    isActive          := false",
            "",
            "// Plot the `trailingStopPrice`.",
            "plot(trailingStopPrice, \"Trailing stop\", color.red, 3, plot.style_linebr)"
          ]
        }
      ],
      "remarks": [
        "A single call to the [strategy.exit](#fun_strategy.exit) command can generate exit orders for several entries in an open position, depending on the call's `from_entry` value. If the call does not include a `from_entry` argument, it creates exit orders for all open trades, even the ones opened after the call, until the position closes. See [this](https://www.tradingview.com/pine-script-docs/concepts/strategies/#exits-for-multiple-entries) section of our User Manual to learn more.",
        "When a position consists of several open trades, and the `close_entries_rule` in the [strategy](#fun_strategy) declaration statement is \"FIFO\" (default), the orders from a [strategy.exit](#fun_strategy.exit) call exit from the position starting with the first open trade. This behavior applies even if the `from_entry` value is the entry ID of different open trades. However, in that case, the maximum size of the exit orders still depends on the trades opened by orders with the `from_entry` ID. For more information, see [this](https://www.tradingview.com/pine-script-docs/concepts/strategies/#closing-a-market-position) section of our User Manual.",
        "If a [strategy.exit](#fun_strategy.exit) call includes arguments for creating stop-loss and trailing stop orders, the command places only the order that is supposed to fill first, because both orders are of the \"stop\" type."
      ],
      "syntax": [
        "strategy.exit(id, from_entry, qty, qty_percent, profit, limit, loss, stop, trail_price, trail_points, trail_offset, oca_name, comment, comment_profit, comment_loss, comment_trailing, alert_message, alert_profit, alert_loss, alert_trailing, disable_alert) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.cancel",
      "desc": [
        "Cancels a pending or unfilled order with a specific identifier. If multiple unfilled orders share the same ID, calling this command with that ID as the `id` argument cancels all of them. If a script calls this command with an `id` representing the ID of a filled order, it has no effect.",
        "This command is most useful when working with price-based orders (e.g., [limit orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#limit-orders)). Calls to this command can also cancel [market orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders), but only if they execute on the same ticks as the order placement commands."
      ],
      "args": [
        {
          "name": "id",
          "desc": "The identifier of the unfilled order to cancel.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(title = \"Order cancellation demo\")",
        "",
        "conditionForBuy = open > high[1]",
        "if conditionForBuy",
        "    strategy.entry(\"Long\", strategy.long, 1, limit = low) // Enter long using limit order at low price of current bar if `conditionForBuy` is `true`.",
        "if not conditionForBuy",
        "    strategy.cancel(\"Long\") // Cancel the entry order with name \"Long\" if `conditionForBuy` is `false`."
      ],
      "syntax": ["strategy.cancel(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.cancel_all",
      "desc": [
        "Cancels all pending or unfilled orders, regardless of their identifiers.",
        "This command is most useful when working with price-based orders (e.g., [limit orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#limit-orders)). Calls to this command can also cancel [market orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders), but only if they execute on the same ticks as the order placement commands."
      ],
      "examples": [
        "//@version=6",
        "strategy(title = \"Cancel all orders demo\")",
        "conditionForBuy1 = open > high[1]",
        "if conditionForBuy1",
        "    strategy.entry(\"Long entry 1\", strategy.long, 1, limit = low) // Enter long using a limit order if `conditionForBuy1` is `true`.",
        "conditionForBuy2 = conditionForBuy1 and open[1] > high[2]",
        "float lowest2 = ta.lowest(low, 2)",
        "if conditionForBuy2",
        "    strategy.entry(\"Long entry 2\", strategy.long, 1, limit = lowest2) // Enter long using a limit order if `conditionForBuy2` is `true`.",
        "conditionForStopTrading = open < lowest2",
        "if conditionForStopTrading",
        "    strategy.cancel_all() // Cancel both limit orders if `conditionForStopTrading` is `true`."
      ],
      "syntax": ["strategy.cancel_all() → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "ta.pivothigh",
      "desc": [
        "This function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point."
      ],
      "args": [
        {
          "name": "leftbars",
          "desc": "Left strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "rightbars",
          "desc": "Right strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"PivotHigh\", overlay=true)",
        "leftBars = input(2)",
        "rightBars=input(2)",
        "ph = ta.pivothigh(leftBars, rightBars)",
        "plot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"
      ],
      "returns": ["Price of the point or 'NaN'."],
      "remarks": [
        "If parameters 'leftbars' or 'rightbars' are series you should use [max_bars_back](#fun_max_bars_back) function for the 'source' variable."
      ],
      "syntax": ["ta.pivothigh(leftbars, rightbars) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.pivothigh",
      "desc": [
        "This function returns price of the pivot high point. It returns 'NaN', if there was no pivot high point."
      ],
      "args": [
        {
          "name": "source",
          "desc": "An optional parameter. Data series to calculate the value. 'High' by default.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "leftbars",
          "desc": "Left strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "rightbars",
          "desc": "Right strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"PivotHigh\", overlay=true)",
        "leftBars = input(2)",
        "rightBars=input(2)",
        "ph = ta.pivothigh(leftBars, rightBars)",
        "plot(ph, style=plot.style_cross, linewidth=3, color= color.red, offset=-rightBars)"
      ],
      "returns": ["Price of the point or 'NaN'."],
      "remarks": [
        "If parameters 'leftbars' or 'rightbars' are series you should use [max_bars_back](#fun_max_bars_back) function for the 'source' variable."
      ],
      "syntax": ["ta.pivothigh(source, leftbars, rightbars) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.pivotlow",
      "desc": [
        "This function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point."
      ],
      "args": [
        {
          "name": "leftbars",
          "desc": "Left strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "rightbars",
          "desc": "Right strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"PivotLow\", overlay=true)",
        "leftBars = input(2)",
        "rightBars=input(2)",
        "pl = ta.pivotlow(close, leftBars, rightBars)",
        "plot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"
      ],
      "returns": ["Price of the point or 'NaN'."],
      "remarks": [
        "If parameters 'leftbars' or 'rightbars' are series you should use [max_bars_back](#fun_max_bars_back) function for the 'source' variable."
      ],
      "syntax": ["ta.pivotlow(leftbars, rightbars) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "ta.pivotlow",
      "desc": [
        "This function returns price of the pivot low point. It returns 'NaN', if there was no pivot low point."
      ],
      "args": [
        {
          "name": "source",
          "desc": "An optional parameter. Data series to calculate the value. 'Low' by default.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "leftbars",
          "desc": "Left strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "rightbars",
          "desc": "Right strength.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"PivotLow\", overlay=true)",
        "leftBars = input(2)",
        "rightBars=input(2)",
        "pl = ta.pivotlow(close, leftBars, rightBars)",
        "plot(pl, style=plot.style_cross, linewidth=3, color= color.blue, offset=-rightBars)"
      ],
      "returns": ["Price of the point or 'NaN'."],
      "remarks": [
        "If parameters 'leftbars' or 'rightbars' are series you should use [max_bars_back](#fun_max_bars_back) function for the 'source' variable."
      ],
      "syntax": ["ta.pivotlow(source, leftbars, rightbars) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.close_all",
      "desc": [
        "Creates an order to close an open position completely, regardless of the identifiers of the entry orders that opened or added to it.",
        "This command always generates [market orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders). To exit from a position using price-based orders (e.g., [stop-loss](https://www.tradingview.com/pine-script-docs/concepts/strategies/#take-profit-and-stop-loss) orders), use the [strategy.exit](#fun_strategy.exit) command."
      ],
      "args": [
        {
          "name": "comment",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the automatically generated exit identifier. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_message",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"Multi-entry close strategy\")",
        "",
        "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
        "float sma14 = ta.sma(close, 14)",
        "float sma28 = ta.sma(close, 28)",
        "",
        "// Place a market order to enter a long trade every time `sma14` crosses over `sma28`.",
        "if ta.crossover(sma14, sma28)",
        "    strategy.order(\"My Long Entry ID \" + str.tostring(strategy.opentrades), strategy.long)",
        "",
        "// Place a market order to close the entire position every 500 bars. ",
        "if bar_index % 500 == 0",
        "    strategy.close_all()",
        "",
        "// Plot the position size.",
        "plot(strategy.position_size)"
      ],
      "syntax": ["strategy.close_all(comment, alert_message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.close_all",
      "desc": [
        "Creates an order to close an open position completely, regardless of the identifiers of the entry orders that opened or added to it.",
        "This command always generates [market orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders). To exit from a position using price-based orders (e.g., [stop-loss](https://www.tradingview.com/pine-script-docs/concepts/strategies/#take-profit-and-stop-loss) orders), use the [strategy.exit](#fun_strategy.exit) command."
      ],
      "args": [
        {
          "name": "comment",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the automatically generated exit identifier. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "alert_message",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "immediately",
          "desc": "Optional. If [true](#const_true), the closing order executes on the same tick when the strategy places it, ignoring the strategy properties that restrict execution to the opening tick of the following bar. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "disable_alert",
          "desc": "Optional. If [true](#const_true) when the command creates an order, the strategy does not trigger an alert when that order fills. This parameter accepts a \"series\" value, meaning users can control which orders trigger alerts when they execute. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"Multi-entry close strategy\")",
        "",
        "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
        "float sma14 = ta.sma(close, 14)",
        "float sma28 = ta.sma(close, 28)",
        "",
        "// Place a market order to enter a long trade every time `sma14` crosses over `sma28`.",
        "if ta.crossover(sma14, sma28)",
        "    strategy.order(\"My Long Entry ID \" + str.tostring(strategy.opentrades), strategy.long)",
        "",
        "// Place a market order to close the entire position every 500 bars. ",
        "if bar_index % 500 == 0",
        "    strategy.close_all()",
        "",
        "// Plot the position size.",
        "plot(strategy.position_size)"
      ],
      "syntax": ["strategy.close_all(comment, alert_message, immediately, disable_alert) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.close",
      "desc": [
        "Creates an order to exit from the part of a position opened by entry orders with a specific identifier. If multiple entries in the position share the same ID, the orders from this command apply to all those entries, starting from the first open trade, when its calls use that ID as the `id` argument.",
        "This command always generates [market orders](https://www.tradingview.com/pine-script-docs/concepts/strategies/#market-orders). To exit from a position using price-based orders (e.g., [stop-loss](https://www.tradingview.com/pine-script-docs/concepts/strategies/#take-profit-and-stop-loss) orders), use the [strategy.exit](#fun_strategy.exit) command."
      ],
      "args": [
        {
          "name": "id",
          "desc": "The entry identifier of the open trades to close.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "comment",
          "desc": "Optional. Additional notes on the filled order. If the value is not an empty string, the Strategy Tester and the chart show this text for the order instead of the automatically generated exit identifier. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "qty",
          "desc": "Optional. The number of contracts/lots/shares/units to close when an exit order fills. If specified, the command uses this value instead of `qty_percent` to determine the order size. The default is [na](#var_na), which means the order size depends on the `qty_percent` value.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "qty_percent",
          "desc": "Optional. A value between 0 and 100 representing the percentage of the open trade quantity to close when an exit order fills. The percentage calculation depends on the total size of the open trades with the `id` entry identifier. The command ignores this parameter if the `qty` value is not [na](#var_na). The default is 100.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "alert_message",
          "desc": "Optional. Custom text for the alert that fires when an order fills. If the \"Message\" field of the \"Create Alert\" dialog box contains the `{{strategy.order.alert_message}}` placeholder, the alert message replaces the placeholder with this text. The default is an empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "immediately",
          "desc": "Optional. If [true](#const_true), the closing order executes on the same tick when the strategy places it, ignoring the strategy properties that restrict execution to the opening tick of the following bar. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "disable_alert",
          "desc": "Optional. If [true](#const_true) when the command creates an order, the strategy does not trigger an alert when that order fills. This parameter accepts a \"series\" value, meaning users can control which orders trigger alerts when they execute. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"Partial close strategy\")",
        "",
        "// Calculate a 14-bar and 28-bar moving average of `close` prices.",
        "float sma14 = ta.sma(close, 14)",
        "float sma28 = ta.sma(close, 28)",
        "",
        "// Place a market order to enter a long position when `sma14` crosses over `sma28`.",
        "if ta.crossover(sma14, sma28)",
        "    strategy.entry(\"My Long Entry ID\", strategy.long)",
        "",
        "// Place a market order to close the long trade when `sma14` crosses under `sma28`. ",
        "if ta.crossunder(sma14, sma28)",
        "    strategy.close(\"My Long Entry ID\", \"50% market close\", qty_percent = 50)",
        "",
        "// Plot the position size.",
        "plot(strategy.position_size)"
      ],
      "remarks": [
        "When a position consists of several open trades and the `close_entries_rule` in the [strategy](#fun_strategy) declaration statement is \"FIFO\" (default), a [strategy.close](#fun_strategy.close) call exits from the position starting with the first open trade. This behavior applies even if the `id` value is the entry ID of different open trades. However, in that case, the maximum exit order size still depends on the trades opened by orders with the `id` identifier. For more information, see [this](https://www.tradingview.com/pine-script-docs/concepts/strategies/#closing-a-market-position) section of our User Manual."
      ],
      "syntax": [
        "strategy.close(id, comment, qty, qty_percent, alert_message, immediately, disable_alert) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.risk.max_position_size",
      "desc": [
        "The purpose of this rule is to determine maximum size of a market position. The rule affects the following function: [strategy.entry](#fun_strategy.entry). The 'entry' quantity can be reduced (if needed) to such number of contracts/shares/lots/units, so the total position size doesn't exceed the value specified in 'strategy.risk.max_position_size'. If minimum possible quantity still violates the rule, the order will not be placed."
      ],
      "args": [
        {
          "name": "contracts",
          "desc": "A required parameter. Maximum number of contracts/shares/lots/units in a position.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"risk.max_position_size Demo\", default_qty_value = 100)",
        "strategy.risk.max_position_size(10)",
        "if open > close",
        "\tstrategy.entry(\"buy\", strategy.long)",
        "plot(strategy.position_size) // max plot value will be 10"
      ],
      "syntax": ["strategy.risk.max_position_size(contracts) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.risk.max_intraday_loss",
      "desc": [
        "The maximum loss value allowed during a day. It is specified either in money (base currency), or in percentage of maximum intraday equity (0 -100)."
      ],
      "args": [
        {
          "name": "value",
          "desc": "A required parameter. The maximum loss value. It is specified either in money (base currency), or in percentage of maximum intraday equity. For % of equity the range of allowed values is from 0 to 100.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "type",
          "desc": "A required parameter. The type of the value. Please specify one of the following values: [strategy.percent_of_equity](#const_strategy.percent_of_equity) or [strategy.cash](#const_strategy.cash). Note: if equity drops down to zero or to a negative and the [strategy.percent_of_equity](#const_strategy.percent_of_equity) is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "alert_message",
          "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box's \"Message\" field.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "// Sets the maximum intraday loss using the strategy's equity value.",
            "//@version=6",
            "strategy(\"strategy.risk.max_intraday_loss Example 1\", overlay = false, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)",
            "",
            "// Input for maximum intraday loss %. ",
            "lossPct = input.float(10)",
            "",
            "// Set maximum intraday loss to our lossPct input",
            "strategy.risk.max_intraday_loss(lossPct, strategy.percent_of_equity)",
            "",
            "// Enter Short at bar_index zero.",
            "if bar_index == 0",
            "\tstrategy.entry(\"Short\", strategy.short)",
            "",
            "// Store equity value from the beginning of the day",
            "eqFromDayStart = ta.valuewhen(ta.change(dayofweek) > 0, strategy.equity, 0)",
            "",
            "// Calculate change of the current equity from the beginning of the current day.",
            "eqChgPct = 100 * ((strategy.equity - eqFromDayStart) / strategy.equity)",
            "",
            "// Plot it",
            "plot(eqChgPct) ",
            "hline(-lossPct)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Sets the maximum intraday loss using the strategy's cash value.",
            "//@version=6",
            "strategy(\"strategy.risk.max_intraday_loss Example 2\", overlay = false)",
            "",
            "// Input for maximum intraday loss in absolute cash value of the symbol. ",
            "absCashLoss = input.float(5)",
            "",
            "// Set maximum intraday loss to `absCashLoss` in account currency.",
            "strategy.risk.max_intraday_loss(absCashLoss, strategy.cash)",
            "",
            "// Enter Short at bar_index zero.",
            "if bar_index == 0",
            "\tstrategy.entry(\"Short\", strategy.short)",
            "",
            "// Store the open price value from the beginning of the day.",
            "beginPrice = ta.valuewhen(ta.change(dayofweek) > 0, open, 0)",
            "",
            "// Calculate the absolute price change for the current period.",
            "priceChg = (close - beginPrice)",
            "",
            "hline(absCashLoss)",
            "plot(priceChg)"
          ]
        }
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.percent_of_equity](#const_strategy.percent_of_equity)",
        "[strategy.cash](#const_strategy.cash)"
      ],
      "syntax": ["strategy.risk.max_intraday_loss(value, type, alert_message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.risk.max_intraday_filled_orders",
      "desc": [
        "The purpose of this rule is to determine maximum number of filled orders per 1 day (per 1 bar, if chart resolution is higher than 1 day). The rule affects the whole strategy. Once the maximum number of filled orders is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed till the end of the current trading session."
      ],
      "args": [
        {
          "name": "count",
          "desc": "A required parameter. The maximum number of filled orders per 1 day.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "alert_message",
          "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box's \"Message\" field.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"risk.max_intraday_filled_orders Demo\")",
        "strategy.risk.max_intraday_filled_orders(10) // After 10 orders are filled, no more strategy orders will be placed (except for a market order to exit current open market position, if there is any).",
        "if open > close",
        "\tstrategy.entry(\"buy\", strategy.long)",
        "if open < close",
        "\tstrategy.entry(\"sell\", strategy.short)"
      ],
      "syntax": ["strategy.risk.max_intraday_filled_orders(count, alert_message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.risk.allow_entry_in",
      "desc": [
        "This function can be used to specify in which market direction the [strategy.entry](#fun_strategy.entry) function is allowed to open positions."
      ],
      "args": [
        {
          "name": "value",
          "desc": "The allowed direction. Possible values: [strategy.direction.all](#const_strategy.direction.all), [strategy.direction.long](#const_strategy.direction.long), [strategy.direction.short](#const_strategy.direction.short)",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.risk.allow_entry_in\")",
        "",
        "strategy.risk.allow_entry_in(strategy.direction.long)",
        "if open > close",
        "\tstrategy.entry(\"Long\", strategy.long)",
        "// Instead of opening a short position with 10 contracts, this command will close long entries.",
        "if open < close",
        "\tstrategy.entry(\"Short\", strategy.short, qty = 10)"
      ],
      "syntax": ["strategy.risk.allow_entry_in(value) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.risk.max_cons_loss_days",
      "desc": [
        "The purpose of this rule is to cancel all pending orders, close all open positions and stop placing orders after a specified number of consecutive days with losses. The rule affects the whole strategy."
      ],
      "args": [
        {
          "name": "count",
          "desc": "A required parameter. The allowed number of consecutive days with losses.",
          "required": true,
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        },
        {
          "name": "alert_message",
          "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box's \"Message\" field.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"risk.max_cons_loss_days Demo 1\")",
        "strategy.risk.max_cons_loss_days(3) // No orders will be placed after 3 days, if each day is with loss.",
        "plot(strategy.position_size)"
      ],
      "syntax": ["strategy.risk.max_cons_loss_days(count, alert_message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.risk.max_drawdown",
      "desc": [
        "The purpose of this rule is to determine maximum drawdown. The rule affects the whole strategy. Once the maximum drawdown value is reached, all pending orders are cancelled, all open positions are closed and no new orders can be placed."
      ],
      "args": [
        {
          "name": "value",
          "desc": "A required parameter. The maximum drawdown value. It is specified either in money (base currency), or in percentage of maximum equity. For % of equity the range of allowed values is from 0 to 100.",
          "required": true,
          "allowedTypeIDs": [
            "simple int",
            "input int",
            "const int",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "simple int/float"
        },
        {
          "name": "type",
          "desc": "A required parameter. The type of the value. Please specify one of the following values: [strategy.percent_of_equity](#const_strategy.percent_of_equity) or [strategy.cash](#const_strategy.cash). Note: if equity drops down to zero or to a negative and the 'strategy.percent_of_equity' is specified, all pending orders are cancelled, all open positions are closed and no new orders can be placed for good.",
          "required": true,
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        },
        {
          "name": "alert_message",
          "desc": "An optional parameter which replaces the {{strategy.order.alert_message}} placeholder when it is used in the \"Create Alert\" dialog box's \"Message\" field.",
          "allowedTypeIDs": ["simple string", "input string", "const string"],
          "displayType": "simple string"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"risk.max_drawdown Demo 1\")",
            "strategy.risk.max_drawdown(50, strategy.percent_of_equity) // set maximum drawdown to 50% of maximum equity",
            "plot(strategy.position_size)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"risk.max_drawdown Demo 2\", currency = \"EUR\")",
            "strategy.risk.max_drawdown(2000, strategy.cash) // set maximum drawdown to 2000 EUR from maximum equity",
            "plot(strategy.position_size)"
          ]
        }
      ],
      "syntax": ["strategy.risk.max_drawdown(value, type, alert_message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.copy",
      "desc": ["Clones the box object."],
      "args": [
        {
          "name": "id",
          "desc": "Box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Last 50 bars price ranges', overlay = true)",
        "LOOKBACK = 50",
        "highest = ta.highest(LOOKBACK)",
        "lowest = ta.lowest(LOOKBACK)",
        "if barstate.islastconfirmedhistory",
        "\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))",
        "\tvar BoxPrev = box.copy(BoxLast)",
        "\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])",
        "\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])",
        "\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))"
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.delete](#fun_box.delete)"],
      "syntax": ["box.copy(id) → series box"],
      "returnedTypes": ["series box"]
    },
    {
      "name": "box.new",
      "desc": ["Creates a new box object."],
      "args": [
        {
          "name": "top_left",
          "desc": "A [chart.point](#type_chart.point) object that specifies the top-left corner location of the box.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        },
        {
          "name": "bottom_right",
          "desc": "A [chart.point](#type_chart.point) object that specifies the bottom-right corner location of the box.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        },
        {
          "name": "border_color",
          "desc": "Color of the four borders. Optional. The default is [color.blue](#const_color.blue).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "border_width",
          "desc": "Width of the four borders, in pixels. Optional. The default is 1 pixel.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "border_style",
          "desc": "Style of the four borders. Possible values: [line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed). Optional. The default value is [line.style_solid](#const_line.style_solid).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "extend",
          "desc": "When [extend.none](#const_extend.none) is used, the horizontal borders start at the left border and end at the right border. With [extend.left](#const_extend.left) or [extend.right](#const_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively. With [extend.both](#const_extend.both), the horizontal borders are extended on both sides. Optional. The default value is [extend.none](#const_extend.none).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "xloc",
          "desc": "Determines whether the arguments to 'left' and 'right' are a bar index or a time value. If xloc = [xloc.bar_index](#const_xloc.bar_index), the arguments must be a bar index. If xloc = [xloc.bar_time](#const_xloc.bar_time), the arguments must be a UNIX time. Possible values: [xloc.bar_index](#const_xloc.bar_index) and [xloc.bar_time](#const_xloc.bar_time). Optional. The default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bgcolor",
          "desc": "Background color of the box. Optional. The default is [color.blue](#const_color.blue).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the box. Optional. The default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_size",
          "desc": "Optional. Size of the box's text. The size can be any positive integer, or one of the `size.*` built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36). The default value is [size.auto](#const_size.auto) or 0.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        },
        {
          "name": "text_color",
          "desc": "The color of the text. Optional. The default is [color.black](#const_color.black).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of the box's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the box's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_wrap",
          "desc": "Optional. Whether to wrap text. Wrapped text starts a new line when it reaches the side of the box. Wrapped text lower than the bottom of the box is not displayed. Unwrapped text stays on a single line and *is displayed* past the width of the box if it is too long. If the `text_size` is 0 or [text.wrap_auto](#const_text.wrap_auto), this setting has no effect. The default value is [text.wrap_none](#const_text.wrap_none). Possible values: [text.wrap_none](#const_text.wrap_none), [text.wrap_auto](#const_text.wrap_auto).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Optional. The default value is [font.family_default](#const_font.family_default). Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"box.new\")",
        "var b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)",
        "box.set_lefttop(b, time, 100)",
        "box.set_rightbottom(b, time + 60 * 60 * 24, 500)",
        "box.set_bgcolor(b, color.green)"
      ],
      "returns": [
        "The ID of a box object which may be used in box.set_*() and box.get_*() functions."
      ],
      "seeAlso": [
        "[box.delete](#fun_box.delete)",
        "[box.get_left](#fun_box.get_left)",
        "[box.get_top](#fun_box.get_top)",
        "[box.get_right](#fun_box.get_right)",
        "[box.get_bottom](#fun_box.get_bottom)",
        "[box.set_top_left_point](#fun_box.set_top_left_point)",
        "[box.set_left](#fun_box.set_left)",
        "[box.set_top](#fun_box.set_top)",
        "[box.set_bottom_right_point](#fun_box.set_bottom_right_point)",
        "[box.set_right](#fun_box.set_right)",
        "[box.set_bottom](#fun_box.set_bottom)",
        "[box.set_border_color](#fun_box.set_border_color)",
        "[box.set_bgcolor](#fun_box.set_bgcolor)",
        "[box.set_border_width](#fun_box.set_border_width)",
        "[box.set_border_style](#fun_box.set_border_style)",
        "[box.set_extend](#fun_box.set_extend)",
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_formatting](#fun_box.set_text_formatting)"
      ],
      "syntax": [
        "box.new(top_left, bottom_right, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) → series box"
      ],
      "returnedTypes": ["series box"]
    },
    {
      "name": "box.new",
      "desc": ["Creates a new box object."],
      "args": [
        {
          "name": "left",
          "desc": "Bar index (if xloc = [xloc.bar_index](#const_xloc.bar_index)) or UNIX time (if xloc = [xloc.bar_time](#const_xloc.bar_time)) of the left border of the box. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "top",
          "desc": "Price of the top border of the box.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "right",
          "desc": "Bar index (if xloc = [xloc.bar_index](#const_xloc.bar_index)) or UNIX time (if xloc = [xloc.bar_time](#const_xloc.bar_time)) of the right border of the box. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "bottom",
          "desc": "Price of the bottom border of the box.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "border_color",
          "desc": "Color of the four borders. Optional. The default is [color.blue](#const_color.blue).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "border_width",
          "desc": "Width of the four borders, in pixels. Optional. The default is 1 pixel.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "border_style",
          "desc": "Style of the four borders. Possible values: [line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed). Optional. The default value is [line.style_solid](#const_line.style_solid).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "extend",
          "desc": "When [extend.none](#const_extend.none) is used, the horizontal borders start at the left border and end at the right border. With [extend.left](#const_extend.left) or [extend.right](#const_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively. With [extend.both](#const_extend.both), the horizontal borders are extended on both sides. Optional. The default value is [extend.none](#const_extend.none).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "xloc",
          "desc": "Determines whether the arguments to 'left' and 'right' are a bar index or a time value. If xloc = [xloc.bar_index](#const_xloc.bar_index), the arguments must be a bar index. If xloc = [xloc.bar_time](#const_xloc.bar_time), the arguments must be a UNIX time. Possible values: [xloc.bar_index](#const_xloc.bar_index) and [xloc.bar_time](#const_xloc.bar_time). Optional. The default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "bgcolor",
          "desc": "Background color of the box. Optional. The default is [color.blue](#const_color.blue).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the box. Optional. The default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_size",
          "desc": "Optional. Size of the box's text. The size can be any positive integer, or one of the `size.*` built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36). The default value is [size.auto](#const_size.auto) or 0.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        },
        {
          "name": "text_color",
          "desc": "The color of the text. Optional. The default is [color.black](#const_color.black).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of the box's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the box's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_wrap",
          "desc": "Optional. Whether to wrap text. Wrapped text starts a new line when it reaches the side of the box. Wrapped text lower than the bottom of the box is not displayed. Unwrapped text stays on a single line and *is displayed* past the width of the box if it is too long. If the `text_size` is 0 or [text.wrap_auto](#const_text.wrap_auto), this setting has no effect. The default value is [text.wrap_none](#const_text.wrap_none). Possible values: [text.wrap_none](#const_text.wrap_none), [text.wrap_auto](#const_text.wrap_auto).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Optional. The default value is [font.family_default](#const_font.family_default). Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"box.new\")",
        "var b = box.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, border_style=line.style_dashed)",
        "box.set_lefttop(b, time, 100)",
        "box.set_rightbottom(b, time + 60 * 60 * 24, 500)",
        "box.set_bgcolor(b, color.green)"
      ],
      "returns": [
        "The ID of a box object which may be used in box.set_*() and box.get_*() functions."
      ],
      "seeAlso": [
        "[box.delete](#fun_box.delete)",
        "[box.get_left](#fun_box.get_left)",
        "[box.get_top](#fun_box.get_top)",
        "[box.get_right](#fun_box.get_right)",
        "[box.get_bottom](#fun_box.get_bottom)",
        "[box.set_top_left_point](#fun_box.set_top_left_point)",
        "[box.set_left](#fun_box.set_left)",
        "[box.set_top](#fun_box.set_top)",
        "[box.set_bottom_right_point](#fun_box.set_bottom_right_point)",
        "[box.set_right](#fun_box.set_right)",
        "[box.set_bottom](#fun_box.set_bottom)",
        "[box.set_border_color](#fun_box.set_border_color)",
        "[box.set_bgcolor](#fun_box.set_bgcolor)",
        "[box.set_border_width](#fun_box.set_border_width)",
        "[box.set_border_style](#fun_box.set_border_style)",
        "[box.set_extend](#fun_box.set_extend)",
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_formatting](#fun_box.set_text_formatting)"
      ],
      "syntax": [
        "box.new(left, top, right, bottom, border_color, border_width, border_style, extend, xloc, bgcolor, text, text_size, text_color, text_halign, text_valign, text_wrap, text_font_family, force_overlay, text_formatting) → series box"
      ],
      "returnedTypes": ["series box"]
    },
    {
      "name": "box.delete",
      "desc": ["Deletes the specified box object. If it has already been deleted, does nothing."],
      "args": [
        {
          "name": "id",
          "desc": "A box object to delete.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.delete(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.get_left",
      "desc": [
        "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "returns": ["A bar index or a UNIX timestamp (in milliseconds)."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_left](#fun_box.set_left)"],
      "syntax": ["box.get_left(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "box.get_right",
      "desc": [
        "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "returns": ["A bar index or a UNIX timestamp (in milliseconds)."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_right](#fun_box.set_right)"],
      "syntax": ["box.get_right(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "box.get_top",
      "desc": ["Returns the price value of the top border of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "returns": ["The price value."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_top](#fun_box.set_top)"],
      "syntax": ["box.get_top(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "box.get_bottom",
      "desc": ["Returns the price value of the bottom border of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "returns": ["The price value."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_bottom](#fun_box.set_bottom)"],
      "syntax": ["box.get_bottom(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "box.set_left",
      "desc": ["Sets the left coordinate of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "left",
          "desc": "Bar index or bar time of the left border. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_left](#fun_box.get_left)"],
      "syntax": ["box.set_left(id, left) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_lefttop",
      "desc": ["Sets the left and top coordinates of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "left",
          "desc": "Bar index or bar time of the left border.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "top",
          "desc": "Price value of the top border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.get_left](#fun_box.get_left)",
        "[box.get_top](#fun_box.get_top)"
      ],
      "syntax": ["box.set_lefttop(id, left, top) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_right",
      "desc": ["Sets the right coordinate of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "right",
          "desc": "Bar index or bar time of the right border. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_right](#fun_box.get_right)"],
      "syntax": ["box.set_right(id, right) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_rightbottom",
      "desc": ["Sets the right and bottom coordinates of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "right",
          "desc": "Bar index or bar time of the right border.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "bottom",
          "desc": "Price value of the bottom border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.get_right](#fun_box.get_right)",
        "[box.get_bottom](#fun_box.get_bottom)"
      ],
      "syntax": ["box.set_rightbottom(id, right, bottom) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_top",
      "desc": ["Sets the top coordinate of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "top",
          "desc": "Price value of the top border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_top](#fun_box.get_top)"],
      "syntax": ["box.set_top(id, top) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_bottom",
      "desc": ["Sets the bottom coordinate of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "bottom",
          "desc": "Price value of the bottom border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_bottom](#fun_box.get_bottom)"],
      "syntax": ["box.set_bottom(id, bottom) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_border_color",
      "desc": ["Sets the border color of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "color",
          "desc": "New border color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.set_border_color(id, color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_bgcolor",
      "desc": ["Sets the background color of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "color",
          "desc": "New background color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.set_bgcolor(id, color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_border_width",
      "desc": ["Sets the border width of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "width",
          "desc": "Width of the four borders, in pixels.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.set_border_width(id, width) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_border_style",
      "desc": ["Sets the border style of the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "style",
          "desc": "New border style.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed)"
      ],
      "syntax": ["box.set_border_style(id, style) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_extend",
      "desc": [
        "Sets extending type of the border of this box object. When [extend.none](#const_extend.none) is used, the horizontal borders start at the left border and end at the right border. With [extend.left](#const_extend.left) or [extend.right](#const_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively. With [extend.both](#const_extend.both), the horizontal borders are extended on both sides."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "extend",
          "desc": "New extending type.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[extend.none](#const_extend.none), [extend.right](#const_extend.right), [extend.left](#const_extend.left), [extend.both](#const_extend.both)"
      ],
      "syntax": ["box.set_extend(id, extend) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text_font_family",
      "desc": ["The function sets the font family of the text inside the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Example of setting the box font\")",
        "if barstate.islastconfirmedhistory",
        "    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")",
        "    box.set_text_font_family(b, font.family_monospace)"
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[font.family_default](#const_font.family_default)",
        "[font.family_monospace](#const_font.family_monospace)"
      ],
      "syntax": ["box.set_text_font_family(id, text_font_family) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text_halign",
      "desc": ["The function sets the horizontal alignment of the box's text."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of a box's text. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_color](#fun_box.set_text_color)"
      ],
      "syntax": ["box.set_text_halign(id, text_halign) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text_valign",
      "desc": ["The function sets the vertical alignment of a box's text."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the box's text. Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_halign](#fun_box.set_text_halign)"
      ],
      "syntax": ["box.set_text_valign(id, text_valign) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text_size",
      "desc": ["The function sets the size of the box's text."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_size",
          "desc": "Size of the box's text. The size can be any positive integer, or one of the `size.*` built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)"
      ],
      "syntax": ["box.set_text_size(id, text_size) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text",
      "desc": ["The function sets the text in the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the box.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)",
        "[box.set_text_formatting](#fun_box.set_text_formatting)"
      ],
      "syntax": ["box.set_text(id, text) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text_formatting",
      "desc": ["Sets the formatting attributes the drawing applies to displayed text."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic).",
          "required": true,
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "seeAlso": [
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)",
        "[box.set_text](#fun_box.set_text)"
      ],
      "syntax": ["box.set_text_formatting(id, text_formatting) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_text_color",
      "desc": ["The function sets the color of the text inside the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_color",
          "desc": "The color of the text.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)"
      ],
      "syntax": ["box.set_text_color(id, text_color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.copy",
      "desc": ["Clones the line object."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Last 100 bars price range', overlay = true)",
        "LOOKBACK = 100",
        "highest = ta.highest(LOOKBACK)",
        "lowest = ta.lowest(LOOKBACK)",
        "if barstate.islastconfirmedhistory",
        "\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)",
        "\tvar lineBottom = line.copy(lineTop)",
        "\tline.set_y1(lineBottom, lowest)",
        "\tline.set_y2(lineBottom, lowest)",
        "\tline.set_color(lineBottom, color.red)"
      ],
      "returns": [
        "New line ID object which may be passed to line.setXXX and line.getXXX functions."
      ],
      "seeAlso": ["[line.new](#fun_line.new)", "[line.delete](#fun_line.delete)"],
      "syntax": ["line.copy(id) → series line"],
      "returnedTypes": ["series line"]
    },
    {
      "name": "box.set_text_wrap",
      "desc": ["The function sets the mode of wrapping of the text inside the box."],
      "args": [
        {
          "name": "id",
          "desc": "A box object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "text_wrap",
          "desc": "Whether to wrap text. Wrapped text starts a new line when it reaches the side of the box. Wrapped text lower than the bottom of the box is not displayed. Unwrapped text stays on a single line and *is displayed* past the width of the box if it is too long. If the `text_size` is 0 or [text.wrap_auto](#const_text.wrap_auto), this setting has no effect. Possible values: [text.wrap_none](#const_text.wrap_none), [text.wrap_auto](#const_text.wrap_auto).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)",
        "[box.set_text_color](#fun_box.set_text_color)"
      ],
      "syntax": ["box.set_text_wrap(id, text_wrap) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.new",
      "desc": ["Creates new line object."],
      "args": [
        {
          "name": "x1",
          "desc": "Bar index (if xloc = [xloc.bar_index](#const_xloc.bar_index)) or bar UNIX time (if xloc = [xloc.bar_time](#const_xloc.bar_time)) of the first point of the line. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y1",
          "desc": "Price of the first point of the line.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "x2",
          "desc": "Bar index (if xloc = [xloc.bar_index](#const_xloc.bar_index)) or bar UNIX time (if xloc = [xloc.bar_time](#const_xloc.bar_time)) of the second point of the line. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y2",
          "desc": "Price of the second point of the line.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "xloc",
          "desc": "See description of **x1** argument. Possible values: [xloc.bar_index](#const_xloc.bar_index) and [xloc.bar_time](#const_xloc.bar_time). Default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "extend",
          "desc": "If extend=[extend.none](#const_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to [extend.right](#const_extend.right) or [extend.left](#const_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend=[extend.both](#const_extend.both), draws a straight line that goes through these points. Default value is [extend.none](#const_extend.none).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "color",
          "desc": "Line color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "style",
          "desc": "Line style. Possible values: [line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed), [line.style_arrow_left](#const_line.style_arrow_left), [line.style_arrow_right](#const_line.style_arrow_right), [line.style_arrow_both](#const_line.style_arrow_both).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "width",
          "desc": "Line width in pixels.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"line.new\")",
        "var line1 = line.new(0, low, bar_index, high, extend=extend.right)",
        "var line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)",
        "line.set_x2(line1, 0)",
        "line.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)",
        "line.set_color(line2, color.green)",
        "line.set_width(line2, 5)"
      ],
      "returns": ["Line ID object which may be passed to line.setXXX and line.getXXX functions."],
      "seeAlso": [
        "[line.delete](#fun_line.delete)",
        "[line.set_x1](#fun_line.set_x1)",
        "[line.set_y1](#fun_line.set_y1)",
        "[line.set_xy1](#fun_line.set_xy1)",
        "[line.set_x2](#fun_line.set_x2)",
        "[line.set_y2](#fun_line.set_y2)",
        "[line.set_xy2](#fun_line.set_xy2)",
        "[line.set_xloc](#fun_line.set_xloc)",
        "[line.set_color](#fun_line.set_color)",
        "[line.set_extend](#fun_line.set_extend)",
        "[line.set_style](#fun_line.set_style)",
        "[line.set_width](#fun_line.set_width)"
      ],
      "syntax": [
        "line.new(x1, y1, x2, y2, xloc, extend, color, style, width, force_overlay) → series line"
      ],
      "returnedTypes": ["series line"]
    },
    {
      "name": "line.new",
      "desc": ["Creates new line object."],
      "args": [
        {
          "name": "first_point",
          "desc": "A [chart.point](#type_chart.point) object that specifies the line's starting coordinate.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        },
        {
          "name": "second_point",
          "desc": "A [chart.point](#type_chart.point) object that specifies the line's ending coordinate.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        },
        {
          "name": "xloc",
          "desc": "See description of **x1** argument. Possible values: [xloc.bar_index](#const_xloc.bar_index) and [xloc.bar_time](#const_xloc.bar_time). Default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "extend",
          "desc": "If extend=[extend.none](#const_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to [extend.right](#const_extend.right) or [extend.left](#const_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend=[extend.both](#const_extend.both), draws a straight line that goes through these points. Default value is [extend.none](#const_extend.none).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "color",
          "desc": "Line color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "style",
          "desc": "Line style. Possible values: [line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed), [line.style_arrow_left](#const_line.style_arrow_left), [line.style_arrow_right](#const_line.style_arrow_right), [line.style_arrow_both](#const_line.style_arrow_both).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "width",
          "desc": "Line width in pixels.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"line.new\")",
        "var line1 = line.new(0, low, bar_index, high, extend=extend.right)",
        "var line2 = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time, style=line.style_dashed)",
        "line.set_x2(line1, 0)",
        "line.set_xloc(line1, time, time + 60 * 60 * 24, xloc.bar_time)",
        "line.set_color(line2, color.green)",
        "line.set_width(line2, 5)"
      ],
      "returns": ["Line ID object which may be passed to line.setXXX and line.getXXX functions."],
      "seeAlso": [
        "[line.delete](#fun_line.delete)",
        "[line.set_x1](#fun_line.set_x1)",
        "[line.set_y1](#fun_line.set_y1)",
        "[line.set_xy1](#fun_line.set_xy1)",
        "[line.set_x2](#fun_line.set_x2)",
        "[line.set_y2](#fun_line.set_y2)",
        "[line.set_xy2](#fun_line.set_xy2)",
        "[line.set_xloc](#fun_line.set_xloc)",
        "[line.set_color](#fun_line.set_color)",
        "[line.set_extend](#fun_line.set_extend)",
        "[line.set_style](#fun_line.set_style)",
        "[line.set_width](#fun_line.set_width)"
      ],
      "syntax": [
        "line.new(first_point, second_point, xloc, extend, color, style, width, force_overlay) → series line"
      ],
      "returnedTypes": ["series line"]
    },
    {
      "name": "line.set_x1",
      "desc": ["Sets bar index or bar time (depending on the xloc) of the first point."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "x",
          "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_x1(id, x) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_y1",
      "desc": ["Sets price of the first point"],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_y1(id, y) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_xy1",
      "desc": ["Sets bar index/time and price of the first point."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "x",
          "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_xy1(id, x, y) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_x2",
      "desc": ["Sets bar index or bar time (depending on the xloc) of the second point."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "x",
          "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_x2(id, x) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_y2",
      "desc": ["Sets price of the second point."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_y2(id, y) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_xy2",
      "desc": ["Sets bar index/time and price of the second point"],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "x",
          "desc": "Bar index or bar time.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_xy2(id, x, y) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_xloc",
      "desc": ["Sets x-location and new bar index/time values."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "x1",
          "desc": "Bar index or bar time of the first point.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "x2",
          "desc": "Bar index or bar time of the second point.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "xloc",
          "desc": "New x-location value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[xloc.bar_index](#const_xloc.bar_index)",
        "[xloc.bar_time](#const_xloc.bar_time)",
        "[line.new](#fun_line.new)"
      ],
      "syntax": ["line.set_xloc(id, x1, x2, xloc) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_extend",
      "desc": [
        "Sets extending type of this line object. If extend=[extend.none](#const_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to [extend.right](#const_extend.right) or [extend.left](#const_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend=[extend.both](#const_extend.both), draws a straight line that goes through these points."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "extend",
          "desc": "New extending type.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[extend.none](#const_extend.none)",
        "[extend.right](#const_extend.right)",
        "[extend.left](#const_extend.left)",
        "[extend.both](#const_extend.both)",
        "[line.new](#fun_line.new)"
      ],
      "syntax": ["line.set_extend(id, extend) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_color",
      "desc": ["Sets the line color"],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "color",
          "desc": "New line color",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_color(id, color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_style",
      "desc": ["Sets the line style"],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "style",
          "desc": "New line style.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_right](#const_line.style_arrow_right)",
        "[line.style_arrow_both](#const_line.style_arrow_both)",
        "[line.new](#fun_line.new)"
      ],
      "syntax": ["line.set_style(id, style) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_width",
      "desc": ["Sets the line width."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "width",
          "desc": "New line width in pixels.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_width(id, width) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.delete",
      "desc": ["Deletes the specified line object. If it has already been deleted, does nothing."],
      "args": [
        {
          "name": "id",
          "desc": "Line object to delete.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.delete(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.get_x1",
      "desc": [
        "Returns UNIX time or bar index (depending on the last xloc value set) of the first point of the line."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"line.get_x1\")",
        "my_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)",
        "a = line.get_x1(my_line)",
        "plot(time - line.get_x1(my_line)) //draws zero plot"
      ],
      "returns": ["UNIX timestamp (in milliseconds) or bar index."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_x1(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "line.get_y1",
      "desc": ["Returns price of the first point of the line."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "returns": ["Price value."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_y1(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "line.get_x2",
      "desc": [
        "Returns UNIX time or bar index (depending on the last xloc value set) of the second point of the line."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "returns": ["UNIX timestamp (in milliseconds) or bar index."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_x2(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "line.get_y2",
      "desc": ["Returns price of the second point of the line."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "returns": ["Price value."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_y2(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "line.get_price",
      "desc": ["Returns the price level of a line at a given bar index."],
      "args": [
        {
          "name": "id",
          "desc": "Line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "x",
          "desc": "Bar index for which price is required.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"GetPrice\", overlay=true)",
        "var line l = na",
        "if bar_index == 10",
        "    l := line.new(0, high[5], bar_index, high)",
        "plot(line.get_price(l, bar_index), color=color.green)"
      ],
      "returns": ["Price value of line 'id' at bar index 'x'."],
      "remarks": [
        "The line is considered to have been created using 'extend=extend.both'.",
        "This function can only be called for lines created using 'xloc.bar_index'. If you try to call it for a line created with 'xloc.bar_time', it will generate an error."
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_price(id, x) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "label.copy",
      "desc": ["Clones the label object."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator('Last 100 bars highest/lowest', overlay = true)",
        "LOOKBACK = 100",
        "highest = ta.highest(LOOKBACK)",
        "highestBars = ta.highestbars(LOOKBACK)",
        "lowest = ta.lowest(LOOKBACK)",
        "lowestBars = ta.lowestbars(LOOKBACK)",
        "if barstate.islastconfirmedhistory",
        "\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)",
        "\tvar labelLow = label.copy(labelHigh)",
        "\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)",
        "\tlabel.set_text(labelLow, str.tostring(lowest))",
        "\tlabel.set_color(labelLow, color.red)",
        "\tlabel.set_style(labelLow, label.style_label_up)"
      ],
      "returns": [
        "New label ID object which may be passed to label.setXXX and label.getXXX functions."
      ],
      "seeAlso": ["[label.new](#fun_label.new)", "[label.delete](#fun_label.delete)"],
      "syntax": ["label.copy(id) → series label"],
      "returnedTypes": ["series label"]
    },
    {
      "name": "linefill.new",
      "desc": [
        "Creates a new linefill object and displays it on the chart, filling the space between `line1` and `line2` with the color specified in `color`."
      ],
      "args": [
        {
          "name": "line1",
          "desc": "First line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "line2",
          "desc": "Second line object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "color",
          "desc": "The color used to fill the space between the lines.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "returns": [
        "The ID of a linefill object that can be passed to other linefill.*() functions."
      ],
      "remarks": [
        "If any line of the two is deleted, the linefill object is also deleted. If the lines are moved (e.g. via [line.set_xy](#fun_line.set_xy) functions), the linefill object is also moved.",
        "If both lines are extended in the same direction relative to the lines themselves (e.g. both have [extend.right](#const_extend.right) as the value of their `extend=` parameter), the space between line extensions will also be filled."
      ],
      "syntax": ["linefill.new(line1, line2, color) → series linefill"],
      "returnedTypes": ["series linefill"]
    },
    {
      "name": "linefill.delete",
      "desc": [
        "Deletes the specified linefill object. If it has already been deleted, does nothing."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A linefill object.",
          "required": true,
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        }
      ],
      "syntax": ["linefill.delete(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "linefill.set_color",
      "desc": ["The function sets the color of the linefill object passed to it."],
      "args": [
        {
          "name": "id",
          "desc": "A linefill object.",
          "required": true,
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        },
        {
          "name": "color",
          "desc": "The color of the linefill object.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "syntax": ["linefill.set_color(id, color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "linefill.get_line1",
      "desc": ["Returns the ID of the first line used in the `id` linefill."],
      "args": [
        {
          "name": "id",
          "desc": "A linefill object.",
          "required": true,
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        }
      ],
      "syntax": ["linefill.get_line1(id) → series line"],
      "returnedTypes": ["series line"]
    },
    {
      "name": "linefill.get_line2",
      "desc": ["Returns the ID of the second line used in the `id` linefill."],
      "args": [
        {
          "name": "id",
          "desc": "A linefill object.",
          "required": true,
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        }
      ],
      "syntax": ["linefill.get_line2(id) → series line"],
      "returnedTypes": ["series line"]
    },
    {
      "name": "array.new_linefill",
      "desc": ["The function creates a new array object of linefill type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements.",
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        }
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "syntax": ["array.new_linefill(size, initial_value) → array<linefill>"],
      "returnedTypes": ["array<linefill>"]
    },
    {
      "name": "label.new",
      "desc": ["Creates new label object."],
      "args": [
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object that specifies the label's location.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        },
        {
          "name": "text",
          "desc": "Label text. Default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "xloc",
          "desc": "See description of **x** argument. Possible values: [xloc.bar_index](#const_xloc.bar_index) and [xloc.bar_time](#const_xloc.bar_time). Default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "yloc",
          "desc": "Possible values are [yloc.price](#const_yloc.price), [yloc.abovebar](#const_yloc.abovebar), [yloc.belowbar](#const_yloc.belowbar). If yloc=[yloc.price](#const_yloc.price), **y** argument specifies the price of the label position. If yloc=[yloc.abovebar](#const_yloc.abovebar), label is located above bar. If yloc=[yloc.belowbar](#const_yloc.belowbar), label is located below bar. Default is [yloc.price](#const_yloc.price).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "color",
          "desc": "Color of the label border and arrow",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "style",
          "desc": "Label style. Possible values: [label.style_none](#const_label.style_none), [label.style_xcross](#const_label.style_xcross), [label.style_cross](#const_label.style_cross), [label.style_triangleup](#const_label.style_triangleup), [label.style_triangledown](#const_label.style_triangledown), [label.style_flag](#const_label.style_flag), [label.style_circle](#const_label.style_circle), [label.style_arrowup](#const_label.style_arrowup), [label.style_arrowdown](#const_label.style_arrowdown), [label.style_label_up](#const_label.style_label_up), [label.style_label_down](#const_label.style_label_down), [label.style_label_left](#const_label.style_label_left), [label.style_label_right](#const_label.style_label_right), [label.style_label_lower_left](#const_label.style_label_lower_left), [label.style_label_lower_right](#const_label.style_label_lower_right), [label.style_label_upper_left](#const_label.style_label_upper_left), [label.style_label_upper_right](#const_label.style_label_upper_right), [label.style_label_center](#const_label.style_label_center), [label.style_square](#const_label.style_square), [label.style_diamond](#const_label.style_diamond), [label.style_text_outline](#const_label.style_text_outline). Default is [label.style_label_down](#const_label.style_label_down).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "textcolor",
          "desc": "Text color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "size",
          "desc": "Optional. Size of the label. Accepts a positive [int](#type_int) value or one of the built-in `size.*` constants. The constants and their equivalent numeric sizes are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (\\~7), [size.small](#const_size.small) (\\~10), [size.normal](#const_size.normal) (12), [size.large](#const_size.large) (18), [size.huge](#const_size.huge) (24). The default value is [size.normal](#const_size.normal), which represents the numeric size of 12.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        },
        {
          "name": "textalign",
          "desc": "Label text alignment. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right). Default value is [text.align_center](#const_text.align_center).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "tooltip",
          "desc": "Hover to see tooltip label.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Optional. The default value is [font.family_default](#const_font.family_default). Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"label.new\")",
        "var label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)",
        "label.set_x(label1, 0)",
        "label.set_xloc(label1, time, xloc.bar_time)",
        "label.set_color(label1, color.red)",
        "label.set_size(label1, size.large)"
      ],
      "returns": [
        "Label ID object which may be passed to label.setXXX and label.getXXX functions."
      ],
      "seeAlso": [
        "[label.delete](#fun_label.delete)",
        "[label.set_x](#fun_label.set_x)",
        "[label.set_y](#fun_label.set_y)",
        "[label.set_xy](#fun_label.set_xy)",
        "[label.set_xloc](#fun_label.set_xloc)",
        "[label.set_yloc](#fun_label.set_yloc)",
        "[label.set_color](#fun_label.set_color)",
        "[label.set_textcolor](#fun_label.set_textcolor)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_size](#fun_label.set_size)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.set_tooltip](#fun_label.set_tooltip)",
        "[label.set_text](#fun_label.set_text)",
        "[label.set_text_formatting](#fun_label.set_text_formatting)"
      ],
      "syntax": [
        "label.new(point, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family, force_overlay, text_formatting) → series label"
      ],
      "returnedTypes": ["series label"]
    },
    {
      "name": "label.new",
      "desc": ["Creates new label object."],
      "args": [
        {
          "name": "x",
          "desc": "Bar index (if xloc = [xloc.bar_index](#const_xloc.bar_index)) or bar UNIX time (if xloc = [xloc.bar_time](#const_xloc.bar_time)) of the label position. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "Price of the label position. It is taken into account only if yloc=[yloc.price](#const_yloc.price).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "text",
          "desc": "Label text. Default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "xloc",
          "desc": "See description of **x** argument. Possible values: [xloc.bar_index](#const_xloc.bar_index) and [xloc.bar_time](#const_xloc.bar_time). Default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "yloc",
          "desc": "Possible values are [yloc.price](#const_yloc.price), [yloc.abovebar](#const_yloc.abovebar), [yloc.belowbar](#const_yloc.belowbar). If yloc=[yloc.price](#const_yloc.price), **y** argument specifies the price of the label position. If yloc=[yloc.abovebar](#const_yloc.abovebar), label is located above bar. If yloc=[yloc.belowbar](#const_yloc.belowbar), label is located below bar. Default is [yloc.price](#const_yloc.price).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "color",
          "desc": "Color of the label border and arrow",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "style",
          "desc": "Label style. Possible values: [label.style_none](#const_label.style_none), [label.style_xcross](#const_label.style_xcross), [label.style_cross](#const_label.style_cross), [label.style_triangleup](#const_label.style_triangleup), [label.style_triangledown](#const_label.style_triangledown), [label.style_flag](#const_label.style_flag), [label.style_circle](#const_label.style_circle), [label.style_arrowup](#const_label.style_arrowup), [label.style_arrowdown](#const_label.style_arrowdown), [label.style_label_up](#const_label.style_label_up), [label.style_label_down](#const_label.style_label_down), [label.style_label_left](#const_label.style_label_left), [label.style_label_right](#const_label.style_label_right), [label.style_label_lower_left](#const_label.style_label_lower_left), [label.style_label_lower_right](#const_label.style_label_lower_right), [label.style_label_upper_left](#const_label.style_label_upper_left), [label.style_label_upper_right](#const_label.style_label_upper_right), [label.style_label_center](#const_label.style_label_center), [label.style_square](#const_label.style_square), [label.style_diamond](#const_label.style_diamond), [label.style_text_outline](#const_label.style_text_outline). Default is [label.style_label_down](#const_label.style_label_down).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "textcolor",
          "desc": "Text color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "size",
          "desc": "Optional. Size of the label. Accepts a positive [int](#type_int) value or one of the built-in `size.*` constants. The constants and their equivalent numeric sizes are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (\\~7), [size.small](#const_size.small) (\\~10), [size.normal](#const_size.normal) (12), [size.large](#const_size.large) (18), [size.huge](#const_size.huge) (24). The default value is [size.normal](#const_size.normal), which represents the numeric size of 12.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        },
        {
          "name": "textalign",
          "desc": "Label text alignment. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right). Default value is [text.align_center](#const_text.align_center).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "tooltip",
          "desc": "Hover to see tooltip label.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Optional. The default value is [font.family_default](#const_font.family_default). Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"label.new\")",
        "var label1 = label.new(bar_index, low, text=\"Hello, world!\", style=label.style_circle)",
        "label.set_x(label1, 0)",
        "label.set_xloc(label1, time, xloc.bar_time)",
        "label.set_color(label1, color.red)",
        "label.set_size(label1, size.large)"
      ],
      "returns": [
        "Label ID object which may be passed to label.setXXX and label.getXXX functions."
      ],
      "seeAlso": [
        "[label.delete](#fun_label.delete)",
        "[label.set_x](#fun_label.set_x)",
        "[label.set_y](#fun_label.set_y)",
        "[label.set_xy](#fun_label.set_xy)",
        "[label.set_xloc](#fun_label.set_xloc)",
        "[label.set_yloc](#fun_label.set_yloc)",
        "[label.set_color](#fun_label.set_color)",
        "[label.set_textcolor](#fun_label.set_textcolor)",
        "[label.set_style](#fun_label.set_style)",
        "[label.set_size](#fun_label.set_size)",
        "[label.set_textalign](#fun_label.set_textalign)",
        "[label.set_tooltip](#fun_label.set_tooltip)",
        "[label.set_text](#fun_label.set_text)",
        "[label.set_text_formatting](#fun_label.set_text_formatting)"
      ],
      "syntax": [
        "label.new(x, y, text, xloc, yloc, color, style, textcolor, size, textalign, tooltip, text_font_family, force_overlay, text_formatting) → series label"
      ],
      "returnedTypes": ["series label"]
    },
    {
      "name": "label.set_x",
      "desc": ["Sets bar index or bar time (depending on the xloc) of the label position."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "x",
          "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_x(id, x) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_y",
      "desc": ["Sets price of the label position"],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "y",
          "desc": "New price of the label position.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_y(id, y) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_xy",
      "desc": ["Sets bar index/time and price of the label position."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "x",
          "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "New price of the label position.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_xy(id, x, y) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_xloc",
      "desc": ["Sets x-location and new bar index/time value."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "x",
          "desc": "New bar index or bar time of the label position.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "xloc",
          "desc": "New x-location value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[xloc.bar_index](#const_xloc.bar_index)",
        "[xloc.bar_time](#const_xloc.bar_time)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_xloc(id, x, xloc) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_yloc",
      "desc": ["Sets new y-location calculation algorithm."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "yloc",
          "desc": "New y-location value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[yloc.price](#const_yloc.price)",
        "[yloc.abovebar](#const_yloc.abovebar)",
        "[yloc.belowbar](#const_yloc.belowbar)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_yloc(id, yloc) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_text",
      "desc": ["Sets label text"],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "text",
          "desc": "New label text.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_text_formatting](#fun_label.set_text_formatting)"
      ],
      "syntax": ["label.set_text(id, text) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_text_formatting",
      "desc": ["Sets the formatting attributes the drawing applies to displayed text."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "required": true,
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)", "[label.set_text](#fun_label.set_text)"],
      "syntax": ["label.set_text_formatting(id, text_formatting) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_text_font_family",
      "desc": ["The function sets the font family of the text inside the label."],
      "args": [
        {
          "name": "id",
          "desc": "A label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Example of setting the label font\")",
        "if barstate.islastconfirmedhistory",
        "    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)",
        "    label.set_text_font_family(l, font.family_monospace)"
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[font.family_default](#const_font.family_default)",
        "[font.family_monospace](#const_font.family_monospace)"
      ],
      "syntax": ["label.set_text_font_family(id, text_font_family) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_color",
      "desc": ["Sets label border and arrow color."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "color",
          "desc": "New label border and arrow color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_color(id, color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_style",
      "desc": ["Sets label style."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "style",
          "desc": "New label style. Possible values: [label.style_none](#const_label.style_none), [label.style_xcross](#const_label.style_xcross), [label.style_cross](#const_label.style_cross), [label.style_triangleup](#const_label.style_triangleup), [label.style_triangledown](#const_label.style_triangledown), [label.style_flag](#const_label.style_flag), [label.style_circle](#const_label.style_circle), [label.style_arrowup](#const_label.style_arrowup), [label.style_arrowdown](#const_label.style_arrowdown), [label.style_label_up](#const_label.style_label_up), [label.style_label_down](#const_label.style_label_down), [label.style_label_left](#const_label.style_label_left), [label.style_label_right](#const_label.style_label_right), [label.style_label_lower_left](#const_label.style_label_lower_left), [label.style_label_lower_right](#const_label.style_label_lower_right), [label.style_label_upper_left](#const_label.style_label_upper_left), [label.style_label_upper_right](#const_label.style_label_upper_right), [label.style_label_center](#const_label.style_label_center), [label.style_square](#const_label.style_square), [label.style_diamond](#const_label.style_diamond), [label.style_text_outline](#const_label.style_text_outline).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_style(id, style) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_textcolor",
      "desc": ["Sets color of the label text."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "textcolor",
          "desc": "New text color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_textcolor(id, textcolor) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_size",
      "desc": ["Sets arrow and text size of the specified label object."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "size",
          "desc": "Size of the label. Accepts a positive [int](#type_int) value or one of the built-in `size.*` constants. The constants and their equivalent numeric sizes are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (\\~7), [size.small](#const_size.small) (\\~10), [size.normal](#const_size.normal) (12), [size.large](#const_size.large) (18), [size.huge](#const_size.huge) (24). The default value is [size.normal](#const_size.normal), which represents the numeric size of 12.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        }
      ],
      "seeAlso": [
        "[size.auto](#const_size.auto)",
        "[size.tiny](#const_size.tiny)",
        "[size.small](#const_size.small)",
        "[size.normal](#const_size.normal)",
        "[size.large](#const_size.large)",
        "[size.huge](#const_size.huge)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_size(id, size) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_textalign",
      "desc": ["Sets the alignment for the label text."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "textalign",
          "desc": "Label text alignment. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[text.align_left](#const_text.align_left)",
        "[text.align_center](#const_text.align_center)",
        "[text.align_right](#const_text.align_right)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_textalign(id, textalign) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_tooltip",
      "desc": ["Sets the tooltip text."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "tooltip",
          "desc": "Tooltip text.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_tooltip(id, tooltip) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.delete",
      "desc": ["Deletes the specified label object. If it has already been deleted, does nothing."],
      "args": [
        {
          "name": "id",
          "desc": "Label object to delete.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.delete(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.get_x",
      "desc": [
        "Returns UNIX time or bar index (depending on the last xloc value set) of this label's position."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"label.get_x\")",
        "my_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)",
        "a = label.get_x(my_label)",
        "plot(time - label.get_x(my_label)) //draws zero plot"
      ],
      "returns": ["UNIX timestamp (in milliseconds) or bar index."],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.get_x(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "label.get_y",
      "desc": ["Returns price of this label's position."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "returns": ["Floating point value representing price."],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.get_y(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "label.get_text",
      "desc": ["Returns the text of this label object."],
      "args": [
        {
          "name": "id",
          "desc": "Label object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"label.get_text\")",
        "my_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)",
        "a = label.get_text(my_label)",
        "label.new(time, close, text = a + \" new\", xloc=xloc.bar_time)"
      ],
      "returns": ["String object containing the text of this label."],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.get_text(id) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "max_bars_back",
      "desc": [
        "Function sets the maximum number of bars that is available for historical reference of a given built-in or user variable. When operator '[]' is applied to a variable - it is a reference to a historical value of that variable.",
        "",
        "If an argument of an operator '[]' is a compile time constant value (e.g. 'v[10]', 'close[500]') then there is no need to use 'max_bars_back' function for that variable. Pine Script® compiler will use that constant value as history buffer size.",
        "",
        "If an argument of an operator '[]' is a value, calculated at runtime (e.g. 'v[i]' where 'i' - is a series variable) then Pine Script® attempts to autodetect the history buffer size at runtime. Sometimes it fails and the script crashes at runtime because it eventually refers to historical values that are out of the buffer. In that case you should use 'max_bars_back' to fix that problem manually."
      ],
      "args": [
        {
          "name": "var",
          "desc": "Series variable identifier for which history buffer should be resized. Possible values are: 'open', 'high', 'low', 'close', 'volume', 'time', or any user defined variable id.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series color",
            "simple color",
            "input color",
            "const color",
            "series label",
            "series line"
          ],
          "displayType": "series int/float/bool/color/label/line"
        },
        {
          "name": "num",
          "desc": "History buffer size which is the number of bars that could be referenced for variable 'var'.",
          "required": true,
          "allowedTypeIDs": ["const int"],
          "displayType": "const int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"max_bars_back\")",
        "close_() => close",
        "depth() => 400",
        "d = depth()",
        "v = close_()",
        "max_bars_back(v, 500)",
        "out = if bar_index > 0",
        "\tv[d]",
        "else",
        "\tv",
        "plot(out)"
      ],
      "returns": ["void"],
      "remarks": [
        "At the moment 'max_bars_back' cannot be applied to built-ins like 'hl2', 'hlc3', 'ohlc4'. Please use multiple 'max_bars_back' calls as workaround here (e.g. instead of a single ‘max_bars_back(hl2, 100)’ call you should call the function twice: ‘max_bars_back(high, 100), max_bars_back(low, 100)’).",
        "",
        "If the [indicator](#fun_indicator) or [strategy](#fun_strategy) 'max_bars_back' parameter is used, all variables in the indicator are affected. This may result in excessive memory usage and cause runtime problems. When possible (i.e. when the cause is a variable rather than a function), please use the [max_bars_back](#fun_max_bars_back) function instead."
      ],
      "seeAlso": [
        "Param 'max_bars_back' of [indicator](#fun_indicator) and [strategy](#fun_strategy) functions."
      ],
      "syntax": ["max_bars_back(var, num) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.new<type>",
      "desc": ["The function creates a new array object of <type> elements."],
      "syntax": ["array.new<type>(size, initial_value) → array<type>"],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": [],
          "displayType": "<array_type>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new<string> example\")",
        "a = array.new<string>(1, \"Hello, World!\")",
        "label.new(bar_index, close, array.get(a, 0))"
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.new<color> example\")",
            "a = array.new<color>()",
            "array.push(a, color.red)",
            "array.push(a, color.green)",
            "plot(close, color = array.get(a, close > open ? 1 : 0))"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.new<float> example\")",
            "length = 5",
            "var a = array.new<float>(length, close)",
            "if array.size(a) == length",
            "\tarray.remove(a, 0)",
            "\tarray.push(a, close)",
            "plot(array.sum(a) / length, \"SMA\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.new<line> example\")",
            "// draw last 15 lines",
            "var a = array.new<line>()",
            "array.push(a, line.new(bar_index - 1, close[1], bar_index, close))",
            "if array.size(a) > 15",
            "    ln = array.shift(a)",
            "    line.delete(ln)"
          ]
        }
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": [
        "An array index starts from 0.",
        "If you want to initialize an array and specify all its elements at the same time, then use the function array.from."
      ],
      "seeAlso": [
        "[array.from](#fun_array.from)",
        "[array.push](#fun_array.push)",
        "[array.get](#fun_array.get)",
        "[array.size](#fun_array.size)",
        "[array.remove](#fun_array.remove)",
        "[array.shift](#fun_array.shift)",
        "[array.sum](#fun_array.sum)"
      ],
      "template": true
    },
    {
      "name": "array.new_float",
      "desc": ["The function creates a new array object of float type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_float example\")",
        "length = 5",
        "a = array.new_float(length, close)",
        "plot(array.sum(a) / length)"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_color](#fun_array.new_color)",
        "[array.new_bool](#fun_array.new_bool)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "syntax": ["array.new_float(size, initial_value) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "array.new_int",
      "desc": ["The function creates a new array object of int type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_int example\")",
        "length = 5",
        "a = array.new_int(length, int(close))",
        "plot(array.sum(a) / length)"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "syntax": ["array.new_int(size, initial_value) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "array.new_color",
      "desc": ["The function creates a new array object of color type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_color example\")",
        "length = 5",
        "a = array.new_color(length, color.red)",
        "plot(close, color = array.get(a, 0))"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "syntax": ["array.new_color(size, initial_value) → array<color>"],
      "returnedTypes": ["array<color>"]
    },
    {
      "name": "array.new_bool",
      "desc": ["The function creates a new array object of bool type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'false'.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_bool example\")",
        "length = 5",
        "a = array.new_bool(length, close > open)",
        "plot(array.get(a, 0) ? close : open)"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "syntax": ["array.new_bool(size, initial_value) → array<bool>"],
      "returnedTypes": ["array<bool>"]
    },
    {
      "name": "array.new_string",
      "desc": ["The function creates a new array object of string type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_string example\")",
        "length = 5",
        "a = array.new_string(length, \"text\")",
        "label.new(bar_index, close, array.get(a, 0))"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.new_string(size, initial_value) → array<string>"],
      "returnedTypes": ["array<string>"]
    },
    {
      "name": "array.new_line",
      "desc": ["The function creates a new array object of line type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_line example\")",
        "// draw last 15 lines",
        "var a = array.new_line()",
        "array.push(a, line.new(bar_index - 1, close[1], bar_index, close))",
        "if array.size(a) > 15",
        "\tln = array.shift(a)",
        "\tline.delete(ln)"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.new_line(size, initial_value) → array<line>"],
      "returnedTypes": ["array<line>"]
    },
    {
      "name": "array.new_box",
      "desc": ["The function creates a new array object of box type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_box example\")",
        "boxes = array.new_box()",
        "array.push(boxes, box.new(time, close, time+2, low, xloc=xloc.bar_time))",
        "plot(1)"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.new_box(size, initial_value) → array<box>"],
      "returnedTypes": ["array<box>"]
    },
    {
      "name": "array.new_table",
      "desc": ["The function creates a new array object of table type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"table array\")",
        "tables = array.new_table()",
        "array.push(tables, table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1))",
        "plot(1)"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.new_table(size, initial_value) → array<table>"],
      "returnedTypes": ["array<table>"]
    },
    {
      "name": "array.new_label",
      "desc": ["The function creates a new array object of label type elements."],
      "args": [
        {
          "name": "size",
          "desc": "Initial size of an array. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all array elements. Optional. The default is 'na'.",
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.new_label example\", overlay = true, max_labels_count = 500)",
        "",
        "//@variable The number of labels to show on the chart.",
        "int labelCount = input.int(50, \"Labels to show\", 1, 500)",
        "",
        "//@variable An array of `label` objects.",
        "var array<label> labelArray = array.new_label()",
        "",
        "//@variable A `chart.point` for the new label.",
        "labelPoint = chart.point.from_index(bar_index, close)",
        "//@variable The text in the new label.",
        "string labelText = na",
        "//@variable The color of the new label.",
        "color labelColor = na",
        "//@variable The style of the new label.",
        "string labelStyle = na",
        "",
        "// Set the label attributes for rising bars.",
        "if close > open",
        "    labelText  := \"Rising\"",
        "    labelColor := color.green",
        "    labelStyle := label.style_label_down",
        "// Set the label attributes for falling bars.",
        "else if close < open",
        "    labelText  := \"Falling\"",
        "    labelColor := color.red",
        "    labelStyle := label.style_label_up",
        "",
        "// Add a new label to the `labelArray` when the chart bar closed at a new value.",
        "if close != open",
        "    labelArray.push(label.new(labelPoint, labelText, color = labelColor, style = labelStyle))",
        "// Remove the first element and delete its label when the size of the `labelArray` exceeds the `labelCount`.",
        "if labelArray.size() > labelCount",
        "    label.delete(labelArray.shift())"
      ],
      "returns": ["The ID of an array object which may be used in other array.*() functions."],
      "remarks": ["An array index starts from 0."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.new_label(size, initial_value) → array<label>"],
      "returnedTypes": ["array<label>"]
    },
    {
      "name": "array.copy",
      "desc": ["The function creates a copy of an existing array."],
      "syntax": ["array.copy(id) → array<type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.copy example\")",
        "length = 5",
        "a = array.new_float(length, close)",
        "b = array.copy(a)",
        "a := array.new_float(length, open)",
        "plot(array.sum(a) / length)",
        "plot(array.sum(b) / length)"
      ],
      "returns": ["A copy of an array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ]
    },
    {
      "name": "array.slice",
      "desc": [
        "The function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays."
      ],
      "syntax": ["array.slice(id, index_from, index_to) → array<type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "index_from",
          "desc": "Zero-based index at which to begin extraction.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "index_to",
          "desc": "Zero-based index before which to end extraction. The function extracts up to but not including the element with this index.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.slice example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "// take elements from 0 to 4",
        "// *note that changes in slice also modify original array ",
        "slice = array.slice(a, 0, 5)",
        "plot(array.sum(a) / 10)",
        "plot(array.sum(slice) / 5)"
      ],
      "returns": ["A shallow copy of an array's slice."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ]
    },
    {
      "name": "array.size",
      "desc": ["The function returns the number of elements in an array."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.size example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "// note that changes in slice also modify original array",
        "slice = array.slice(a, 0, 5)",
        "array.push(slice, open)",
        "// size was changed in slice and in original array",
        "plot(array.size(a))",
        "plot(array.size(slice))"
      ],
      "returns": ["The number of elements in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.sum](#fun_array.sum)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "syntax": ["array.size(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.first",
      "desc": ["Returns the array's first element. Throws a runtime error if the array is empty."],
      "syntax": ["array.first(id) → series <type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.first example\")",
        "arr = array.new_int(3, 10)",
        "plot(array.first(arr))"
      ],
      "seeAlso": ["[array.last](#fun_array.last)", "[array.get](#fun_array.get)"]
    },
    {
      "name": "array.last",
      "desc": ["Returns the array's last element. Throws a runtime error if the array is empty."],
      "syntax": ["array.last(id) → series <type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.last example\")",
        "arr = array.new_int(3, 10)",
        "plot(array.last(arr))"
      ],
      "seeAlso": ["[array.first](#fun_array.first)", "[array.get](#fun_array.get)"]
    },
    {
      "name": "array.every",
      "desc": [
        "Returns [true](#const_true) if all elements of the `id` array are [true](#const_true), [false](#const_false) otherwise."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<bool>"],
          "displayType": "array<bool>"
        }
      ],
      "remarks": [
        "This function also works with arrays of [int](#type_int) and [float](#type_float) types, in which case zero values are considered [false](#const_false), and all others [true](#const_true)."
      ],
      "seeAlso": ["[array.some](#fun_array.some)", "[array.get](#fun_array.get)"],
      "syntax": ["array.every(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "array.some",
      "desc": [
        "Returns [true](#const_true) if at least one element of the `id` array is [true](#const_true), [false](#const_false) otherwise."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<bool>"],
          "displayType": "array<bool>"
        }
      ],
      "remarks": [
        "This function also works with arrays of [int](#type_int) and [float](#type_float) types, in which case zero values are considered [false](#const_false), and all others [true](#const_true)."
      ],
      "seeAlso": ["[array.every](#fun_array.every)", "[array.get](#fun_array.get)"],
      "syntax": ["array.some(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "array.get",
      "desc": ["The function returns the value of the element at the specified index."],
      "syntax": ["array.get(id, index) → series <type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "index",
          "desc": "The index of the element whose value is to be returned.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.get example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i] - open[i])",
        "plot(array.get(a, 9))"
      ],
      "returns": ["The array element's value."],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ]
    },
    {
      "name": "array.min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "nth",
          "desc": "The nth smallest value to return, where zero is the smallest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id, nth) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "nth",
          "desc": "The nth smallest value to return, where zero is the smallest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id, nth) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "nth",
          "desc": "The nth greatest value to return, where zero is the greatest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id, nth) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "nth",
          "desc": "The nth greatest value to return, where zero is the greatest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id, nth) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.range",
      "desc": [
        "The function returns the difference between the min and max values from a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.range example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.range(a))"
      ],
      "returns": ["The difference between the min and max values in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.range(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.range",
      "desc": [
        "The function returns the difference between the min and max values from a given array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.range example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.range(a))"
      ],
      "returns": ["The difference between the min and max values in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.range(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.sum",
      "desc": ["The function returns the sum of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.sum example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.sum(a))"
      ],
      "returns": ["The sum of the array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.sum(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.sum",
      "desc": ["The function returns the sum of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.sum example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.sum(a))"
      ],
      "returns": ["The sum of the array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.sum(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.set",
      "desc": ["The function sets the value of the element at the specified index."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "index",
          "desc": "The index of the element to be modified.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "value",
          "desc": "The new value to be set.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.set example\")",
        "a = array.new_float(10)",
        "for i = 0 to 9",
        "\tarray.set(a, i, close[i])",
        "plot(array.sum(a) / 10)"
      ],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.set(id, index, value) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "<arg..._type>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<bool>"],
      "returnedTypes": ["array<bool>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<string>"],
      "returnedTypes": ["array<string>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<label>"],
      "returnedTypes": ["array<label>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<line>"],
      "returnedTypes": ["array<line>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<color>"],
      "returnedTypes": ["array<color>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series enum"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<series enum>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<box>"],
      "returnedTypes": ["array<box>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<table>"],
      "returnedTypes": ["array<table>"]
    },
    {
      "name": "array.from",
      "desc": [
        "The function takes a variable number of arguments with one of the types: int, float, bool, string, label, line, color, box, table, linefill, and returns an array of the corresponding type."
      ],
      "args": [
        {
          "name": "arg0, arg1, ...",
          "desc": "Array arguments.",
          "required": true,
          "allowedTypeIDs": ["series linefill"],
          "displayType": "series linefill"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.from_example\", overlay = false)",
        "arr = array.from(\"Hello\", \"World!\") // arr (array<string>) will contain 2 elements: {Hello}, {World!}.",
        "plot(close)"
      ],
      "remarks": [
        "This function can accept up to 4,000 'int', 'float', 'bool', or 'color' arguments. For all other types, including user-defined types, the limit is 999."
      ],
      "returns": ["The array element's value."],
      "syntax": ["array.from(arg0, arg1, ...) → array<linefill>"],
      "returnedTypes": ["array<linefill>"]
    },
    {
      "name": "array.fill",
      "desc": [
        "The function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "value",
          "desc": "Value to fill the array with.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        },
        {
          "name": "index_from",
          "desc": "Start index, default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "index_to",
          "desc": "End index, default is na. Must be one greater than the index of the last element to set.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.fill example\")",
        "a = array.new_float(10)",
        "array.fill(a, close)",
        "plot(array.sum(a))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.fill(id, value, index_from, index_to) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.insert",
      "desc": ["The function changes the contents of an array by adding new elements in place."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "index",
          "desc": "The index at which to insert the value.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "value",
          "desc": "The value to add to the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.insert example\")",
        "a = array.new_float(5, close)",
        "array.insert(a, 0, open)",
        "plot(array.get(a, 5))"
      ],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)",
        "[array.unshift](#fun_array.unshift)"
      ],
      "syntax": ["array.insert(id, index, value) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.join",
      "desc": [
        "The function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>", "array<string>"],
          "displayType": "array<int/float/string>"
        },
        {
          "name": "separator",
          "desc": "The string used to separate each array element.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.join example\")",
        "a = array.new_float(5, 5)",
        "label.new(bar_index, close, array.join(a, \",\"))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.insert](#fun_array.insert)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)",
        "[array.unshift](#fun_array.unshift)"
      ],
      "syntax": ["array.join(id, separator) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "array.push",
      "desc": ["The function appends a value to an array."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "value",
          "desc": "The value of the element added to the end of the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.push example\")",
        "a = array.new_float(5, 0)",
        "array.push(a, open)",
        "plot(array.get(a, 5))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.insert](#fun_array.insert)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)",
        "[array.unshift](#fun_array.unshift)"
      ],
      "syntax": ["array.push(id, value) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.remove",
      "desc": [
        "The function changes the contents of an array by removing the element with the specified index."
      ],
      "syntax": ["array.remove(id, index) → series <type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "index",
          "desc": "The index of the element to remove.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.remove example\")",
        "a = array.new_float(5,high)",
        "removedEl = array.remove(a, 0)",
        "plot(array.size(a))",
        "plot(removedEl)"
      ],
      "returns": ["The value of the removed element."],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.insert](#fun_array.insert)",
        "[array.pop](#fun_array.pop)",
        "[array.shift](#fun_array.shift)"
      ]
    },
    {
      "name": "array.pop",
      "desc": ["The function removes the last element from an array and returns its value."],
      "syntax": ["array.pop(id) → series <type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.pop example\")",
        "a = array.new_float(5,high)",
        "removedEl = array.pop(a)",
        "plot(array.size(a))",
        "plot(removedEl)"
      ],
      "returns": ["The value of the removed element."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)",
        "[array.shift](#fun_array.shift)"
      ]
    },
    {
      "name": "array.clear",
      "desc": ["The function removes all elements from an array."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.clear example\")",
        "a = array.new_float(5,high)",
        "array.clear(a)",
        "array.push(a, close)",
        "plot(array.get(a,0))",
        "plot(array.size(a))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)"
      ],
      "syntax": ["array.clear(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.sort",
      "desc": ["The function sorts the elements of an array."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>", "array<string>"],
          "displayType": "array<int/float/string>"
        },
        {
          "name": "order",
          "desc": "The sort order: order.ascending (default) or order.descending.",
          "allowedTypeIDs": [
            "series sort_order",
            "simple sort_order",
            "input sort_order",
            "const sort_order"
          ],
          "displayType": "series sort_order"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.sort example\")",
        "a = array.new_float(0,0)",
        "for i = 0 to 5",
        "\tarray.push(a, high[i])",
        "array.sort(a, order.descending)",
        "if barstate.islast",
        "\tlabel.new(bar_index, close, str.tostring(a))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.sort(id, order) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.sort_indices",
      "desc": [
        "Returns an array of indices which, when used to index the original array, will access its elements in their sorted order. It does not modify the original array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>", "array<string>"],
          "displayType": "array<int/float/string>"
        },
        {
          "name": "order",
          "desc": "The sort order: order.ascending or order.descending. Optional. The default is order.ascending.",
          "allowedTypeIDs": [
            "series sort_order",
            "simple sort_order",
            "input sort_order",
            "const sort_order"
          ],
          "displayType": "series sort_order"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.sort_indices\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "sortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]",
        "indexOfSmallestValue = array.get(sortedIndices, 0) // 1",
        "smallestValue = array.get(a, indexOfSmallestValue) // -2",
        "plot(smallestValue)"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.sort_indices(id, order) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "array.percentrank",
      "desc": ["Returns the percentile rank of the element at the specified `index`."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "index",
          "desc": "The index of the element for which the percentile rank should be calculated.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "remarks": [
        "Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentrank(id, index) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.percentrank",
      "desc": ["Returns the percentile rank of the element at the specified `index`."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "index",
          "desc": "The index of the element for which the percentile rank should be calculated.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "remarks": [
        "Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentrank(id, index) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.percentile_nearest_rank",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_nearest_rank(id, percentage) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.percentile_nearest_rank",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_nearest_rank(id, percentage) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.percentile_linear_interpolation",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring. Linear interpolation estimates the value between two ranks."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_linear_interpolation(id, percentage) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.percentile_linear_interpolation",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring. Linear interpolation estimates the value between two ranks."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_linear_interpolation(id, percentage) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.abs",
      "desc": [
        "Returns an array containing the absolute value of each element in the original array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.abs(id) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "array.abs",
      "desc": [
        "Returns an array containing the absolute value of each element in the original array."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.abs(id) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "array.binary_search",
      "desc": [
        "The function returns the index of the value, or -1 if the value is not found. The array to search must be sorted in ascending order."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "val",
          "desc": "The value to search for in the array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.binary_search\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "array.sort(a) // [-2, 0, 1, 5, 9]",
        "position = array.binary_search(a, 0) // 1",
        "plot(position)"
      ],
      "remarks": [
        "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.binary_search(id, val) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.binary_search_leftmost",
      "desc": [
        "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the next smallest element to the left of where the value would lie if it was in the array. The array to search must be sorted in ascending order."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "val",
          "desc": "The value to search for in the array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_leftmost\")",
            "a = array.from(5, -2, 0, 9, 1)",
            "array.sort(a) // [-2, 0, 1, 5, 9]",
            "position = array.binary_search_leftmost(a, 3) // 2",
            "plot(position)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_leftmost, repetitive elements\")",
            "a = array.from(4, 5, 5, 5)",
            "// Returns the index of the first instance.",
            "position = array.binary_search_leftmost(a, 5) ",
            "plot(position) // Plots 1"
          ]
        }
      ],
      "remarks": [
        "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.binary_search_leftmost(id, val) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.binary_search_rightmost",
      "desc": [
        "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the element to the right of where the value would lie if it was in the array. The array must be sorted in ascending order."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "val",
          "desc": "The value to search for in the array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_rightmost\")",
            "a = array.from(5, -2, 0, 9, 1)",
            "array.sort(a) // [-2, 0, 1, 5, 9]",
            "position = array.binary_search_rightmost(a, 3) // 3",
            "plot(position)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_rightmost, repetitive elements\")",
            "a = array.from(4, 5, 5, 5)",
            "// Returns the index of the last instance.",
            "position = array.binary_search_rightmost(a, 5) ",
            "plot(position) // Plots 3"
          ]
        }
      ],
      "remarks": [
        "A binary search works on sorted arrays in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.binary_search_rightmost(id, val) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.concat",
      "desc": [
        "The function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array."
      ],
      "syntax": ["array.concat(id1, id2) → array<type>"],
      "args": [
        {
          "name": "id1",
          "desc": "The first array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "id2",
          "desc": "The second array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.concat example\")",
        "a = array.new_float(0,0)",
        "b = array.new_float(0,0)",
        "for i = 0 to 4",
        "    array.push(a, high[i])",
        "    array.push(b, low[i])",
        "c = array.concat(a,b)",
        "plot(array.size(a))",
        "plot(array.size(b))",
        "plot(array.size(c))"
      ],
      "returns": ["The first array with merged elements from the second array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice),"
      ]
    },
    {
      "name": "array.avg",
      "desc": ["The function returns the mean of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.avg example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.avg(a))"
      ],
      "returns": ["Mean of array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.avg(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.avg",
      "desc": ["The function returns the mean of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.avg example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.avg(a))"
      ],
      "returns": ["Mean of array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.avg(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.stdev",
      "desc": ["The function returns the standard deviation of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.stdev example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.stdev(a))"
      ],
      "returns": ["The standard deviation of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)"
      ],
      "syntax": ["array.stdev(id, biased) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.stdev",
      "desc": ["The function returns the standard deviation of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.stdev example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.stdev(a))"
      ],
      "returns": ["The standard deviation of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)"
      ],
      "syntax": ["array.stdev(id, biased) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.variance",
      "desc": ["The function returns the variance of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.variance example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.variance(a))"
      ],
      "returns": ["The variance of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.stdev](#fun_array.stdev)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)",
        "[array.covariance](#fun_array.covariance)"
      ],
      "syntax": ["array.variance(id, biased) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.variance",
      "desc": ["The function returns the variance of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.variance example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.variance(a))"
      ],
      "returns": ["The variance of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.stdev](#fun_array.stdev)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)",
        "[array.covariance](#fun_array.covariance)"
      ],
      "syntax": ["array.variance(id, biased) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.covariance",
      "desc": ["The function returns the covariance of two arrays."],
      "args": [
        {
          "name": "id1",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "id2",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.covariance example\")",
        "a = array.new_float(0)",
        "b = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "\tarray.push(b, open[i])",
        "plot(array.covariance(a, b))"
      ],
      "returns": ["The covariance of two arrays."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.stdev](#fun_array.stdev)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)"
      ],
      "syntax": ["array.covariance(id1, id2, biased) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.mode",
      "desc": [
        "The function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.mode example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.mode(a))"
      ],
      "returns": [
        "The most frequently occurring value from the `id` array. If none exists, returns the smallest value instead."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[ta.mode](#fun_ta.mode)",
        "[matrix.mode](#fun_matrix.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.mode(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.mode",
      "desc": [
        "The function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.mode example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.mode(a))"
      ],
      "returns": [
        "The most frequently occurring value from the `id` array. If none exists, returns the smallest value instead."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[ta.mode](#fun_ta.mode)",
        "[matrix.mode](#fun_matrix.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.mode(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.median",
      "desc": ["The function returns the median of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.median example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.median(a))"
      ],
      "returns": ["The median of the array's elements."],
      "seeAlso": [
        "[array.median](#fun_array.median)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.median(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "array.median",
      "desc": ["The function returns the median of an array's elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.median example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.median(a))"
      ],
      "returns": ["The median of the array's elements."],
      "seeAlso": [
        "[array.median](#fun_array.median)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.median(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.standardize",
      "desc": ["The function returns the array of standardized elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.standardize example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "b = array.standardize(a)",
        "plot(array.min(b))",
        "plot(array.max(b))"
      ],
      "returns": ["The array of standardized elements."],
      "seeAlso": [
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.mode](#fun_array.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.standardize(id) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "array.standardize",
      "desc": ["The function returns the array of standardized elements."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.standardize example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "b = array.standardize(a)",
        "plot(array.min(b))",
        "plot(array.max(b))"
      ],
      "returns": ["The array of standardized elements."],
      "seeAlso": [
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.mode](#fun_array.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.standardize(id) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "array.indexof",
      "desc": [
        "The function returns the index of the first occurrence of the value, or -1 if the value is not found."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "value",
          "desc": "The value to search in the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.indexof example\")",
        "a = array.new_float(5,high)",
        "index = array.indexof(a, high)",
        "plot(index)"
      ],
      "returns": ["The index of an element."],
      "seeAlso": [
        "[array.lastindexof](#fun_array.lastindexof)",
        "[array.get](#fun_array.get)",
        "[array.lastindexof](#fun_array.lastindexof)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)"
      ],
      "syntax": ["array.indexof(id, value) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.lastindexof",
      "desc": [
        "The function returns the index of the last occurrence of the value, or -1 if the value is not found."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "value",
          "desc": "The value to search in the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.lastindexof example\")",
        "a = array.new_float(5,high)",
        "index = array.lastindexof(a, high)",
        "plot(index)"
      ],
      "returns": ["The index of an element."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)"
      ],
      "syntax": ["array.lastindexof(id, value) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "array.includes",
      "desc": ["The function returns true if the value was found in an array, false otherwise."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "value",
          "desc": "The value to search in the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.includes example\")",
        "a = array.new_float(5,high)",
        "p = close",
        "if array.includes(a, high)",
        "\tp := open",
        "plot(p)"
      ],
      "returns": ["True if the value was found in the array, false otherwise."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.indexof](#fun_array.indexof)",
        "[array.shift](#fun_array.shift)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)"
      ],
      "syntax": ["array.includes(id, value) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "array.shift",
      "desc": ["The function removes an array's first element and returns its value."],
      "syntax": ["array.shift(id) → series <type>"],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.shift example\")",
        "a = array.new_float(5,high)",
        "removedEl = array.shift(a)",
        "plot(array.size(a))",
        "plot(removedEl)"
      ],
      "returns": ["The value of the removed element."],
      "seeAlso": [
        "[array.unshift](#fun_array.unshift)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.includes](#fun_array.includes)"
      ]
    },
    {
      "name": "array.unshift",
      "desc": ["The function inserts the value at the beginning of the array."],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        },
        {
          "name": "value",
          "desc": "The value to add to the start of the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.unshift example\")",
        "a = array.new_float(5, 0)",
        "array.unshift(a, open)",
        "plot(array.get(a, 0))"
      ],
      "seeAlso": [
        "[array.shift](#fun_array.shift)",
        "[array.set](#fun_array.set)",
        "[array.insert](#fun_array.insert)",
        "[array.remove](#fun_array.remove)",
        "[array.indexof](#fun_array.indexof)"
      ],
      "syntax": ["array.unshift(id, value) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "array.reverse",
      "desc": [
        "The function reverses an array. The first array element becomes the last, and the last array element becomes the first."
      ],
      "args": [
        {
          "name": "id",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.reverse example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.get(a, 0))",
        "array.reverse(a)",
        "plot(array.get(a, 0))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.sort](#fun_array.sort)",
        "[array.push](#fun_array.push)",
        "[array.set](#fun_array.set)",
        "[array.avg](#fun_array.avg)"
      ],
      "syntax": ["array.reverse(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "alert",
      "desc": [
        "Creates an alert trigger for an indicator or strategy, with a specified frequency, when called on the latest realtime bar. To activate alerts for a script containing calls to this function, open the \"Create Alert\" dialog box, then select the script name and \"Any alert() function call\" in the \"Condition\" section."
      ],
      "args": [
        {
          "name": "message",
          "desc": "The message to send when the alert occurs.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "freq",
          "desc": "Optional. Determines the allowed frequency of the alert trigger. Possible values are: [alert.freq_all](#const_alert.freq_all) (allows an alert on any realtime update), [alert.freq_once_per_bar](#const_alert.freq_once_per_bar) (allows an alert only on the first execution for each realtime bar), or [alert.freq_once_per_bar_close](#const_alert.freq_once_per_bar_close) (allows an alert only when a realtime bar closes). The default is [alert.freq_once_per_bar](#const_alert.freq_once_per_bar).",
          "allowedTypeIDs": ["input string", "const string"],
          "displayType": "input string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`alert()` example\", \"\", true)",
        "ma = ta.sma(close, 14)",
        "xUp = ta.crossover(close, ma)",
        "if xUp",
        "    // Trigger the alert the first time a cross occurs during the real-time bar.",
        "    alert(\"Price (\" + str.tostring(close) + \") crossed over MA (\" + str.tostring(ma) + \").\", alert.freq_once_per_bar)",
        "plot(ma)",
        "plotchar(xUp, \"xUp\", \"▲\", location.top, size = size.tiny)"
      ],
      "remarks": [
        "The `alert()` function does not display information on the chart.",
        "In contrast to [alertcondition](#fun_alertcondition), calls to this function do not count toward a script's plot count. Additionally, `alert()` calls are allowed in local scopes, including the scopes of exported library functions.",
        "See [this article](https://www.tradingview.com/chart/?solution=43000597494) in our Help Center to learn more about activating alerts from `alert()` calls."
      ],
      "seeAlso": ["[alertcondition](#fun_alertcondition)"],
      "syntax": ["alert(message, freq) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "request.earnings",
      "desc": ["Requests earnings data for the specified symbol."],
      "args": [
        {
          "name": "ticker",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\". Using [syminfo.ticker](#var_syminfo.ticker) will cause an error. Use [syminfo.tickerid](#var_syminfo.tickerid) instead.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "field",
          "desc": "Input string. Possible values include: [earnings.actual](#const_earnings.actual), [earnings.estimate](#const_earnings.estimate), [earnings.standardized](#const_earnings.standardized). Default value is [earnings.actual](#const_earnings.actual).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "gaps",
          "desc": "Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: [barmerge.gaps_on](#const_barmerge.gaps_on), [barmerge.gaps_off](#const_barmerge.gaps_off). [barmerge.gaps_on](#const_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#const_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "lookahead",
          "desc": "Merge strategy for the requested data position. Possible values: [barmerge.lookahead_on](#const_barmerge.lookahead_on), [barmerge.lookahead_off](#const_barmerge.lookahead_off). Default value is [barmerge.lookahead_off](#const_barmerge.lookahead_off) starting from version 3. Note that behavour is the same on real-time, and differs only on history.",
          "allowedTypeIDs": [
            "simple barmerge_lookahead",
            "input barmerge_lookahead",
            "const barmerge_lookahead"
          ],
          "displayType": "simple barmerge_lookahead"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "currency",
          "desc": "Currency into which the symbol's currency-related earnings values (e.g. [earnings.actual](#const_earnings.actual)) are to be converted. The conversion rate depends on the previous daily value of a corresponding currency pair from the most popular exchange. A spread symbol is used if no exchange provides the rate directly. Possible values: a \"string\" representing a valid currency code (e.g., \"USD\" or \"USDT\") or a constant from the `currency.*` namespace (e.g., [currency.USD](#const_currency.USD) or [currency.USDT](#const_currency.USDT)). The default is [syminfo.currency](#var_syminfo.currency).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"request.earnings\")",
        "s1 = request.earnings(\"NASDAQ:BELFA\")",
        "plot(s1)",
        "s2 = request.earnings(\"NASDAQ:BELFA\", earnings.actual, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)",
        "plot(s2)"
      ],
      "returns": [
        "Requested series, or n/a if there is no earnings data for the specified symbol."
      ],
      "seeAlso": [
        "[request.dividends](#fun_request.dividends)",
        "[request.splits](#fun_request.splits)",
        "[request.security](#fun_request.security)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ],
      "syntax": [
        "request.earnings(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float"
      ],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.dividends",
      "desc": ["Requests dividends data for the specified symbol."],
      "args": [
        {
          "name": "ticker",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\". Using [syminfo.ticker](#var_syminfo.ticker) will cause an error. Use [syminfo.tickerid](#var_syminfo.tickerid) instead.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "field",
          "desc": "Input string. Possible values include: [dividends.net](#const_dividends.net), [dividends.gross](#const_dividends.gross). Default value is [dividends.gross](#const_dividends.gross).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "gaps",
          "desc": "Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: [barmerge.gaps_on](#const_barmerge.gaps_on), [barmerge.gaps_off](#const_barmerge.gaps_off). [barmerge.gaps_on](#const_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#const_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "lookahead",
          "desc": "Merge strategy for the requested data position. Possible values: [barmerge.lookahead_on](#const_barmerge.lookahead_on), [barmerge.lookahead_off](#const_barmerge.lookahead_off). Default value is [barmerge.lookahead_off](#const_barmerge.lookahead_off) starting from version 3. Note that behavour is the same on real-time, and differs only on history.",
          "allowedTypeIDs": [
            "simple barmerge_lookahead",
            "input barmerge_lookahead",
            "const barmerge_lookahead"
          ],
          "displayType": "simple barmerge_lookahead"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "currency",
          "desc": "Currency into which the symbol's currency-related dividends values (e.g. [dividends.gross](#const_dividends.gross)) are to be converted. The conversion rate depends on the previous daily value of a corresponding currency pair from the most popular exchange. A spread symbol is used if no exchange provides the rate directly. Possible values: a \"string\" representing a valid currency code (e.g., \"USD\" or \"USDT\") or a constant from the `currency.*` namespace (e.g., [currency.USD](#const_currency.USD) or [currency.USDT](#const_currency.USDT)). The default is [syminfo.currency](#var_syminfo.currency).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"request.dividends\")",
        "s1 = request.dividends(\"NASDAQ:BELFA\")",
        "plot(s1)",
        "s2 = request.dividends(\"NASDAQ:BELFA\", dividends.net, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)",
        "plot(s2)"
      ],
      "returns": [
        "Requested series, or n/a if there is no dividends data for the specified symbol."
      ],
      "seeAlso": [
        "[request.earnings](#fun_request.earnings)",
        "[request.splits](#fun_request.splits)",
        "[request.security](#fun_request.security)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ],
      "syntax": [
        "request.dividends(ticker, field, gaps, lookahead, ignore_invalid_symbol, currency) → series float"
      ],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.splits",
      "desc": ["Requests splits data for the specified symbol."],
      "args": [
        {
          "name": "ticker",
          "desc": "Symbol. Note that the symbol should be passed with a prefix. For example: \"NASDAQ:AAPL\" instead of \"AAPL\". Using [syminfo.ticker](#var_syminfo.ticker) will cause an error. Use [syminfo.tickerid](#var_syminfo.tickerid) instead.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "field",
          "desc": "Input string. Possible values include: [splits.denominator](#const_splits.denominator), [splits.numerator](#const_splits.numerator).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "gaps",
          "desc": "Merge strategy for the requested data (requested data automatically merges with the main series OHLC data). Possible values: [barmerge.gaps_on](#const_barmerge.gaps_on), [barmerge.gaps_off](#const_barmerge.gaps_off). [barmerge.gaps_on](#const_barmerge.gaps_on) - requested data is merged with possible gaps ([na](#var_na) values). [barmerge.gaps_off](#const_barmerge.gaps_off) - requested data is merged continuously without gaps, all the gaps are filled with the previous nearest existing values. Default value is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "lookahead",
          "desc": "Merge strategy for the requested data position. Possible values: [barmerge.lookahead_on](#const_barmerge.lookahead_on), [barmerge.lookahead_off](#const_barmerge.lookahead_off). Default value is [barmerge.lookahead_off](#const_barmerge.lookahead_off) starting from version 3. Note that behavour is the same on real-time, and differs only on history.",
          "allowedTypeIDs": [
            "simple barmerge_lookahead",
            "input barmerge_lookahead",
            "const barmerge_lookahead"
          ],
          "displayType": "simple barmerge_lookahead"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "An optional parameter. Determines the behavior of the function if the specified symbol is not found: if false, the script will halt and return a runtime error; if true, the function will return na and execution will continue. The default value is false.",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"request.splits\")",
        "s1 = request.splits(\"NASDAQ:BELFA\", splits.denominator)",
        "plot(s1)",
        "s2 = request.splits(\"NASDAQ:BELFA\", splits.denominator, gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_on)",
        "plot(s2)"
      ],
      "returns": ["Requested series, or n/a if there is no splits data for the specified symbol."],
      "seeAlso": [
        "[request.earnings](#fun_request.earnings)",
        "[request.dividends](#fun_request.dividends)",
        "[request.security](#fun_request.security)",
        "[syminfo.tickerid](#var_syminfo.tickerid)"
      ],
      "syntax": [
        "request.splits(ticker, field, gaps, lookahead, ignore_invalid_symbol) → series float"
      ],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.economic",
      "desc": [
        "Requests economic data for a symbol. Economic data includes information such as the state of a country's economy (GDP, inflation rate, etc.) or of a particular industry (steel production, ICU beds, etc.)."
      ],
      "args": [
        {
          "name": "country_code",
          "desc": "The code of the country (e.g. \"US\") or the region (e.g. \"EU\") for which the economic data is requested. The [Help Center article](https://www.tradingview.com/chart/?solution=43000665359) lists the countries and their codes. The countries for which information is available vary with metrics. The [Help Center article for each metric](https://www.tradingview.com/support/folders/43000581956-list-of-available-economic-indicators/) lists the countries for which the metric is available.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "field",
          "desc": "The code of the requested economic metric (e.g., \"GDP\"). The [Help Center article](https://www.tradingview.com/chart/?solution=43000665359) lists the metrics and their codes.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "gaps",
          "desc": "Specifies how the returned values are merged on chart bars. Possible values: [barmerge.gaps_off](#const_barmerge.gaps_off), [barmerge.gaps_on](#const_barmerge.gaps_on). With [barmerge.gaps_on](#const_barmerge.gaps_on), a value only appears on the current chart bar when it first becomes available from the function's context, otherwise [na](#var_na) is returned (thus a \"gap\" occurs). With [barmerge.gaps_off](#const_barmerge.gaps_off), what would otherwise be gaps are filled with the latest known value returned, avoiding [na](#var_na) values. Optional. The default is [barmerge.gaps_off](#const_barmerge.gaps_off).",
          "allowedTypeIDs": ["simple barmerge_gaps", "input barmerge_gaps", "const barmerge_gaps"],
          "displayType": "simple barmerge_gaps"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#const_false), the script will halt and return a runtime error; if [true](#const_true), the function will return [na](#var_na) and execution will continue. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"US GDP\")",
        "e = request.economic(\"US\", \"GDP\")",
        "plot(e)"
      ],
      "returns": ["Requested series."],
      "remarks": [
        "Economic data can also be accessed from charts, just like a regular symbol. Use \"ECONOMIC\" as the exchange name and `{country_code}{field}` as the ticker. The name of US GDP data is thus \"ECONOMIC:USGDP\"."
      ],
      "seeAlso": ["[request.financial](#fun_request.financial)"],
      "syntax": [
        "request.economic(country_code, field, gaps, ignore_invalid_symbol) → series float"
      ],
      "returnedTypes": ["series float"]
    },
    {
      "name": "request.seed",
      "desc": [
        "Requests data from a user-maintained GitHub repository and returns it as a series. An in-depth tutorial on how to add new data can be found [here](https://github.com/tradingview-eod/pine-seeds-docs)."
      ],
      "args": [
        {
          "name": "source",
          "desc": "Name of the GitHub repository.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "symbol",
          "desc": "Name of the file in the GitHub repository containing the data. The \".csv\" file extension must not be included.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "expression",
          "desc": "An expression to be calculated and returned from the requested symbol's context. It can be a built-in variable like [close](#var_close), an expression such as `ta.sma(close, 100)`, a non-mutable variable previously calculated in the script, a function call that does not use Pine Script® drawings, an array, a matrix, or a tuple. Mutable variables are not allowed, unless they are enclosed in the body of a function used in the expression.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "<arg_expr_type>"
        },
        {
          "name": "ignore_invalid_symbol",
          "desc": "Determines the behavior of the function if the specified symbol is not found: if [false](#const_false), the script will halt and throw a runtime error; if [true](#const_true), the function will return [na](#var_na) and execution will continue. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["input bool", "const bool"],
          "displayType": "input bool"
        },
        {
          "name": "calc_bars_count",
          "desc": "If specified, the function will only request this number of values from the end of the symbol's history and calculate `expression` as if these values are the only available data, which might improve calculation speed in some cases. Optional. The default is 100,000, which is the limit for all non-professional TradingView plans.",
          "allowedTypeIDs": ["simple int", "input int", "const int"],
          "displayType": "simple int"
        }
      ],
      "returns": ["Requested series or tuple of series, which may include array/matrix IDs."],
      "examples": [
        "//@version=6",
        "indicator(\"BTC Development Activity\")",
        "",
        "[devAct, devActSMA] = request.seed(\"seed_crypto_santiment\", \"BTC_DEV_ACTIVITY\", [close, ta.sma(close, 10)])",
        "",
        "plot(devAct, \"BTC Development Activity\")",
        "plot(devActSMA, \"BTC Development Activity SMA10\", color = color.yellow)"
      ],
      "syntax": [
        "request.seed(source, symbol, expression, ignore_invalid_symbol, calc_bars_count) → series <type>"
      ]
    },
    {
      "name": "table.new",
      "desc": ["The function creates a new table."],
      "args": [
        {
          "name": "position",
          "desc": "Position of the table. Possible values are: [position.top_left](#const_position.top_left), [position.top_center](#const_position.top_center), [position.top_right](#const_position.top_right), [position.middle_left](#const_position.middle_left), [position.middle_center](#const_position.middle_center), [position.middle_right](#const_position.middle_right), [position.bottom_left](#const_position.bottom_left), [position.bottom_center](#const_position.bottom_center), [position.bottom_right](#const_position.bottom_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "columns",
          "desc": "The number of columns in the table.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "rows",
          "desc": "The number of rows in the table.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "bgcolor",
          "desc": "The background color of the table. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "frame_color",
          "desc": "The color of the outer frame of the table. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "frame_width",
          "desc": "The width of the outer frame of the table. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "border_color",
          "desc": "The color of the borders of the cells (excluding the outer frame). Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "border_width",
          "desc": "The width of the borders of the cells (excluding the outer frame). Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"table.new example\")",
        "var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)",
        "if barstate.islast",
        "    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))",
        "    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)"
      ],
      "returns": ["The ID of a table object that can be passed to other table.*() functions."],
      "remarks": [
        "This function creates the table object itself, but the table will not be displayed until its cells are populated. To define a cell and change its contents or attributes, use [table.cell](#fun_table.cell) and other table.cell_*() functions.",
        "One [table.new](#fun_table.new) call can only display one table (the last one drawn), but the function itself will be recalculated on each bar it is used on. For performance reasons, it is wise to use [table.new](#fun_table.new) in conjunction with either the [var](#kw_var) keyword (so the table object is only created on the first bar) or in an [if](#kw_if) [barstate.islast](#var_barstate.islast) block (so the table object is only created on the last bar)."
      ],
      "seeAlso": [
        "[table.cell](#fun_table.cell)",
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": [
        "table.new(position, columns, rows, bgcolor, frame_color, frame_width, border_color, border_width, force_overlay) → series table"
      ],
      "returnedTypes": ["series table"]
    },
    {
      "name": "table.delete",
      "desc": ["The function deletes a table."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"table.delete example\")",
        "var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)",
        "if barstate.islast",
        "    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))",
        "    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)",
        "if barstate.isrealtime",
        "    table.delete(testTable)"
      ],
      "seeAlso": ["[table.new](#fun_table.new)", "[table.clear](#fun_table.clear)"],
      "syntax": ["table.delete(table_id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.set_position",
      "desc": ["The function sets the position of a table."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "position",
          "desc": "Position of the table. Possible values are: [position.top_left](#const_position.top_left), [position.top_center](#const_position.top_center), [position.top_right](#const_position.top_right), [position.middle_left](#const_position.middle_left), [position.middle_center](#const_position.middle_center), [position.middle_right](#const_position.middle_right), [position.bottom_left](#const_position.bottom_left), [position.bottom_center](#const_position.bottom_center), [position.bottom_right](#const_position.bottom_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)"
      ],
      "syntax": ["table.set_position(table_id, position) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.set_bgcolor",
      "desc": ["The function sets the background color of a table."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "bgcolor",
          "desc": "The background color of the table. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_bgcolor(table_id, bgcolor) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.set_frame_color",
      "desc": ["The function sets the color of the outer frame of a table."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "frame_color",
          "desc": "The color of the frame of the table. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_frame_color(table_id, frame_color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.set_border_color",
      "desc": [
        "The function sets the color of the borders (excluding the outer frame) of the table's cells."
      ],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "border_color",
          "desc": "The color of the borders. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_border_color(table_id, border_color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.set_frame_width",
      "desc": ["The function set the width of the outer frame of a table."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "frame_width",
          "desc": "The width of the outer frame of the table. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_frame_width(table_id, frame_width) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.set_border_width",
      "desc": [
        "The function sets the width of the borders (excluding the outer frame) of the table's cells."
      ],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "border_width",
          "desc": "The width of the borders. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_border_width(table_id, border_width) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell",
      "desc": ["The function defines a cell in the table and sets its attributes."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the cell. Optional. The default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "width",
          "desc": "The width of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the width based on the text inside the cell. Value 0 has the same effect.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "height",
          "desc": "The height of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell. Value 0 has the same effect.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "text_color",
          "desc": "The color of the text. Optional. The default is [color.black](#const_color.black).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of the cell's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the cell's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_size",
          "desc": "Size of the object. The size can be any positive integer, or one of the size.* built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36). The default value is [size.normal](#const_size.normal) or 14.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        },
        {
          "name": "bgcolor",
          "desc": "The background color of the text. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "tooltip",
          "desc": "The tooltip to be displayed inside the cell. Optional.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Optional. The default value is [font.family_default](#const_font.family_default). Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "remarks": [
        "This function does not create the table itself, but defines the table’s cells. To use it, you first need to create a table object with [table.new](#fun_table.new).",
        "Each [table.cell](#fun_table.cell) call overwrites all previously defined properties of a cell. If you call [table.cell](#fun_table.cell) twice in a row, e.g., the first time with text='Test Text', and the second time with text_color=[color.red](#const_color.red) but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string. If you want, instead, to modify any of the cell's properties, use the table.cell_set_*() functions.",
        "A single script can only display one table in each of the possible locations. If [table.cell](#fun_table.cell) is used on several bars to change the same attribute of a cell (e.g. change the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell’s background will be yellow. Avoid unnecessary setting of cell properties by enclosing function calls in an [if](#kw_if) [barstate.islast](#var_barstate.islast) block whenever possible, to restrict their execution to the last bar of the series."
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_formatting](#fun_table.cell_set_text_formatting)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": [
        "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family, text_formatting) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text",
      "desc": ["The function sets the text in the specified cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the cell.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"TABLE example\")",
        "var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)",
        "table.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)",
        "table.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")"
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)",
        "[table.cell_set_text_formatting](#fun_table.cell_set_text_formatting)"
      ],
      "syntax": ["table.cell_set_text(table_id, column, row, text) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text_formatting",
      "desc": ["Sets the formatting attributes the drawing applies to displayed text."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "required": true,
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)",
        "[table.cell_set_text](#fun_table.cell_set_text)"
      ],
      "syntax": ["table.cell_set_text_formatting(table_id, column, row, text_formatting) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text_font_family",
      "desc": ["The function sets the font family of the text inside the cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Example of setting the table cell font\")",
        "var t = table.new(position.top_left, rows = 1, columns = 1)",
        "table.cell(t, 0, 0, \"monospace\", text_color = color.blue)",
        "table.cell_set_text_font_family(t, 0, 0, font.family_monospace)"
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[font.family_default](#const_font.family_default)",
        "[font.family_monospace](#const_font.family_monospace)"
      ],
      "syntax": ["table.cell_set_text_font_family(table_id, column, row, text_font_family) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_tooltip",
      "desc": ["The function sets the tooltip in the specified cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "tooltip",
          "desc": "The tooltip to be displayed inside the cell.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"TABLE example\")",
        "var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)",
        "table.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)",
        "table.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")"
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_text](#fun_table.cell_set_text)"
      ],
      "syntax": ["table.cell_set_tooltip(table_id, column, row, tooltip) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_width",
      "desc": ["The function sets the width of the cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "width",
          "desc": "The width of the cell as a % of the chart window. Passing 0 auto-adjusts the width based on the text inside of the cell.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_width(table_id, column, row, width) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_height",
      "desc": ["The function sets the height of cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "height",
          "desc": "The height of the cell as a % of the chart window. Passing 0 auto-adjusts the height based on the text inside of the cell.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_height(table_id, column, row, height) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text_color",
      "desc": ["The function sets the color of the text inside the cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_color",
          "desc": "The color of the text.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_color(table_id, column, row, text_color) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text_halign",
      "desc": ["The function sets the horizontal alignment of the cell's text."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of a cell's text. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_halign(table_id, column, row, text_halign) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text_valign",
      "desc": ["The function sets the vertical alignment of a cell's text."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the cell's text. Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_valign(table_id, column, row, text_valign) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_text_size",
      "desc": ["The function sets the size of the cell's text."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_size",
          "desc": "Size of the object. The size can be any positive integer, or one of the size.* built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36). The default value is [size.normal](#const_size.normal) or 14.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_size(table_id, column, row, text_size) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.cell_set_bgcolor",
      "desc": ["The function sets the background color of the cell."],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "bgcolor",
          "desc": "The background color of the cell.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_bgcolor(table_id, column, row, bgcolor) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "table.clear",
      "desc": [
        "The function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner."
      ],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "start_column",
          "desc": "The index of the column of the first cell to delete. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "start_row",
          "desc": "The index of the row of the first cell to delete. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_column",
          "desc": "The index of the column of the last cell to delete. Optional. The default is the argument used for start_column. Numbering starts at 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_row",
          "desc": "The index of the row of the last cell to delete. Optional. The default is the argument used for start_row. Numbering starts at 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"A donut\", overlay=true)",
        "if barstate.islast",
        "    colNum = 8, rowNum = 8",
        "    padding = \"◯\"",
        "    donutTable = table.new(position.middle_right, colNum, rowNum)",
        "    for c = 0 to colNum - 1",
        "        for r = 0 to rowNum - 1",
        "            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))",
        "    table.clear(donutTable, 2, 2, 5, 5)"
      ],
      "seeAlso": ["[table.delete](#fun_table.delete)", "[table.new](#fun_table.new)"],
      "syntax": ["table.clear(table_id, start_column, start_row, end_column, end_row) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.new<type>",
      "desc": [
        "The function creates a new matrix object. A matrix is a two-dimensional data structure containing rows and columns. All elements in the matrix must be of the type specified in the type template (\"<type>\")."
      ],
      "syntax": ["matrix.new<type>(rows, columns, initial_value) → matrix<type>"],
      "args": [
        {
          "name": "rows",
          "desc": "Initial row count of the matrix. Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "columns",
          "desc": "Initial column count of the matrix. Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "initial_value",
          "desc": "Initial value of all matrix elements. Optional. The default is 'na'.",
          "allowedTypeIDs": [],
          "displayType": "<matrix_type>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Create a matrix of elements with the same initial value"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.new<type>()` Example 1\")",
            "",
            "// Create a 2x3 (2 rows x 3 columns) \"int\" matrix with values zero.",
            "var m = matrix.new<int>(2, 3, 0)",
            "",
            "// Display using a label.",
            "if barstate.islastconfirmedhistory",
            "\tlabel.new(bar_index, high, str.tostring(m))"
          ]
        },
        {
          "desc": ["Create a matrix from array values"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.new<type>()` Example 2\")",
            "",
            "// Function to create a matrix whose rows are filled with array values.",
            "matrixFromArray(int rows, int columns, array<float> data) =>",
            "\tm = matrix.new<float>(rows, columns)",
            "\tfor i = 0 to rows <= 0 ? na : rows - 1",
            "\t\tfor j = 0 to columns <= 0 ? na : columns - 1",
            "\t\t\tmatrix.set(m, i, j, array.get(data, i * columns + j))",
            "\tm",
            "\t",
            "// Create a 3x3 matrix from an array of values.",
            "var m1 = matrixFromArray(3, 3, array.from(1, 2, 3, 4, 5, 6, 7, 8, 9))",
            "// Display using a label.",
            "if barstate.islastconfirmedhistory",
            "\tlabel.new(bar_index, high, str.tostring(m1))"
          ]
        },
        {
          "desc": ["Create a matrix from an `input.text_area()` field"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.new<type>()` Example 3\")",
            "",
            "// Function to create a matrix from a text string.",
            "// Values in a row must be separated by a space. Each line is one row.",
            "matrixFromInputArea(stringOfValues) =>",
            "\tvar rowsArray = str.split(stringOfValues, \"\\n\")",
            "\tvar rows = array.size(rowsArray)",
            "\tvar cols = array.size(str.split(array.get(rowsArray, 0), \" \"))",
            "\tvar matrix = matrix.new<float>(rows, cols, na) ",
            "\trow = 0",
            "\tfor rowString in rowsArray",
            "\t\tcol = 0",
            "\t\tvalues = str.split(rowString, \" \")",
            "\t\tfor val in values",
            "\t\t\tmatrix.set(matrix, row, col, str.tonumber(val))",
            "\t\t\tcol += 1",
            "\t\trow += 1",
            "\tmatrix",
            "",
            "",
            "stringInput = input.text_area(\"1 2 3\\n4 5 6\\n7 8 9\")",
            "var m = matrixFromInputArea(stringInput)    ",
            "",
            "// Display using a label.",
            "if barstate.islastconfirmedhistory",
            "\tlabel.new(bar_index, high, str.tostring(m))"
          ]
        },
        {
          "desc": ["Create matrix from random values"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.new<type>()` Example 4\")",
            "",
            "// Function to create a matrix with random values (0.0 to 1.0).",
            "matrixRandom(int rows, int columns)=>",
            "\tresult = matrix.new<float>(rows, columns)",
            "\tfor i = 0 to rows - 1",
            "\t\tfor j = 0 to columns - 1",
            "\t\t\tmatrix.set(result, i, j, math.random())",
            "\tresult",
            "",
            "// Create a 2x3 matrix with random values.",
            "var m = matrixRandom(2, 3)",
            "",
            "// Display using a label.",
            "if barstate.islastconfirmedhistory",
            "\tlabel.new(bar_index, high, str.tostring(m))"
          ]
        }
      ],
      "returns": ["The ID of the new matrix object."],
      "seeAlso": [
        "[matrix.set](#fun_matrix.set)",
        "[matrix.fill](#fun_matrix.fill)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[array.new<type>](#fun_array.new<type>)"
      ],
      "template": true
    },
    {
      "name": "matrix.row",
      "desc": ["The function creates a one-dimensional array from the elements of a matrix row."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row",
          "desc": "Index of the required row.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.row()` Example\", \"\", true)",
        "",
        "// Create a 2x3 \"float\" matrix from `hlc3` values.",
        "m = matrix.new<float>(2, 3, hlc3)",
        "",
        "// Return an array with the values of the first row of the matrix.",
        "a = matrix.row(m, 0)",
        "",
        "// Plot the first value from the array `a`.",
        "plot(array.get(a, 0))"
      ],
      "returns": ["An array ID containing the `row` values of the `id` matrix."],
      "remarks": ["Indexing of rows starts at 0."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[array.get](#fun_array.get)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.row(id, row) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "matrix.col",
      "desc": [
        "The function creates a one-dimensional array from the elements of a matrix column."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "column",
          "desc": "Index of the required column.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.col()` Example\", \"\", true)",
        "",
        "// Create a 2x3 \"float\" matrix from `hlc3` values.",
        "m = matrix.new<float>(2, 3, hlc3)",
        "",
        "// Return an array with the values of the first column of matrix `m`.",
        "a = matrix.col(m, 0)",
        "",
        "// Plot the first value from the array `a`.",
        "plot(array.get(a, 0))"
      ],
      "returns": ["An array ID containing the `column` values of the `id` matrix."],
      "remarks": ["Indexing of rows starts at 0."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[array.get](#fun_array.get)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.columns](#fun_matrix.columns)"
      ],
      "syntax": ["matrix.col(id, column) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "matrix.reshape",
      "desc": ["The function rebuilds the `id` matrix to `rows` x `cols` dimensions."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "rows",
          "desc": "The number of rows of the reshaped matrix.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "columns",
          "desc": "The number of columns of the reshaped matrix.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.reshape()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x3 matrix.",
        "\tvar m1 = matrix.new<float>(2, 3)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 0, 2, 3)",
        "\tmatrix.set(m1, 1, 0, 4)",
        "\tmatrix.set(m1, 1, 1, 5)",
        "\tmatrix.set(m1, 1, 2, 6)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Reshape the copy to a 3x2.",
        "\tmatrix.reshape(m2, 3, 2)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Reshaped matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.add_row](#fun_matrix.add_row)",
        "[matrix.add_col](#fun_matrix.add_col)"
      ],
      "syntax": ["matrix.reshape(id, rows, columns) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.get",
      "desc": ["The function returns the element with the specified index of the matrix."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row",
          "desc": "Index of the required row.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "column",
          "desc": "Index of the required column.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.get()` Example\", \"\", true)",
        "",
        "// Create a 2x3 \"float\" matrix from the `hl2` values.",
        "m = matrix.new<float>(2, 3, hl2)",
        "",
        "// Return the value of the element at index [0, 0] of matrix `m`.",
        "x = matrix.get(m, 0, 0)",
        "",
        "plot(x)"
      ],
      "returns": ["The value of the element at the `row` and `column` index of the `id` matrix."],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.get(id, row, column) → <matrix_type>"],
      "returnedTypes": []
    },
    {
      "name": "matrix.set",
      "desc": [
        "The function assigns `value` to the element at the `row` and `column` of the `id` matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row",
          "desc": "The row index of the element to be modified.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "column",
          "desc": "The column index of the element to be modified.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "value",
          "desc": "The new value to be set.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the matrix's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.set()` Example\")",
        "",
        "// Create a 2x3 \"int\" matrix containing values `4`.",
        "m = matrix.new<int>(2, 3, 4)",
        "",
        "// Replace the value of element at row 1 and column 2 with value `3`.",
        "matrix.set(m, 0, 1, 3)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, str.tostring(m))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.set(id, row, column, value) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.add_row",
      "desc": [
        "The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row",
          "desc": "The index of the row after which the new row will be inserted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a row with `na` values to the matrix.",
            "matrix.add_row(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `2`.",
            "\tvar a = array.from(1, 2)",
            "\t",
            "\t// Add the `a` array as the first row of the empty matrix.",
            "\tmatrix.add_row(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_col](#fun_matrix.add_col)"
      ],
      "syntax": ["matrix.add_row(id, row) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.add_row",
      "desc": [
        "The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row",
          "desc": "The index of the row after which the new row will be inserted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "array_id",
          "desc": "An array to be inserted. Optional.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a row with `na` values to the matrix.",
            "matrix.add_row(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `2`.",
            "\tvar a = array.from(1, 2)",
            "\t",
            "\t// Add the `a` array as the first row of the empty matrix.",
            "\tmatrix.add_row(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_col](#fun_matrix.add_col)"
      ],
      "syntax": ["matrix.add_row(id, row, array_id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.add_col",
      "desc": [
        "The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "column",
          "desc": "The index of the column after which the new column will be inserted. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a column with `na` values to the matrix.",
            "matrix.add_col(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `3`.",
            "\tvar a = array.from(1, 3)",
            "\t",
            "\t// Add the `a` array as the first column of the empty matrix.",
            "\tmatrix.add_col(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values. Adding a column is also much slower than adding a row with the [matrix.add_row](#fun_matrix.add_row) function."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_row](#fun_matrix.add_row)"
      ],
      "syntax": ["matrix.add_col(id, column) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.add_col",
      "desc": [
        "The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "column",
          "desc": "The index of the column after which the new column will be inserted. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "array_id",
          "desc": "An array to be inserted. Optional.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a column with `na` values to the matrix.",
            "matrix.add_col(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `3`.",
            "\tvar a = array.from(1, 3)",
            "\t",
            "\t// Add the `a` array as the first column of the empty matrix.",
            "\tmatrix.add_col(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values. Adding a column is also much slower than adding a row with the [matrix.add_row](#fun_matrix.add_row) function."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_row](#fun_matrix.add_row)"
      ],
      "syntax": ["matrix.add_col(id, column, array_id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.remove_row",
      "desc": [
        "The function removes the row at `row` index of the `id` matrix and returns an array containing the removed row's values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row",
          "desc": "The index of the row to be deleted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"matrix_remove_row\", overlay = true)",
        "",
        "// Create a 2x2 \"int\" matrix containing values `1`.",
        "var matrixOrig = matrix.new<int>(2, 2, 1)",
        "",
        "// Set values to the 'matrixOrig' matrix.",
        "matrix.set(matrixOrig, 0, 1, 2)",
        "matrix.set(matrixOrig, 1, 0, 3)",
        "matrix.set(matrixOrig, 1, 1, 4)",
        "",
        "// Create a copy of the 'matrixOrig' matrix.",
        "matrixCopy = matrix.copy(matrixOrig)",
        "",
        "// Remove the first row from the matrix `matrixCopy`.",
        "arr = matrix.remove_row(matrixCopy, 0)",
        "",
        "// Display matrix elements.",
        "if barstate.islastconfirmedhistory",
        "\tvar t = table.new(position.top_right, 3, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(matrixOrig))",
        "\ttable.cell(t, 1, 0, \"Removed Elements:\")",
        "\ttable.cell(t, 1, 1, str.tostring(arr))",
        "\ttable.cell(t, 2, 0, \"Result Matrix:\")",
        "\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
      ],
      "returns": ["An array containing the elements of the row removed from the `id` matrix."],
      "remarks": [
        "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing rows."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.copy](#fun_matrix.copy)",
        "[matrix.remove_col](#fun_matrix.remove_col)"
      ],
      "syntax": ["matrix.remove_row(id, row) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "matrix.remove_col",
      "desc": [
        "The function removes the column at `column` index of the `id` matrix and returns an array containing the removed column's values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "column",
          "desc": "The index of the column to be removed. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"matrix_remove_col\", overlay = true)",
        "",
        "// Create a 2x2 matrix with ones.",
        "var matrixOrig = matrix.new<int>(2, 2, 1)",
        "",
        "// Set values to the 'matrixOrig' matrix.",
        "matrix.set(matrixOrig, 0, 1, 2)",
        "matrix.set(matrixOrig, 1, 0, 3)",
        "matrix.set(matrixOrig, 1, 1, 4)",
        "",
        "",
        "// Create a copy of the 'matrixOrig' matrix.",
        "matrixCopy = matrix.copy(matrixOrig)",
        "",
        "// Remove the first column from the `matrixCopy` matrix.",
        "arr = matrix.remove_col(matrixCopy, 0)",
        "",
        "// Display matrix elements.",
        "if barstate.islastconfirmedhistory",
        "\tvar t = table.new(position.top_right, 3, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(matrixOrig))",
        "\ttable.cell(t, 1, 0, \"Removed Elements:\")",
        "\ttable.cell(t, 1, 1, str.tostring(arr))",
        "\ttable.cell(t, 2, 0, \"Result Matrix:\")",
        "\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
      ],
      "returns": ["An array containing the elements of the column removed from the `id` matrix."],
      "remarks": [
        "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing columns. Deleting a column is also much slower than deleting a row with the [matrix.remove_row](#fun_matrix.remove_row) function."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.copy](#fun_matrix.copy)",
        "[matrix.remove_row](#fun_matrix.remove_row)"
      ],
      "syntax": ["matrix.remove_col(id, column) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "matrix.fill",
      "desc": [
        "The function fills a rectangular area of the `id` matrix defined by the indices `from_column` to `to_column` (not including it) and `from_row` to `to_row`(not including it) with the `value`."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "value",
          "desc": "The value to fill with.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the matrix's elements>"
        },
        {
          "name": "from_row",
          "desc": "Row index from which the fill will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_row",
          "desc": "Row index where the fill will end (not inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "from_column",
          "desc": "Column index from which the fill will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_column",
          "desc": "Column index where the fill will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.fill()` Example\")",
        "",
        "// Create a 4x5 \"int\" matrix containing values `0`.",
        "m = matrix.new<float>(4, 5, 0)",
        "",
        "// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.",
        "matrix.fill(m, hl2, 0, 2, 1, 3)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, str.tostring(m))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.fill(id, value, from_row, to_row, from_column, to_column) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.submatrix",
      "desc": [
        "The function extracts a submatrix of the `id` matrix within the specified indices."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "from_row",
          "desc": "Index of the row from which the extraction will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_row",
          "desc": "Index of the row where the extraction will end (non inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "from_column",
          "desc": "Index of the column from which the extraction will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_column",
          "desc": "Index of the column where the extraction will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.submatrix()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x3 matrix matrix with values `0`.",
        "\tvar m1 = matrix.new<int>(2, 3, 0)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 0, 2, 3)",
        "\tmatrix.set(m1, 1, 0, 4)",
        "\tmatrix.set(m1, 1, 1, 5)",
        "\tmatrix.set(m1, 1, 2, 6)",
        "\t",
        "\t// Create a 2x2 submatrix of the `m1` matrix.",
        "\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Submatrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": [
        "A new matrix object containing the submatrix of the `id` matrix defined by the `from_row`, `to_row`, `from_column` and `to_column` indices."
      ],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.row](#fun_matrix.row)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.reshape](#fun_matrix.reshape)"
      ],
      "syntax": ["matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>"],
      "returnedTypes": ["matrix<>"]
    },
    {
      "name": "matrix.copy",
      "desc": ["The function creates a new matrix which is a copy of the original."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object to copy.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.copy()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x3 \"float\" matrix with `1` values.",
        "\tvar m1 = matrix.new<float>(2, 3, 1)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\t// Note that unlike what `matrix.copy()` does, ",
        "\t// the simple assignment operation `m2 = m1`",
        "\t// would NOT create a new copy of the `m1` matrix.",
        "\t// It would merely create a copy of its ID referencing the same matrix.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 5, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix Copy:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix object of the copied `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.copy(id) → matrix<type>"],
      "returnedTypes": ["matrix<>"]
    },
    {
      "name": "matrix.columns",
      "desc": ["The function returns the number of columns in the matrix."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.columns()` Example\")",
        "",
        "// Create a 2x6 matrix with values `0`.",
        "var m = matrix.new<int>(2, 6, 0)",
        "",
        "// Get the quantity of columns in matrix `m`.",
        "var x = matrix.columns(m)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
      ],
      "returns": ["The number of columns in the matrix `id`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.row](#fun_matrix.row)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.columns(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.rows",
      "desc": ["The function returns the number of rows in the matrix."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.rows()` Example\")",
        "",
        "// Create a 2x6 matrix with values `0`.",
        "var m = matrix.new<int>(2, 6, 0)",
        "",
        "// Get the quantity of rows in the matrix.",
        "var x = matrix.rows(m)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
      ],
      "returns": ["The number of rows in the matrix `id`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.row](#fun_matrix.row)"
      ],
      "syntax": ["matrix.rows(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.elements_count",
      "desc": ["The function returns the total number of all matrix elements."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.elements_count(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.concat",
      "desc": ["The function appends the `m2` matrix to the `m1` matrix."],
      "args": [
        {
          "name": "id1",
          "desc": "Matrix object to concatenate into.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "id2",
          "desc": "Matrix object whose elements will be appended to `id1`.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.concat()` Example\")",
        "",
        "// Create a 2x4 \"int\" matrix containing values `0`.",
        "m1 = matrix.new<int>(2, 4, 0)",
        "// Create a 2x4 \"int\" matrix containing values `1`.",
        "m2 = matrix.new<int>(2, 4, 1)",
        "",
        "// Append matrix `m2` to `m1`.",
        "matrix.concat(m1, m2)",
        "",
        "// Display matrix elements.",
        "if barstate.islastconfirmedhistory",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix Elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))"
      ],
      "returns": ["Returns the `id1` matrix concatenated with the `id2` matrix."],
      "remarks": ["The number of columns in both matrices must be identical."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.concat(id1, id2) → matrix<type>"],
      "returnedTypes": ["matrix<>"]
    },
    {
      "name": "matrix.swap_rows",
      "desc": ["The function swaps the rows at the index `row1` and `row2` in the `id` matrix."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "row1",
          "desc": "Index of the first row to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row2",
          "desc": "Index of the second row to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.swap_rows()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 3x2 matrix with ‘na’ values.",
        "\tvar m1 = matrix.new<int>(3, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\tmatrix.set(m1, 2, 0, 5)",
        "\tmatrix.set(m1, 2, 1, 6)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Swap the first and second rows of the matrix copy.",
        "\tmatrix.swap_rows(m2, 0, 1)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Swapped rows in copy:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.swap_columns](#fun_matrix.swap_columns)"
      ],
      "syntax": ["matrix.swap_rows(id, row1, row2) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.swap_columns",
      "desc": [
        "The function swaps the columns at the index `column1` and `column2` in the `id` matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        },
        {
          "name": "column1",
          "desc": "Index of the first column to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "column2",
          "desc": "Index of the second column to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.swap_columns()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix with ‘na’ values.",
        "\tvar m1 = matrix.new<int>(2, 2, na)    ",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Swap the first and second columns of the matrix copy.",
        "\tmatrix.swap_columns(m2, 0, 1)",
        "",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Swapped columns in copy:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.swap_columns(id, column1, column2) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.reverse",
      "desc": [
        "The function reverses the order of rows and columns in the matrix `id`. The first row and first column become the last, and the last become the first."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.reverse()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Copy the matrix to a new one.",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Copy matrix elements to a new matrix.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Reverse the `m2` copy of the original matrix. ",
        "\tmatrix.reverse(m2)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Reversed matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.reshape](#fun_matrix.reshape)"
      ],
      "syntax": ["matrix.reverse(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.sort",
      "desc": [
        "The function rearranges the rows in the `id` matrix following the sorted order of the values in the `column`."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object to be sorted.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>", "matrix<string>"],
          "displayType": "matrix<int/float/string>"
        },
        {
          "name": "column",
          "desc": "Index of the column whose sorted values determine the new order of rows. Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "order",
          "desc": "The sort order. Possible values: [order.ascending](#const_order.ascending) (default), [order.descending](#const_order.descending).",
          "allowedTypeIDs": [
            "series sort_order",
            "simple sort_order",
            "input sort_order",
            "const sort_order"
          ],
          "displayType": "series sort_order"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.sort()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<float>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 3)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 1)",
        "\tmatrix.set(m1, 1, 1, 2)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t// Sort the rows of `m2` using the default arguments (first column and ascending order).",
        "\tmatrix.sort(m2)",
        "\t",
        "\t// Display using a table.",
        "\tif barstate.islastconfirmedhistory",
        "\t\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\t\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\t\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\t\ttable.cell(t, 1, 0, \"Sorted matrix:\")",
        "\t\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.max](#fun_matrix.max)",
        "[matrix.min](#fun_matrix.min)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.sort(id, column, order) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "matrix.det",
      "desc": [
        "The function returns the [determinant](https://en.wikipedia.org/wiki/Determinant) of a square matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.det` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<float>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0,  3)",
        "matrix.set(m, 0, 1,  7)",
        "matrix.set(m, 1, 0,  1)",
        "matrix.set(m, 1, 1, -4)",
        "",
        "// Get the determinant of the matrix. ",
        "var x = matrix.det(m)",
        "",
        "plot(x, 'Matrix determinant')"
      ],
      "returns": ["The determinant value of the `id` matrix."],
      "remarks": [
        "Function calculation based on the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.det(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.det",
      "desc": [
        "The function returns the [determinant](https://en.wikipedia.org/wiki/Determinant) of a square matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.det` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<float>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0,  3)",
        "matrix.set(m, 0, 1,  7)",
        "matrix.set(m, 1, 0,  1)",
        "matrix.set(m, 1, 1, -4)",
        "",
        "// Get the determinant of the matrix. ",
        "var x = matrix.det(m)",
        "",
        "plot(x, 'Matrix determinant')"
      ],
      "returns": ["The determinant value of the `id` matrix."],
      "remarks": [
        "Function calculation based on the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.det(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.min",
      "desc": ["The function returns the smallest value from the matrix elements."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.min()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the minimum value from the matrix.",
        "var x = matrix.min(m)",
        "",
        "plot(x, 'Matrix minimum value')"
      ],
      "returns": ["The smallest value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.max](#fun_matrix.max)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.min(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.min",
      "desc": ["The function returns the smallest value from the matrix elements."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.min()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the minimum value from the matrix.",
        "var x = matrix.min(m)",
        "",
        "plot(x, 'Matrix minimum value')"
      ],
      "returns": ["The smallest value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.max](#fun_matrix.max)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.min(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.max",
      "desc": ["The function returns the largest value from the matrix elements."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.max()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the maximum value in the matrix.",
        "var x = matrix.max(m)",
        "",
        "plot(x, 'Matrix maximum value')"
      ],
      "returns": ["The maximum value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.min](#fun_matrix.min)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.max(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.max",
      "desc": ["The function returns the largest value from the matrix elements."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.max()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the maximum value in the matrix.",
        "var x = matrix.max(m)",
        "",
        "plot(x, 'Matrix maximum value')"
      ],
      "returns": ["The maximum value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.min](#fun_matrix.min)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.max(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.avg",
      "desc": ["The function calculates the average of all elements in the matrix."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.avg()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the average value of the matrix.",
        "var x = matrix.avg(m)",
        "",
        "plot(x, 'Matrix average value')"
      ],
      "returns": ["The average value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.avg(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.avg",
      "desc": ["The function calculates the average of all elements in the matrix."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.avg()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the average value of the matrix.",
        "var x = matrix.avg(m)",
        "",
        "plot(x, 'Matrix average value')"
      ],
      "returns": ["The average value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.avg(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.median",
      "desc": [
        "The function calculates the [median](https://en.wikipedia.org/wiki/Median) (\"the middle\" value) of matrix elements."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.median()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the median of the matrix.",
        "x = matrix.median(m)",
        "",
        "plot(x, 'Median of the matrix')"
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the median."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mode](#fun_matrix.mode)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.median(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.median",
      "desc": [
        "The function calculates the [median](https://en.wikipedia.org/wiki/Median) (\"the middle\" value) of matrix elements."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.median()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the median of the matrix.",
        "x = matrix.median(m)",
        "",
        "plot(x, 'Median of the matrix')"
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the median."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mode](#fun_matrix.mode)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.median(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.mode",
      "desc": [
        "The function calculates the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.mode()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 0)",
        "matrix.set(m, 0, 1, 0)",
        "matrix.set(m, 1, 0, 1)",
        "matrix.set(m, 1, 1, 1)",
        "",
        "// Get the mode of the matrix.",
        "var x = matrix.mode(m)",
        "",
        "plot(x, 'Mode of the matrix')"
      ],
      "returns": [
        "The most frequently occurring value from the `id` matrix. If none exists, returns the smallest value instead."
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the mode."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.median](#fun_matrix.median)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.mode(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.mode",
      "desc": [
        "The function calculates the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.mode()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 0)",
        "matrix.set(m, 0, 1, 0)",
        "matrix.set(m, 1, 0, 1)",
        "matrix.set(m, 1, 1, 1)",
        "",
        "// Get the mode of the matrix.",
        "var x = matrix.mode(m)",
        "",
        "plot(x, 'Mode of the matrix')"
      ],
      "returns": [
        "The most frequently occurring value from the `id` matrix. If none exists, returns the smallest value instead."
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the mode."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.median](#fun_matrix.median)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.mode(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.transpose",
      "desc": [
        "The function creates a new, [transposed](https://en.wikipedia.org/wiki/Transpose#Transpose_of_a_matrix) version of the `id`. This interchanges the row and column index of each element."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.transpose()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<float>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Create a transpose of the matrix.",
        "\tvar m2 = matrix.transpose(m1)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Transposed matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the transposed version of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.reshape](#fun_matrix.reshape)",
        "[matrix.reverse](#fun_matrix.reverse)"
      ],
      "syntax": ["matrix.transpose(id) → matrix<type>"],
      "returnedTypes": ["matrix<>"]
    },
    {
      "name": "matrix.sum",
      "desc": [
        "The function returns a new matrix resulting from the [sum](https://en.wikipedia.org/wiki/Matrix_addition) of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object, or scalar value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>"
          ],
          "displayType": "series int/float/matrix<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Sum of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix that sums matrices `m1` and `m2`.",
            "\tvar m3 = matrix.sum(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Sum of a matrix and scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.",
            "\tvar m2 = matrix.sum(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the sum of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.sum(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.sum",
      "desc": [
        "The function returns a new matrix resulting from the [sum](https://en.wikipedia.org/wiki/Matrix_addition) of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object, or scalar value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/matrix<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Sum of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix that sums matrices `m1` and `m2`.",
            "\tvar m3 = matrix.sum(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Sum of a matrix and scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.",
            "\tvar m2 = matrix.sum(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the sum of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.sum(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.diff",
      "desc": [
        "The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "Matrix to subtract from.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        },
        {
          "name": "id2",
          "desc": "Matrix object or a scalar value to be subtracted.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>"
          ],
          "displayType": "series int/float/matrix<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Difference between two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix containing the difference between matrices `m1` and `m2`.",
            "\tvar m3 = matrix.diff(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Difference between a matrix and a scalar value"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.",
            "\tvar m2 = matrix.diff(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the difference between `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.diff(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.diff",
      "desc": [
        "The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "Matrix to subtract from.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        },
        {
          "name": "id2",
          "desc": "Matrix object or a scalar value to be subtracted.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/matrix<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Difference between two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix containing the difference between matrices `m1` and `m2`.",
            "\tvar m3 = matrix.diff(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Difference between a matrix and a scalar value"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.",
            "\tvar m2 = matrix.diff(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the difference between `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.diff(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>"
          ],
          "displayType": "series int/float/matrix<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/matrix<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "matrix.mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "matrix.pinv",
      "desc": [
        "The function returns the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse) of a matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pinv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Pseudoinverse of the matrix.",
        "\tvar m2 = matrix.pinv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the pseudoinverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using a [Moore–Penrose](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition) inverse formula based on singular-value decomposition of a matrix. For non-singular square matrices this function returns the result of [matrix.inv](#fun_matrix.inv)."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.inv](#fun_matrix.inv)"
      ],
      "syntax": ["matrix.pinv(id) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.pinv",
      "desc": [
        "The function returns the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse) of a matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pinv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Pseudoinverse of the matrix.",
        "\tvar m2 = matrix.pinv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the pseudoinverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using a [Moore–Penrose](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition) inverse formula based on singular-value decomposition of a matrix. For non-singular square matrices this function returns the result of [matrix.inv](#fun_matrix.inv)."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.inv](#fun_matrix.inv)"
      ],
      "syntax": ["matrix.pinv(id) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.inv",
      "desc": [
        "The function returns the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of a square matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.inv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Inverse of the matrix.",
        "\tvar m2 = matrix.inv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Inverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix, which is the inverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.pinv](#fun_matrix.pinv)",
        "[matrix.copy](#fun_matrix.copy)",
        "[str.tostring](#fun_str.tostring)"
      ],
      "syntax": ["matrix.inv(id) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.inv",
      "desc": [
        "The function returns the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of a square matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.inv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Inverse of the matrix.",
        "\tvar m2 = matrix.inv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Inverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix, which is the inverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.pinv](#fun_matrix.pinv)",
        "[matrix.copy](#fun_matrix.copy)",
        "[str.tostring](#fun_str.tostring)"
      ],
      "syntax": ["matrix.inv(id) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.rank",
      "desc": [
        "The function calculates the [rank](https://en.wikipedia.org/wiki/Rank_(linear_algebra)) of the matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.rank()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Get the rank of the matrix. ",
        "\tr = matrix.rank(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Rank of the matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(r))"
      ],
      "returns": ["The rank of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[str.tostring](#fun_str.tostring)"
      ],
      "syntax": ["matrix.rank(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.trace",
      "desc": [
        "The function calculates the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a matrix (the sum of the main diagonal's elements)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.trace()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Get the trace of the matrix.",
        "\ttr = matrix.trace(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Trace of the matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["The trace of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.trace(id) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "matrix.trace",
      "desc": [
        "The function calculates the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a matrix (the sum of the main diagonal's elements)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.trace()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Get the trace of the matrix.",
        "\ttr = matrix.trace(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Trace of the matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["The trace of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.trace(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "matrix.eigenvalues",
      "desc": [
        "The function returns an array containing the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors) of a square matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvalues()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvalues of the matrix.",
        "\ttr = matrix.eigenvalues(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["An array containing the eigenvalues of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvectors](#fun_matrix.eigenvectors)"
      ],
      "syntax": ["matrix.eigenvalues(id) → array<float>"],
      "returnedTypes": ["array<float>"]
    },
    {
      "name": "matrix.eigenvalues",
      "desc": [
        "The function returns an array containing the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors) of a square matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvalues()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvalues of the matrix.",
        "\ttr = matrix.eigenvalues(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["An array containing the eigenvalues of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvectors](#fun_matrix.eigenvectors)"
      ],
      "syntax": ["matrix.eigenvalues(id) → array<int>"],
      "returnedTypes": ["array<int>"]
    },
    {
      "name": "matrix.eigenvectors",
      "desc": [
        "Returns a matrix of [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors), in which each column is an eigenvector of the `id` matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvectors()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix ",
        "\tvar m1 = matrix.new<int>(2, 2, 1)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvectors of the matrix.",
        "\tm2 = matrix.eigenvectors(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix Elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the eigenvectors of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvalues](#fun_matrix.eigenvalues)"
      ],
      "syntax": ["matrix.eigenvectors(id) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.eigenvectors",
      "desc": [
        "Returns a matrix of [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors), in which each column is an eigenvector of the `id` matrix."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvectors()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix ",
        "\tvar m1 = matrix.new<int>(2, 2, 1)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvectors of the matrix.",
        "\tm2 = matrix.eigenvectors(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix Elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the eigenvectors of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvalues](#fun_matrix.eigenvalues)"
      ],
      "syntax": ["matrix.eigenvectors(id) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.kron",
      "desc": [
        "The function returns the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) for the `id1` and `id2` matrices."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.kron()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create two matrices with default values `1` and `2`. ",
        "\tvar m1 = matrix.new<float>(2, 2, 1) ",
        "\tvar m2 = matrix.new<float>(2, 2, 2) ",
        "\t",
        "\t// Calculate the Kronecker product of the matrices.",
        "\tvar m3 = matrix.kron(m1, m2) ",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 5, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 1, \"⊗\")",
        "\ttable.cell(t, 2, 0, \"Matrix 2:\")",
        "\ttable.cell(t, 2, 1, str.tostring(m2))",
        "\ttable.cell(t, 3, 1, \"=\")",
        "\ttable.cell(t, 4, 0, \"Kronecker product:\")",
        "\ttable.cell(t, 4, 1, str.tostring(m3))"
      ],
      "returns": [
        "A new matrix containing the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) of `id1` and `id2`."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mult](#fun_matrix.mult)",
        "[str.tostring](#fun_str.tostring)",
        "[table.new](#fun_table.new)"
      ],
      "syntax": ["matrix.kron(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.kron",
      "desc": [
        "The function returns the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) for the `id1` and `id2` matrices."
      ],
      "args": [
        {
          "name": "id1",
          "desc": "First matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        },
        {
          "name": "id2",
          "desc": "Second matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.kron()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create two matrices with default values `1` and `2`. ",
        "\tvar m1 = matrix.new<float>(2, 2, 1) ",
        "\tvar m2 = matrix.new<float>(2, 2, 2) ",
        "\t",
        "\t// Calculate the Kronecker product of the matrices.",
        "\tvar m3 = matrix.kron(m1, m2) ",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 5, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 1, \"⊗\")",
        "\ttable.cell(t, 2, 0, \"Matrix 2:\")",
        "\ttable.cell(t, 2, 1, str.tostring(m2))",
        "\ttable.cell(t, 3, 1, \"=\")",
        "\ttable.cell(t, 4, 0, \"Kronecker product:\")",
        "\ttable.cell(t, 4, 1, str.tostring(m3))"
      ],
      "returns": [
        "A new matrix containing the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) of `id1` and `id2`."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mult](#fun_matrix.mult)",
        "[str.tostring](#fun_str.tostring)",
        "[table.new](#fun_table.new)"
      ],
      "syntax": ["matrix.kron(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.pow",
      "desc": ["The function calculates the product of the matrix by itself `power` times."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        },
        {
          "name": "power",
          "desc": "The number of times the matrix will be multiplied by itself.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pow()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, 2)",
        "\t// Calculate the power of three of the matrix.",
        "\tvar m2 = matrix.pow(m1, 3)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix³:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["The product of the `id` matrix by itself `power` times."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.mult](#fun_matrix.mult)"
      ],
      "syntax": ["matrix.pow(id, power) → matrix<float>"],
      "returnedTypes": ["matrix<float>"]
    },
    {
      "name": "matrix.pow",
      "desc": ["The function calculates the product of the matrix by itself `power` times."],
      "args": [
        {
          "name": "id",
          "desc": "A matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        },
        {
          "name": "power",
          "desc": "The number of times the matrix will be multiplied by itself.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pow()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, 2)",
        "\t// Calculate the power of three of the matrix.",
        "\tvar m2 = matrix.pow(m1, 3)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix³:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["The product of the `id` matrix by itself `power` times."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.mult](#fun_matrix.mult)"
      ],
      "syntax": ["matrix.pow(id, power) → matrix<int>"],
      "returnedTypes": ["matrix<int>"]
    },
    {
      "name": "matrix.is_zero",
      "desc": ["The function determines if all elements of the matrix are zero."],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to check.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if all elements of the `id` matrix are zero, false otherwise."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)"
      ],
      "syntax": ["matrix.is_zero(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_identity",
      "desc": [
        "The function determines if a matrix is an [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix) (elements with ones on the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) and zeros elsewhere)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if `id` is an identity matrix, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.is_square](#fun_matrix.is_square)",
        "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
      ],
      "syntax": ["matrix.is_identity(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_binary",
      "desc": [
        "The function determines if the matrix is [binary](https://en.wikipedia.org/wiki/Logical_matrix) (when all elements of the matrix are 0 or 1)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if the `id` matrix is binary, false otherwise."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)"
      ],
      "syntax": ["matrix.is_binary(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_symmetric",
      "desc": [
        "The function determines if a [square matrix](https://en.wikipedia.org/wiki/Square_matrix) is [symmetric](https://en.wikipedia.org/wiki/Symmetric_matrix) (elements are symmetric with respect to the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal))."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if the `id` matrix is symmetric, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.is_symmetric(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_antisymmetric",
      "desc": [
        "The function determines if a matrix is [antisymmetric](https://en.wikipedia.org/wiki/Skew-symmetric_matrix) (its [transpose](https://en.wikipedia.org/wiki/Transpose) equals its negative)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true, if the `id` matrix is antisymmetric, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.is_antisymmetric(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_diagonal",
      "desc": [
        "The function determines if the matrix is [diagonal](https://en.wikipedia.org/wiki/Diagonal_matrix) (all elements outside the main diagonal are zero)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if the `id` matrix is diagonal, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)",
        "[matrix.is_identity](#fun_matrix.is_identity)",
        "[matrix.is_antidiagonal](#fun_matrix.is_antidiagonal)"
      ],
      "syntax": ["matrix.is_diagonal(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_antidiagonal",
      "desc": [
        "The function determines if the matrix is [anti-diagonal](https://en.wikipedia.org/wiki/Anti-diagonal_matrix) (all elements outside the secondary diagonal are zero)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if the `id` matrix is ​​anti-diagonal, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)",
        "[matrix.is_identity](#fun_matrix.is_identity)",
        "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
      ],
      "syntax": ["matrix.is_antidiagonal(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_triangular",
      "desc": [
        "The function determines if the matrix is [triangular](https://en.wikipedia.org/wiki/Triangular_matrix) (if all elements above or below the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) are zero)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if the `id` matrix is triangular, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.is_triangular(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_stochastic",
      "desc": [
        "The function determines if the matrix is [stochastic](https://en.wikipedia.org/wiki/Stochastic_matrix)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "returns": ["Returns true if the `id` matrix is stochastic, false otherwise."],
      "seeAlso": ["[matrix.new<type>](#fun_matrix.new<type>)", "[matrix.set](#fun_matrix.set)"],
      "syntax": ["matrix.is_stochastic(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "matrix.is_square",
      "desc": [
        "The function determines if the matrix is [square](https://en.wikipedia.org/wiki/Square_matrix) (it has the same number of rows and columns)."
      ],
      "args": [
        {
          "name": "id",
          "desc": "Matrix object to test.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "returns": ["Returns true if the `id` matrix is square, false otherwise."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.is_square(id) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "table.merge_cells",
      "desc": [
        "The function merges a sequence of cells in the table into one cell. The cells are merged in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner."
      ],
      "args": [
        {
          "name": "table_id",
          "desc": "A table object.",
          "required": true,
          "allowedTypeIDs": ["series table"],
          "displayType": "series table"
        },
        {
          "name": "start_column",
          "desc": "The index of the column of the first cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "start_row",
          "desc": "The index of the row of the first cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_column",
          "desc": "The index of the column of the last cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_row",
          "desc": "The index of the row of the last cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"table.merge_cells example\")",
        "SMA50  = ta.sma(close, 50)",
        "SMA100 = ta.sma(close, 100)",
        "SMA200 = ta.sma(close, 200)",
        "if barstate.islast",
        "\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)",
        "\t// Header",
        "\ttable.cell(maTable, 0, 0, text = \"SMA Table\")",
        "\ttable.merge_cells(maTable, 0, 0, 2, 0)",
        "\t// Cell Titles",
        "\ttable.cell(maTable, 0, 1, text = \"SMA 50\")",
        "\ttable.cell(maTable, 1, 1, text = \"SMA 100\")",
        "\ttable.cell(maTable, 2, 1, text = \"SMA 200\")",
        "\t// Values",
        "\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))",
        "\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))",
        "\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))"
      ],
      "remarks": [
        "This function will merge cells, even if their properties are not yet defined with [table.cell](#fun_table.cell).",
        "The resulting merged cell inherits all of its values from the cell located at `start_column`:`start_row`, except width and height. The width and height of the resulting merged cell are based on the width/height of other cells in the neighboring columns/rows and cannot be set manually.",
        "To modify the merged cell with any of the `table.cell_set_*` functions, target the cell at the `start_column`:`start_row` coordinates.",
        "An attempt to merge a cell that has already been merged will result in an error."
      ],
      "seeAlso": ["[table.delete](#fun_table.delete)", "[table.new](#fun_table.new)"],
      "syntax": [
        "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void"
      ],
      "returnedTypes": ["void"]
    },
    {
      "name": "strategy.closedtrades.entry_price",
      "desc": ["Returns the price of the closed trade's entry."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.closedtrades.entry_price Example 1\")",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Return the entry price for the latest entry.",
            "entryPrice = strategy.closedtrades.entry_price(strategy.closedtrades - 1)",
            "",
            "plot(entryPrice, \"Long entry price\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the average profit percentage for all closed trades.",
            "//@version=6",
            "strategy(\"strategy.closedtrades.entry_price Example 2\")",
            "",
            "// Strategy calls to create single short and long trades",
            "if bar_index == last_bar_index - 15",
            "    strategy.entry(\"Long Entry\", strategy.long)",
            "else if bar_index == last_bar_index - 10",
            "    strategy.close(\"Long Entry\")",
            "    strategy.entry(\"Short\", strategy.short)",
            "else if bar_index == last_bar_index - 5",
            "    strategy.close(\"Short\")",
            "",
            "// Calculate profit for both closed trades.",
            "profitPct = 0.0",
            "for tradeNo = 0 to strategy.closedtrades - 1",
            "    entryP = strategy.closedtrades.entry_price(tradeNo)",
            "    exitP = strategy.closedtrades.exit_price(tradeNo)",
            "    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100",
            "    ",
            "// Calculate average profit percent for both closed trades.",
            "avgProfitPct = nz(profitPct / strategy.closedtrades)",
            "",
            "plot(avgProfitPct)"
          ]
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.entry_price](#fun_strategy.closedtrades.entry_price)",
        "[strategy.closedtrades.exit_price](#fun_strategy.closedtrades.exit_price)",
        "[strategy.closedtrades.size](#fun_strategy.closedtrades.size)",
        "[strategy.closedtrades](#var_strategy.closedtrades),"
      ],
      "syntax": ["strategy.closedtrades.entry_price(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.entry_bar_index",
      "desc": ["Returns the bar_index of the closed trade's entry."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.closedtrades.entry_bar_index Example\")",
        "// Enter long trades on three rising bars; exit on two falling bars.",
        "if ta.rising(close, 3)",
        "    strategy.entry(\"Long\", strategy.long)",
        "if ta.falling(close, 2)",
        "    strategy.close(\"Long\")",
        "// Function that calculates the average amount of bars in a trade.",
        "avgBarsPerTrade() =>",
        "\tsumBarsPerTrade = 0",
        "\tfor tradeNo = 0 to strategy.closedtrades - 1",
        "\t\t// Loop through all closed trades, starting with the oldest.",
        "\t\tsumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1",
        "\tresult = nz(sumBarsPerTrade / strategy.closedtrades)",
        "plot(avgBarsPerTrade())"
      ],
      "seeAlso": [
        "[strategy.closedtrades.exit_bar_index](#fun_strategy.closedtrades.exit_bar_index)",
        "[strategy.opentrades.entry_bar_index](#fun_strategy.opentrades.entry_bar_index)"
      ],
      "syntax": ["strategy.closedtrades.entry_bar_index(trade_num) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "strategy.closedtrades.entry_time",
      "desc": ["Returns the UNIX time of the closed trade's entry, expressed in milliseconds.."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.closedtrades.entry_time Example\", overlay = true)",
        "",
        "// Enter long trades on three rising bars; exit on two falling bars.",
        "if ta.rising(close, 3)",
        "    strategy.entry(\"Long\", strategy.long)",
        "if ta.falling(close, 2)",
        "    strategy.close(\"Long\")",
        "",
        "// Calculate the average trade duration ",
        "avgTradeDuration() =>",
        "    sumTradeDuration = 0",
        "    for i = 0 to strategy.closedtrades - 1",
        "        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)",
        "    result = nz(sumTradeDuration / strategy.closedtrades)",
        "",
        "// Display average duration converted to seconds and formatted using 2 decimal points",
        "if barstate.islastconfirmedhistory",
        "    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")"
      ],
      "seeAlso": [
        "[strategy.opentrades.entry_time](#fun_strategy.opentrades.entry_time)",
        "[strategy.closedtrades.exit_time](#fun_strategy.closedtrades.exit_time)",
        "[time](#var_time)"
      ],
      "syntax": ["strategy.closedtrades.entry_time(trade_num) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "strategy.closedtrades.exit_price",
      "desc": ["Returns the price of the closed trade's exit."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.closedtrades.exit_price Example 1\")",
            "",
            "// We are creating a long trade every 5 bars",
            "if bar_index % 5 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "strategy.close(\"Long\")",
            "",
            "// Return the exit price from the latest closed trade.",
            "exitPrice = strategy.closedtrades.exit_price(strategy.closedtrades - 1)",
            "",
            "plot(exitPrice, \"Long exit price\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the average profit percentage for all closed trades.",
            "//@version=6",
            "strategy(\"strategy.closedtrades.exit_price Example 2\")",
            "",
            "// Strategy calls to create single short and long trades.",
            "if bar_index == last_bar_index - 15",
            "    strategy.entry(\"Long Entry\", strategy.long)",
            "else if bar_index == last_bar_index - 10",
            "    strategy.close(\"Long Entry\")",
            "    strategy.entry(\"Short\", strategy.short)",
            "else if bar_index == last_bar_index - 5",
            "    strategy.close(\"Short\")",
            "",
            "// Calculate profit for both closed trades.",
            "profitPct = 0.0",
            "for tradeNo = 0 to strategy.closedtrades - 1",
            "    entryP = strategy.closedtrades.entry_price(tradeNo)",
            "    exitP = strategy.closedtrades.exit_price(tradeNo)",
            "    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100",
            "    ",
            "// Calculate average profit percent for both closed trades.",
            "avgProfitPct = nz(profitPct / strategy.closedtrades)",
            "",
            "plot(avgProfitPct)"
          ]
        }
      ],
      "seeAlso": ["[strategy.closedtrades.entry_price](#fun_strategy.closedtrades.entry_price)"],
      "syntax": ["strategy.closedtrades.exit_price(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.exit_bar_index",
      "desc": ["Returns the bar_index of the closed trade's exit."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.closedtrades.exit_bar_index Example 1\")",
            "",
            "// Strategy calls to place a single short trade. We enter the trade at the first bar and exit the trade at 10 bars before the last chart bar.",
            "if bar_index == 0",
            "    strategy.entry(\"Short\", strategy.short)",
            "if bar_index == last_bar_index - 10",
            "    strategy.close(\"Short\")",
            "",
            "// Calculate the amount of bars since the last closed trade.",
            "barsSinceClosed = strategy.closedtrades > 0 ? bar_index - strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1) : na",
            "",
            "plot(barsSinceClosed, \"Bars since last closed trade\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the average amount of bars per trade.",
            "//@version=6",
            "strategy(\"strategy.closedtrades.exit_bar_index Example 2\")",
            "",
            "// Enter long trades on three rising bars; exit on two falling bars.",
            "if ta.rising(close, 3)",
            "    strategy.entry(\"Long\", strategy.long)",
            "if ta.falling(close, 2)",
            "    strategy.close(\"Long\")",
            "",
            "// Function that calculates the average amount of bars per trade.",
            "avgBarsPerTrade() =>",
            "    sumBarsPerTrade = 0",
            "    for tradeNo = 0 to strategy.closedtrades - 1",
            "        // Loop through all closed trades, starting with the oldest.",
            "        sumBarsPerTrade += strategy.closedtrades.exit_bar_index(tradeNo) - strategy.closedtrades.entry_bar_index(tradeNo) + 1",
            "    result = nz(sumBarsPerTrade / strategy.closedtrades)",
            "",
            "plot(avgBarsPerTrade())"
          ]
        }
      ],
      "seeAlso": ["[bar_index](#var_bar_index)", "[last_bar_index](#var_last_bar_index)"],
      "syntax": ["strategy.closedtrades.exit_bar_index(trade_num) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "strategy.closedtrades.exit_time",
      "desc": ["Returns the UNIX time of the closed trade's exit, expressed in milliseconds."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.closedtrades.exit_time Example 1\")",
            "",
            "// Enter long trades on three rising bars; exit on two falling bars.",
            "if ta.rising(close, 3)",
            "    strategy.entry(\"Long\", strategy.long)",
            "if ta.falling(close, 2)",
            "    strategy.close(\"Long\")",
            "",
            "// Calculate the average trade duration. ",
            "avgTradeDuration() =>",
            "    sumTradeDuration = 0",
            "    for i = 0 to strategy.closedtrades - 1",
            "        sumTradeDuration += strategy.closedtrades.exit_time(i) - strategy.closedtrades.entry_time(i)",
            "    result = nz(sumTradeDuration / strategy.closedtrades)",
            "",
            "// Display average duration converted to seconds and formatted using 2 decimal points.",
            "if barstate.islastconfirmedhistory",
            "    label.new(bar_index, high, str.tostring(avgTradeDuration() / 1000, \"#.##\") + \" seconds\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Reopens a closed trade after X seconds.",
            "//@version=6",
            "strategy(\"strategy.closedtrades.exit_time Example 2\")",
            "",
            "// Strategy calls to emulate a single long trade at the first bar.",
            "if bar_index == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "",
            "reopenPositionAfter(timeSec) =>",
            "    if strategy.closedtrades > 0",
            "        if time - strategy.closedtrades.exit_time(strategy.closedtrades - 1) >= timeSec * 1000",
            "            strategy.entry(\"Long\", strategy.long)",
            "",
            "// Reopen last closed position after 120 sec.                ",
            "reopenPositionAfter(120)",
            "",
            "if ta.change(strategy.opentrades) != 0",
            "    strategy.exit(\"Long\", stop = low * 0.9, profit = high * 2.5)"
          ]
        }
      ],
      "seeAlso": ["[strategy.closedtrades.entry_time](#fun_strategy.closedtrades.entry_time)"],
      "syntax": ["strategy.closedtrades.exit_time(trade_num) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "strategy.closedtrades.size",
      "desc": [
        "Returns the direction and the number of contracts traded in the closed trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"`strategy.closedtrades.size` Example 1\")",
            "",
            "// We calculate the max amt of shares we can buy.",
            "amtShares = math.floor(strategy.equity / close)",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long, qty = amtShares)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Plot the number of contracts traded in the last closed trade.     ",
            "plot(strategy.closedtrades.size(strategy.closedtrades - 1), \"Number of contracts traded\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the average profit percentage for all closed trades.",
            "//@version=6",
            "strategy(\"`strategy.closedtrades.size` Example 2\")",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "",
            "// Calculate profit for both closed trades.",
            "profitPct = 0.0",
            "for tradeNo = 0 to strategy.closedtrades - 1",
            "    entryP = strategy.closedtrades.entry_price(tradeNo)",
            "    exitP = strategy.closedtrades.exit_price(tradeNo)",
            "    profitPct += (exitP - entryP) / entryP * strategy.closedtrades.size(tradeNo) * 100",
            "    ",
            "// Calculate average profit percent for both closed trades.",
            "avgProfitPct = nz(profitPct / strategy.closedtrades)",
            "",
            "plot(avgProfitPct)"
          ]
        }
      ],
      "seeAlso": [
        "[strategy.opentrades.size](#fun_strategy.opentrades.size)",
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.closedtrades](#var_strategy.closedtrades)",
        "[strategy.opentrades](#var_strategy.opentrades)"
      ],
      "syntax": ["strategy.closedtrades.size(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.profit",
      "desc": [
        "Returns the profit/loss of the closed trade, expressed in [strategy.account_currency](#var_strategy.account_currency). Losses are expressed as negative values."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.closedtrades.profit` Example\")",
        "",
        "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
        "if bar_index % 15 == 0",
        "    strategy.entry(\"Long\", strategy.long)",
        "if bar_index % 20 == 0",
        "    strategy.close(\"Long\")",
        "",
        "// Calculate average gross profit by adding the difference between gross profit and commission.",
        "avgGrossProfit() =>",
        "    sumGrossProfit = 0.0",
        "    for tradeNo = 0 to strategy.closedtrades - 1",
        "        sumGrossProfit += strategy.closedtrades.profit(tradeNo) - strategy.closedtrades.commission(tradeNo)",
        "    result = nz(sumGrossProfit / strategy.closedtrades)",
        "    ",
        "plot(avgGrossProfit(), \"Average gross profit\")"
      ],
      "seeAlso": [
        "[strategy.opentrades.profit](#fun_strategy.opentrades.profit)",
        "[strategy.closedtrades.commission](#fun_strategy.closedtrades.commission)"
      ],
      "syntax": ["strategy.closedtrades.profit(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.commission",
      "desc": [
        "Returns the sum of entry and exit fees paid in the closed trade, expressed in [strategy.account_currency](#var_strategy.account_currency)."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.closedtrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)",
        "",
        "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
        "if bar_index % 15 == 0",
        "    strategy.entry(\"Long\", strategy.long)",
        "if bar_index % 20 == 0",
        "    strategy.close(\"Long\")",
        "",
        "// Plot total fees for the latest closed trade.",
        "plot(strategy.closedtrades.commission(strategy.closedtrades - 1))"
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.opentrades.commission](#fun_strategy.opentrades.commission)"
      ],
      "syntax": ["strategy.closedtrades.commission(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.max_runup",
      "desc": [
        "Returns the maximum run up of the closed trade, i.e., the maximum possible profit during the trade, expressed in [strategy.account_currency](#var_strategy.account_currency)."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.closedtrades.max_runup` Example\")",
        "",
        "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
        "if bar_index % 15 == 0",
        "    strategy.entry(\"Long\", strategy.long)",
        "if bar_index % 20 == 0",
        "    strategy.close(\"Long\")",
        "",
        "// Get the biggest max trade runup value from all of the closed trades.",
        "maxTradeRunUp() =>",
        "    maxRunup = 0.0",
        "    for tradeNo = 0 to strategy.closedtrades - 1",
        "        maxRunup := math.max(maxRunup, strategy.closedtrades.max_runup(tradeNo))",
        "    result = maxRunup",
        "",
        "plot(maxTradeRunUp(), \"Max trade runup\")"
      ],
      "seeAlso": [
        "[strategy.opentrades.max_runup](#fun_strategy.opentrades.max_runup)",
        "[strategy.max_runup](#var_strategy.max_runup)"
      ],
      "syntax": ["strategy.closedtrades.max_runup(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.max_drawdown",
      "desc": [
        "Returns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade, expressed in [strategy.account_currency](#var_strategy.account_currency)."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.closedtrades.max_drawdown` Example\")",
        "",
        "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
        "if bar_index % 15 == 0",
        "    strategy.entry(\"Long\", strategy.long)",
        "if bar_index % 20 == 0",
        "    strategy.close(\"Long\")",
        "",
        "// Get the biggest max trade drawdown value from all of the closed trades.",
        "maxTradeDrawDown() =>",
        "    maxDrawdown = 0.0",
        "    for tradeNo = 0 to strategy.closedtrades - 1",
        "        maxDrawdown := math.max(maxDrawdown, strategy.closedtrades.max_drawdown(tradeNo))",
        "    result = maxDrawdown",
        "",
        "plot(maxTradeDrawDown(), \"Biggest max drawdown\")"
      ],
      "remarks": [
        "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1."
      ],
      "seeAlso": [
        "[strategy.opentrades.max_drawdown](#fun_strategy.opentrades.max_drawdown)",
        "[strategy.max_drawdown](#var_strategy.max_drawdown)"
      ],
      "syntax": ["strategy.closedtrades.max_drawdown(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.max_drawdown_percent",
      "desc": [
        "Returns the maximum drawdown of the closed trade, i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by formula: `Lowest Value During Trade / (Entry Price x Quantity) * 100`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.max_drawdown](#fun_strategy.closedtrades.max_drawdown)",
        "[strategy.max_drawdown](#var_strategy.max_drawdown)"
      ],
      "syntax": ["strategy.closedtrades.max_drawdown_percent(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.max_runup_percent",
      "desc": [
        "Returns the maximum run-up of the closed trade, i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by formula: `Highest Value During Trade / (Entry Price x Quantity) * 100`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.max_runup](#fun_strategy.closedtrades.max_runup)",
        "[strategy.max_runup](#var_strategy.max_runup)"
      ],
      "syntax": ["strategy.closedtrades.max_runup_percent(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.profit_percent",
      "desc": [
        "Returns the profit/loss value of the closed trade, expressed as a percentage. Losses are expressed as negative values."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[strategy.closedtrades.profit](#fun_strategy.closedtrades.profit)"],
      "syntax": ["strategy.closedtrades.profit_percent(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.max_drawdown_percent",
      "desc": [
        "Returns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade, expressed as a percentage and calculated by formula: `Lowest Value During Trade / (Entry Price x Quantity) * 100`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[strategy.opentrades.max_drawdown](#fun_strategy.opentrades.max_drawdown)",
        "[strategy.max_drawdown](#var_strategy.max_drawdown)"
      ],
      "syntax": ["strategy.opentrades.max_drawdown_percent(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.max_runup_percent",
      "desc": [
        "Returns the maximum run-up of the open trade, i.e., the maximum possible profit during the trade, expressed as a percentage and calculated by formula: `Highest Value During Trade / (Entry Price x Quantity) * 100`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[strategy.opentrades.max_runup](#fun_strategy.opentrades.max_runup)",
        "[strategy.max_runup](#var_strategy.max_runup)"
      ],
      "syntax": ["strategy.opentrades.max_runup_percent(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.profit_percent",
      "desc": [
        "Returns the profit/loss of the open trade, expressed as a percentage. Losses are expressed as negative values."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[strategy.opentrades.profit](#fun_strategy.opentrades.profit)"],
      "syntax": ["strategy.opentrades.profit_percent(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.closedtrades.entry_id",
      "desc": ["Returns the id of the closed trade's entry."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.closedtrades.entry_id Example\", overlay = true)",
        "",
        "// Enter a short position and close at the previous to last bar.",
        "if bar_index == 1",
        "    strategy.entry(\"Short at bar #\" + str.tostring(bar_index), strategy.short)",
        "if bar_index == last_bar_index - 2",
        "    strategy.close_all()",
        "    ",
        "// Display ID of the last entry position.",
        "if barstate.islastconfirmedhistory",
        "    label.new(last_bar_index, high, \"Last Entry ID is: \" + strategy.closedtrades.entry_id(strategy.closedtrades - 1))"
      ],
      "returns": ["Returns the id of the closed trade's entry."],
      "remarks": [
        "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1."
      ],
      "seeAlso": [
        "[strategy.closedtrades.entry_bar_index](#fun_strategy.closedtrades.entry_bar_index)",
        "[strategy.closedtrades.entry_price](#fun_strategy.closedtrades.entry_price)",
        "[strategy.closedtrades.entry_time](#fun_strategy.closedtrades.entry_time)"
      ],
      "syntax": ["strategy.closedtrades.entry_id(trade_num) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "strategy.closedtrades.exit_id",
      "desc": ["Returns the id of the closed trade's exit."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.closedtrades.exit_id Example\", overlay = true)",
        "",
        "// Strategy calls to create single short and long trades",
        "if bar_index == last_bar_index - 15",
        "    strategy.entry(\"Long Entry\", strategy.long)",
        "else if bar_index == last_bar_index - 10",
        "    strategy.entry(\"Short Entry\", strategy.short)",
        "    ",
        "// When a new open trade is detected then we create the exit strategy corresponding with the matching entry id",
        "// We detect the correct entry id by determining if a position is long or short based on the position quantity",
        "if ta.change(strategy.opentrades) != 0",
        "    posSign = strategy.opentrades.size(strategy.opentrades - 1)",
        "    strategy.exit(posSign > 0 ? \"SL Long Exit\" : \"SL Short Exit\", strategy.opentrades.entry_id(strategy.opentrades - 1), stop = posSign > 0 ? high - ta.tr : low + ta.tr)",
        "",
        "// When a new closed trade is detected then we place a label above the bar with the exit info",
        "if ta.change(strategy.closedtrades) != 0",
        "    msg = \"Trade closed by: \" + strategy.closedtrades.exit_id(strategy.closedtrades - 1)",
        "    label.new(bar_index, high + (3 * ta.tr), msg)"
      ],
      "returns": ["Returns the id of the closed trade's exit."],
      "remarks": [
        "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades-1."
      ],
      "seeAlso": [
        "[strategy.closedtrades.exit_bar_index](#fun_strategy.closedtrades.exit_bar_index)",
        "[strategy.closedtrades.exit_price](#fun_strategy.closedtrades.exit_price)",
        "[strategy.closedtrades.exit_time](#fun_strategy.closedtrades.exit_time)"
      ],
      "syntax": ["strategy.closedtrades.exit_id(trade_num) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "strategy.opentrades.entry_comment",
      "desc": [
        "Returns the comment message of the open trade's entry, or\n[na](#var_na) if there is no entry with this `trade_num`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.opentrades.entry_comment()` Example\", overlay = true)",
        "",
        "stopPrice = open * 1.01",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "",
        "if (longCondition)",
        "    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))",
        "",
        "var testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)",
        "",
        "if barstate.islastconfirmedhistory or barstate.isrealtime",
        "    table.cell(testTable, 0, 0, 'Last entry stats')",
        "    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.opentrades.entry_comment(strategy.opentrades - 1))",
        "    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.opentrades.entry_price(strategy.opentrades - 1)))"
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.opentrades](#var_strategy.opentrades)"
      ],
      "syntax": ["strategy.opentrades.entry_comment(trade_num) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "strategy.closedtrades.entry_comment",
      "desc": [
        "Returns the comment message of the closed trade's entry, or [na](#var_na)\nif there is no entry with this `trade_num`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.closedtrades.entry_comment()` Example\", overlay = true)",
        "",
        "stopPrice = open * 1.01",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "",
        "if (longCondition)",
        "    strategy.entry(\"Long\", strategy.long, stop = stopPrice, comment = str.tostring(stopPrice, \"#.####\"))",
        "    strategy.exit(\"EXIT\", trail_points = 1000, trail_offset = 0)",
        "",
        "var testTable = table.new(position.top_right, 1, 3, color.orange, border_width = 1)",
        "",
        "if barstate.islastconfirmedhistory or barstate.isrealtime",
        "    table.cell(testTable, 0, 0, 'Last closed trade:')",
        "    table.cell(testTable, 0, 1, \"Order stop price value: \" + strategy.closedtrades.entry_comment(strategy.closedtrades - 1))",
        "    table.cell(testTable, 0, 2, \"Actual Entry Price: \" + str.tostring(strategy.closedtrades.entry_price(strategy.closedtrades - 1)))"
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.entry](#fun_strategy.entry)",
        "[strategy.closedtrades](#var_strategy.closedtrades)"
      ],
      "syntax": ["strategy.closedtrades.entry_comment(trade_num) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "strategy.closedtrades.exit_comment",
      "desc": [
        "Returns the comment message of the closed trade's exit, or\n[na](#var_na) if there is no entry with this `trade_num`."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the closed trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.closedtrades.exit_comment()` Example\", overlay = true)",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "    strategy.entry(\"Long\", strategy.long)",
        "    strategy.exit(\"Exit\", stop = open * 0.95, limit = close * 1.05, trail_points = 100, trail_offset = 0, comment_profit = \"TP\", comment_loss = \"SL\", comment_trailing = \"TRAIL\")",
        "",
        "exitStats() =>",
        "    int slCount = 0",
        "    int tpCount = 0",
        "    int trailCount = 0",
        "\t",
        "    if strategy.closedtrades > 0",
        "        for i = 0 to strategy.closedtrades - 1",
        "            switch strategy.closedtrades.exit_comment(i)",
        "                \"TP\"    => tpCount    += 1",
        "                \"SL\"    => slCount    += 1",
        "                \"TRAIL\" => trailCount += 1",
        "    [slCount, tpCount, trailCount]",
        "",
        "var testTable = table.new(position.top_right, 1, 4, color.orange, border_width = 1)",
        "",
        "if barstate.islastconfirmedhistory",
        "    [slCount, tpCount, trailCount] = exitStats()",
        "    table.cell(testTable, 0, 0, \"Closed trades (\" + str.tostring(strategy.closedtrades) +\") stats:\")",
        "    table.cell(testTable, 0, 1, \"Stop Loss: \" + str.tostring(slCount))",
        "    table.cell(testTable, 0, 2, \"Take Profit: \" + str.tostring(tpCount))",
        "    table.cell(testTable, 0, 3, \"Trailing Stop: \" + str.tostring(trailCount))"
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.exit](#fun_strategy.exit)",
        "[strategy.close](#fun_strategy.close)",
        "[strategy.closedtrades](#fun_strategy.closedtrades)"
      ],
      "syntax": ["strategy.closedtrades.exit_comment(trade_num) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "strategy.opentrades.entry_price",
      "desc": ["Returns the price of the open trade's entry."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.opentrades.entry_price Example 1\", overlay = true)",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if ta.crossover(close, ta.sma(close, 14))",
            "\tstrategy.entry(\"Long\", strategy.long)",
            "",
            "// Return the entry price for the latest closed trade.",
            "currEntryPrice = strategy.opentrades.entry_price(strategy.opentrades - 1)",
            "currExitPrice = currEntryPrice * 1.05",
            "",
            "if high >= currExitPrice",
            "\tstrategy.close(\"Long\")",
            "",
            "plot(currEntryPrice, \"Long entry price\", style = plot.style_linebr)",
            "plot(currExitPrice, \"Long exit price\", color.green, style = plot.style_linebr)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the average price for the open position.",
            "//@version=6",
            "strategy(\"strategy.opentrades.entry_price Example 2\", pyramiding = 2)",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Calculates the average price for the open position.",
            "avgOpenPositionPrice() =>",
            "    sumOpenPositionPrice = 0.0",
            "    for tradeNo = 0 to strategy.opentrades - 1",
            "        sumOpenPositionPrice += strategy.opentrades.entry_price(tradeNo) * strategy.opentrades.size(tradeNo) / strategy.position_size",
            "    result = nz(sumOpenPositionPrice / strategy.opentrades)",
            "",
            "plot(avgOpenPositionPrice())"
          ]
        }
      ],
      "seeAlso": ["[strategy.closedtrades.exit_price](#fun_strategy.closedtrades.exit_price)"],
      "syntax": ["strategy.opentrades.entry_price(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.entry_bar_index",
      "desc": ["Returns the bar_index of the open trade's entry."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "// Wait 10 bars and then close the position.",
            "//@version=6",
            "strategy(\"`strategy.opentrades.entry_bar_index` Example\")",
            "",
            "barsSinceLastEntry() =>",
            "    strategy.opentrades > 0 ? bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na",
            "",
            "// Enter a long position if there are no open positions.",
            "if strategy.opentrades == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "",
            "// Close the long position after 10 bars. ",
            "if barsSinceLastEntry() >= 10",
            "    strategy.close(\"Long\")"
          ]
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.entry_bar_index](#fun_strategy.closedtrades.entry_bar_index)",
        "[strategy.closedtrades.exit_bar_index](#fun_strategy.closedtrades.exit_bar_index)"
      ],
      "syntax": ["strategy.opentrades.entry_bar_index(trade_num) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "strategy.opentrades.entry_time",
      "desc": ["Returns the UNIX time of the open trade's entry, expressed in milliseconds."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"strategy.opentrades.entry_time Example\")",
        "",
        "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
        "if bar_index % 15 == 0",
        "    strategy.entry(\"Long\", strategy.long)",
        "if bar_index % 20 == 0",
        "    strategy.close(\"Long\")",
        "",
        "// Calculates duration in milliseconds since the last position was opened.",
        "timeSinceLastEntry()=>",
        "    strategy.opentrades > 0 ? (time - strategy.opentrades.entry_time(strategy.opentrades - 1)) : na",
        "",
        "plot(timeSinceLastEntry() / 1000 * 60 * 60 * 24, \"Days since last entry\")"
      ],
      "seeAlso": [
        "[strategy.closedtrades.entry_time](#fun_strategy.closedtrades.entry_time)",
        "[strategy.closedtrades.exit_time](#fun_strategy.closedtrades.exit_time)"
      ],
      "syntax": ["strategy.opentrades.entry_time(trade_num) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "strategy.opentrades.size",
      "desc": [
        "Returns the direction and the number of contracts traded in the open trade. If the value is > 0, the market position was long. If the value is < 0, the market position was short."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"`strategy.opentrades.size` Example 1\")",
            "",
            "// We calculate the max amt of shares we can buy.",
            "amtShares = math.floor(strategy.equity / close)",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long, qty = amtShares)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Plot the number of contracts in the latest open trade.",
            "plot(strategy.opentrades.size(strategy.opentrades - 1), \"Amount of contracts in latest open trade\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the average profit percentage for all open trades.",
            "//@version=6",
            "strategy(\"`strategy.opentrades.size` Example 2\")",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Calculate profit for all open trades.",
            "profitPct = 0.0",
            "for tradeNo = 0 to strategy.opentrades - 1",
            "    entryP = strategy.opentrades.entry_price(tradeNo)",
            "    exitP = close",
            "    profitPct += (exitP - entryP) / entryP * strategy.opentrades.size(tradeNo) * 100",
            "    ",
            "// Calculate average profit percent for all open trades.",
            "avgProfitPct = nz(profitPct / strategy.opentrades)",
            "plot(avgProfitPct)"
          ]
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.size](#fun_strategy.closedtrades.size)",
        "[strategy.position_size](#var_strategy.position_size)",
        "[strategy.opentrades](#var_strategy.opentrades)",
        "[strategy.closedtrades](#var_strategy.closedtrades)"
      ],
      "syntax": ["strategy.opentrades.size(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.profit",
      "desc": [
        "Returns the profit/loss of the open trade, expressed in [strategy.account_currency](#var_strategy.account_currency). Losses are expressed as negative values."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "// Returns the profit of the last open trade.",
            "//@version=6",
            "strategy(\"`strategy.opentrades.profit` Example 1\", commission_type = strategy.commission.percent, commission_value = 0.1)",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "plot(strategy.opentrades.profit(strategy.opentrades - 1), \"Profit of the latest open trade\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the profit for all open trades.",
            "//@version=6",
            "strategy(\"`strategy.opentrades.profit` Example 2\", pyramiding = 5)",
            "",
            "// Strategy calls to enter 5 long positions every 2 bars.",
            "if bar_index % 2 == 0",
            "    strategy.entry(\"Long\", strategy.long, qty = 5)",
            "",
            "// Calculate open profit or loss for the open positions.",
            "tradeOpenPL() =>",
            "    sumProfit = 0.0",
            "    for tradeNo = 0 to strategy.opentrades - 1",
            "        sumProfit += strategy.opentrades.profit(tradeNo)",
            "    result = sumProfit",
            "    ",
            "plot(tradeOpenPL(), \"Profit of all open trades\")"
          ]
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.profit](#fun_strategy.closedtrades.profit)",
        "[strategy.openprofit](#var_strategy.openprofit)",
        "[strategy.netprofit](#var_strategy.netprofit)",
        "[strategy.grossprofit](#var_strategy.grossprofit)"
      ],
      "syntax": ["strategy.opentrades.profit(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.commission",
      "desc": [
        "Returns the sum of entry and exit fees paid in the open trade, expressed in [strategy.account_currency](#var_strategy.account_currency)."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "// Calculates the gross profit or loss for the current open position.",
            "//@version=6",
            "strategy(\"`strategy.opentrades.commission` Example\", commission_type = strategy.commission.percent, commission_value = 0.1)",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Calculate gross profit or loss for open positions only.",
            "tradeOpenGrossPL() =>",
            "    sumOpenGrossPL = 0.0",
            "    for tradeNo = 0 to strategy.opentrades - 1",
            "        sumOpenGrossPL += strategy.opentrades.profit(tradeNo) - strategy.opentrades.commission(tradeNo)",
            "    result = sumOpenGrossPL",
            "    ",
            "plot(tradeOpenGrossPL())"
          ]
        }
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.closedtrades.commission](#fun_strategy.closedtrades.commission)"
      ],
      "syntax": ["strategy.opentrades.commission(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.max_runup",
      "desc": [
        "Returns the maximum run up of the open trade, i.e., the maximum possible profit during the trade, expressed in [strategy.account_currency](#var_strategy.account_currency)."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.opentrades.max_runup Example 1\")",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Plot the max runup of the latest open trade.",
            "plot(strategy.opentrades.max_runup(strategy.opentrades - 1), \"Max runup of the latest open trade\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the max trade runup value for all open trades.",
            "//@version=6",
            "strategy(\"strategy.opentrades.max_runup Example 2\", pyramiding = 100)",
            "",
            "// Enter a long position every 30 bars.",
            "if bar_index % 30 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "",
            "// Calculate biggest max trade runup value from all of the open trades.",
            "maxOpenTradeRunUp() =>",
            "    maxRunup = 0.0",
            "    for tradeNo = 0 to strategy.opentrades - 1",
            "        maxRunup := math.max(maxRunup, strategy.opentrades.max_runup(tradeNo))",
            "    result = maxRunup",
            "",
            "plot(maxOpenTradeRunUp(), \"Biggest max runup of all open trades\")"
          ]
        }
      ],
      "seeAlso": [
        "[strategy.closedtrades.max_runup](#fun_strategy.closedtrades.max_runup)",
        "[strategy.max_drawdown](#var_strategy.max_drawdown)"
      ],
      "syntax": ["strategy.opentrades.max_runup(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.max_drawdown",
      "desc": [
        "Returns the maximum drawdown of the open trade, i.e., the maximum possible loss during the trade, expressed in [strategy.account_currency](#var_strategy.account_currency)."
      ],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"strategy.opentrades.max_drawdown Example 1\")",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Plot the max drawdown of the latest open trade.",
            "plot(strategy.opentrades.max_drawdown(strategy.opentrades - 1), \"Max drawdown of the latest open trade\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the max trade drawdown value for all open trades.",
            "//@version=6",
            "strategy(\"`strategy.opentrades.max_drawdown` Example 2\", pyramiding = 100)",
            "",
            "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars.",
            "if bar_index % 15 == 0",
            "    strategy.entry(\"Long\", strategy.long)",
            "if bar_index % 20 == 0",
            "    strategy.close(\"Long\")",
            "",
            "// Get the biggest max trade drawdown value from all of the open trades.",
            "maxTradeDrawDown() =>",
            "    maxDrawdown = 0.0",
            "    for tradeNo = 0 to strategy.opentrades - 1",
            "        maxDrawdown := math.max(maxDrawdown, strategy.opentrades.max_drawdown(tradeNo))",
            "    result = maxDrawdown",
            "",
            "plot(maxTradeDrawDown(), \"Biggest max drawdown\")"
          ]
        }
      ],
      "remarks": [
        "The function returns na if trade_num is not in the range: 0 to strategy.closedtrades - 1."
      ],
      "seeAlso": [
        "[strategy.closedtrades.max_drawdown](#fun_strategy.closedtrades.max_drawdown)",
        "[strategy.max_drawdown](#var_strategy.max_drawdown)"
      ],
      "syntax": ["strategy.opentrades.max_drawdown(trade_num) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.opentrades.entry_id",
      "desc": ["Returns the id of the open trade's entry."],
      "args": [
        {
          "name": "trade_num",
          "desc": "The trade number of the open trade. The number of the first trade is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.opentrades.entry_id` Example\", overlay = true)",
        "",
        "// We enter a long position when 14 period sma crosses over 28 period sma.",
        "// We enter a short position when 14 period sma crosses under 28 period sma.",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "shortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))",
        "",
        "// Strategy calls to enter a long or short position when the corresponding condition is met.",
        "if longCondition",
        "    strategy.entry(\"Long entry at bar #\" + str.tostring(bar_index), strategy.long)",
        "if shortCondition",
        "    strategy.entry(\"Short entry at bar #\" + str.tostring(bar_index), strategy.short)",
        "",
        "// Display ID of the latest open position.",
        "if barstate.islastconfirmedhistory",
        "    label.new(bar_index, high + (2 * ta.tr), \"Last opened position is \\n \" + strategy.opentrades.entry_id(strategy.opentrades - 1))"
      ],
      "returns": ["Returns the id of the open trade's entry."],
      "remarks": [
        "The function returns na if trade_num is not in the range: 0 to strategy.opentrades-1."
      ],
      "seeAlso": [
        "[strategy.opentrades.entry_bar_index](#fun_strategy.opentrades.entry_bar_index)",
        "[strategy.opentrades.entry_price](#fun_strategy.opentrades.entry_price)",
        "[strategy.opentrades.entry_time](#fun_strategy.opentrades.entry_time)"
      ],
      "syntax": ["strategy.opentrades.entry_id(trade_num) → series string"],
      "returnedTypes": ["series string"]
    },
    {
      "name": "strategy.convert_to_account",
      "desc": [
        "Converts the value from the currency that the symbol on the chart is traded in ([syminfo.currency](#var_syminfo.currency)) to the currency used by the strategy ([strategy.account_currency](#var_strategy.account_currency))."
      ],
      "args": [
        {
          "name": "value",
          "desc": "The value to be converted.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "strategy(\"`strategy.convert_to_account` Example 1\", currency = currency.EUR)",
            "",
            "plot(close, \"Close price using default currency\")",
            "plot(strategy.convert_to_account(close), \"Close price converted to strategy currency\")"
          ]
        },
        {
          "desc": [],
          "examples": [
            "// Calculates the \"Buy and hold return\" using your account's currency.",
            "//@version=6",
            "strategy(\"`strategy.convert_to_account` Example 2\", currency = currency.EUR)",
            "",
            "dateInput = input.time(timestamp(\"20 Jul 2021 00:00 +0300\"), \"From Date\", confirm = true)",
            "",
            "buyAndHoldReturnPct(fromDate) =>",
            "    if time >= fromDate",
            "        money = close * syminfo.pointvalue",
            "        var initialBal = strategy.convert_to_account(money)",
            "        (strategy.convert_to_account(money) - initialBal) / initialBal * 100",
            "        ",
            "plot(buyAndHoldReturnPct(dateInput))"
          ]
        }
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.convert_to_symbol](#fun_strategy.convert_to_symbol)"
      ],
      "syntax": ["strategy.convert_to_account(value) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.default_entry_qty",
      "desc": [
        "Calculates the default quantity, in units, of an entry order from [strategy.entry](#fun_strategy.entry) or [strategy.order](#fun_strategy.order) if it were to fill at the specified `fill_price` value. The calculation depends on several strategy properties, including `default_qty_type`, `default_qty_value`, `currency`, and other parameters in the [strategy](#fun_strategy) function and their representation in the \"Properties\" tab of the strategy's settings."
      ],
      "args": [
        {
          "name": "fill_price",
          "desc": "The fill price for which to calculate the default order quantity.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"Supertrend Strategy\", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 15)",
        "",
        "//@variable The length of the ATR calculation.",
        "atrPeriod = input(10, \"ATR Length\")",
        "//@variable The ATR multiplier.",
        "factor = input.float(3.0, \"Factor\", step = 0.01)",
        "//@variable The tick offset of the stop order.",
        "stopOffsetInput = input.int(100, \"Tick offset for entry stop\")",
        "",
        "// Get the direction of the SuperTrend.",
        "[_, direction] = ta.supertrend(factor, atrPeriod)",
        "",
        "if ta.change(direction) < 0",
        "\t//@variable The stop price of the entry order.",
        "\tstopPrice = close + syminfo.mintick * stopOffsetInput",
        "\t//@variable The expected default fill quantity at the `stopPrice`. This value may not reflect actual qty of the filled order, because fill price may be different.",
        "\tcalculatedQty = strategy.default_entry_qty(stopPrice)",
        "\tstrategy.entry(\"My Long Entry Id\", strategy.long, stop = stopPrice)",
        "\tlabel.new(bar_index, stopPrice, str.format(\"Stop set at {0}\\nExpected qty at {0}: {1}\", math.round_to_mintick(stopPrice), calculatedQty))",
        "",
        "if ta.change(direction) > 0",
        "\tstrategy.close_all()"
      ],
      "remarks": [
        "This function does not consider open positions simulated by a strategy. For example, if a strategy script has an open position from a long order with a `qty` of 10 units, using the [strategy.entry](#fun_strategy.entry) function to simulate a short order with a `qty` of 5 will prompt the script to sell 15 units to reverse the position. This function will still return 5 in such a case since it doesn't consider an open trade.",
        "This value represents the default calculated quantity of an order.",
        "Order placement commands can override the default value by explicitly passing a new `qty` value in the function call."
      ],
      "syntax": ["strategy.default_entry_qty(fill_price) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "strategy.convert_to_symbol",
      "desc": [
        "Converts the value from the currency used by the strategy ([strategy.account_currency](#var_strategy.account_currency)) to the currency that the symbol on the chart is traded in ([syminfo.currency](#var_syminfo.currency))."
      ],
      "args": [
        {
          "name": "value",
          "desc": "The value to be converted.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"`strategy.convert_to_symbol` Example\", currency = currency.EUR)",
        "",
        "// Calculate the max qty we can buy using current chart's currency.",
        "calcContracts(accountMoney) =>",
        "    math.floor(strategy.convert_to_symbol(accountMoney) / syminfo.pointvalue / close)",
        "",
        "// Return max qty we can buy using 300 euros",
        "qt = calcContracts(300)",
        "",
        "// Strategy calls to enter long trades every 15 bars and exit long trades every 20 bars using our custom qty.",
        "if bar_index % 15 == 0",
        "    strategy.entry(\"Long\", strategy.long, qty = qt)",
        "if bar_index % 20 == 0",
        "    strategy.close(\"Long\")"
      ],
      "seeAlso": [
        "[strategy](#fun_strategy)",
        "[strategy.convert_to_account](#fun_strategy.convert_to_account)"
      ],
      "syntax": ["strategy.convert_to_symbol(value) → series float"],
      "returnedTypes": ["series float"]
    },
    {
      "name": "chart.point.from_index",
      "desc": [
        "Returns a [chart.point](#type_chart.point) object with `index` as its x-coordinate and `price` as its y-coordinate."
      ],
      "args": [
        {
          "name": "index",
          "desc": "The x-coordinate of the point, expressed as a bar index value.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "price",
          "desc": "The y-coordinate of the point.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "The `time` field values of [chart.point](#type_chart.point) instances returned from this function will be [na](#var_na), meaning drawing objects with `xloc` values set to `xloc.bar_time` will not work with them."
      ],
      "syntax": ["chart.point.from_index(index, price) → chart.point"],
      "returnedTypes": ["chart.point"]
    },
    {
      "name": "chart.point.copy",
      "desc": [
        "Creates a copy of a [chart.point](#type_chart.point) object with the specified `id`."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["chart.point.copy(id) → chart.point"],
      "returnedTypes": ["chart.point"]
    },
    {
      "name": "chart.point.from_time",
      "desc": [
        "Returns a [chart.point](#type_chart.point) object with `time` as its x-coordinate and `price` as its y-coordinate."
      ],
      "args": [
        {
          "name": "time",
          "desc": "The x-coordinate of the point, expressed as a UNIX time value, in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "price",
          "desc": "The y-coordinate of the point.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "The `index` field values of [chart.point](#type_chart.point) instances returned from this function will be [na](#var_na), meaning drawing objects with `xloc` values set to `xloc.bar_index` will not work with them."
      ],
      "syntax": ["chart.point.from_time(time, price) → chart.point"],
      "returnedTypes": ["chart.point"]
    },
    {
      "name": "chart.point.now",
      "desc": [
        "Returns a [chart.point](#type_chart.point) object with `price` as the y-coordinate"
      ],
      "args": [
        {
          "name": "price",
          "desc": "The y-coordinate of the point. Optional. The default is [close](#var_close).",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "The [chart.point](#type_chart.point) instance returned from this function records values for its `index` and `time` fields on the bar it executed on, making it suitable for use with drawing objects of any `xloc` type."
      ],
      "syntax": ["chart.point.now(price) → chart.point"],
      "returnedTypes": ["chart.point"]
    },
    {
      "name": "chart.point.new",
      "seeAlso": ["[polyline.new](#fun_polyline.new)"],
      "desc": [
        "Creates a new [chart.point](#type_chart.point) object with the specified `time`, `index`, and `price`."
      ],
      "args": [
        {
          "name": "time",
          "desc": "The x-coordinate of the point, expressed as a UNIX time value, in milliseconds.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "index",
          "desc": "The x-coordinate of the point, expressed as a bar index value.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "price",
          "desc": "The y-coordinate of the point.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "Whether a drawing object uses a point's `time` or `index` field as an x-coordinate depends on the `xloc` type used in the function call that returned the drawing.",
        "It's important to note that this function does not verify that the `time` and `index` values refer to the same bar."
      ],
      "syntax": ["chart.point.new(time, index, price) → chart.point"],
      "returnedTypes": ["chart.point"]
    },
    {
      "name": "line.set_first_point",
      "desc": ["Sets the first point of the `id` line to `point`."],
      "args": [
        {
          "name": "id",
          "desc": "A [line](#type_line) object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["line.set_first_point(id, point) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "line.set_second_point",
      "desc": ["Sets the second point of the `id` line to `point`."],
      "args": [
        {
          "name": "id",
          "desc": "A [line](#type_line) object.",
          "required": true,
          "allowedTypeIDs": ["series line"],
          "displayType": "series line"
        },
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["line.set_second_point(id, point) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "label.set_point",
      "desc": ["Sets the location of the `id` label to `point`."],
      "args": [
        {
          "name": "id",
          "desc": "A [label](#type_label) object.",
          "required": true,
          "allowedTypeIDs": ["series label"],
          "displayType": "series label"
        },
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["label.set_point(id, point) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_top_left_point",
      "desc": ["Sets the top-left corner location of the `id` box to `point`."],
      "args": [
        {
          "name": "id",
          "desc": "A [box](#type_box) object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["box.set_top_left_point(id, point) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "box.set_bottom_right_point",
      "desc": ["Sets the bottom-right corner location of the `id` box to `point`."],
      "args": [
        {
          "name": "id",
          "desc": "A [box](#type_box) object.",
          "required": true,
          "allowedTypeIDs": ["series box"],
          "displayType": "series box"
        },
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["box.set_bottom_right_point(id, point) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "library",
      "desc": [
        "Declaration statement identifying a script as a [library](https://www.tradingview.com/pine-script-docs/concepts/libraries/)."
      ],
      "args": [
        {
          "name": "title",
          "desc": "The title of the library and its identifier. It cannot contain spaces, special characters or begin with a digit. It is used as the publication's default title, and to uniquely identify the library in the [import](#kw_import) statement, when another script uses it. It is also used as the script's name on the chart.",
          "required": true,
          "allowedTypeIDs": ["const string"],
          "displayType": "const string"
        },
        {
          "name": "overlay",
          "desc": "If true, the library will be added over the chart. If false, it will be added in a separate pane. Optional. The default is false.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        },
        {
          "name": "dynamic_requests",
          "desc": "Specifies whether the script can dynamically call functions from the `request.*()` namespace. Dynamic `request.*()` calls are allowed within the local scopes of conditional structures (e.g., [if](#kw_if)), loops (e.g., [for](#kw_for)), and exported functions. Additionally, such calls allow \"series\" arguments for many of their parameters. Optional. The default is [true](#const_true). See the User Manual's [Dynamic requests](https://www.tradingview.com/pine-script-docs/concepts/other-timeframes-and-data/#dynamic-requests) section for more information.",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "// @description Math library",
        "library(\"num_methods\", overlay = true)",
        "// Calculate \"sinh()\" from the float parameter `x`",
        "export sinh(float x) =>",
        "\t(math.exp(x) - math.exp(-x)) / 2.0",
        "plot(sinh(0))"
      ],
      "seeAlso": ["[indicator](#fun_indicator)", "[strategy](#fun_strategy)"],
      "syntax": ["library(title, overlay, dynamic_requests) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "runtime.error",
      "desc": [
        "When called, causes a runtime error with the error message specified in the `message` argument."
      ],
      "args": [
        {
          "name": "message",
          "desc": "Error message.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "syntax": ["runtime.error(message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "log.info",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"info\" debug level.",
        "",
        "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function's argument list."
      ],
      "args": [
        {
          "name": "message",
          "desc": "Log message.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true, process_orders_on_close = true)",
        "bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "\tlimitLevel = close * 1.01",
        "\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)",
        "\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)",
        "",
        "\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)",
        "\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)",
        "",
        "if strategy.opentrades > 10",
        "\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)",
        "",
        "last10Perc = strategy.initial_capital / 10 > strategy.equity",
        "if (last10Perc and not last10Perc[1])",
        "\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
        "",
        "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
        "",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "",
        "The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
      ],
      "syntax": ["log.info(message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "log.info",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"info\" debug level.",
        "",
        "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function's argument list."
      ],
      "args": [
        {
          "name": "formatString",
          "desc": "Format string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "arg0, arg1, ...",
          "desc": "Values to format.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series string",
            "simple string",
            "input string",
            "const string",
            "array<int>",
            "array<float>",
            "array<bool>",
            "array<string>"
          ],
          "displayType": "series int/float/bool/string/array<int/float/bool/string>"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true, process_orders_on_close = true)",
        "bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "\tlimitLevel = close * 1.01",
        "\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)",
        "\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)",
        "",
        "\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)",
        "\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)",
        "",
        "if strategy.opentrades > 10",
        "\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)",
        "",
        "last10Perc = strategy.initial_capital / 10 > strategy.equity",
        "if (last10Perc and not last10Perc[1])",
        "\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
        "",
        "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
        "",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "",
        "The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
      ],
      "syntax": ["log.info(formatString, arg0, arg1, ...) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "log.warning",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"warning\" debug level.",
        "",
        "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function's argument list."
      ],
      "args": [
        {
          "name": "message",
          "desc": "Log message.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true, process_orders_on_close = true)",
        "bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "\tlimitLevel = close * 1.01",
        "\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)",
        "\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)",
        "",
        "\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)",
        "\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)",
        "",
        "if strategy.opentrades > 10",
        "\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)",
        "",
        "last10Perc = strategy.initial_capital / 10 > strategy.equity",
        "if (last10Perc and not last10Perc[1])",
        "\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
        "",
        "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
        "",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "",
        "The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
      ],
      "syntax": ["log.warning(message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "log.warning",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"warning\" debug level.",
        "",
        "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function's argument list."
      ],
      "args": [
        {
          "name": "formatString",
          "desc": "Format string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "arg0, arg1, ...",
          "desc": "Values to format.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series string",
            "simple string",
            "input string",
            "const string",
            "array<int>",
            "array<float>",
            "array<bool>",
            "array<string>"
          ],
          "displayType": "series int/float/bool/string/array<int/float/bool/string>"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true, process_orders_on_close = true)",
        "bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "\tlimitLevel = close * 1.01",
        "\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)",
        "\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)",
        "",
        "\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)",
        "\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)",
        "",
        "if strategy.opentrades > 10",
        "\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)",
        "",
        "last10Perc = strategy.initial_capital / 10 > strategy.equity",
        "if (last10Perc and not last10Perc[1])",
        "\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
        "",
        "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
        "",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "",
        "The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
      ],
      "syntax": ["log.warning(formatString, arg0, arg1, ...) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "log.error",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"error\" debug level.",
        "",
        "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function's argument list."
      ],
      "args": [
        {
          "name": "message",
          "desc": "Log message.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true, process_orders_on_close = true)",
        "bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "\tlimitLevel = close * 1.01",
        "\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)",
        "\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)",
        "",
        "\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)",
        "\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)",
        "",
        "if strategy.opentrades > 10",
        "\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)",
        "",
        "last10Perc = strategy.initial_capital / 10 > strategy.equity",
        "if (last10Perc and not last10Perc[1])",
        "\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
        "",
        "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
        "",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "",
        "The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
      ],
      "syntax": ["log.error(message) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "log.error",
      "desc": [
        "Converts the formatting string and value(s) into a formatted string, and sends the result to the \"Pine logs\" menu tagged with the \"error\" debug level.",
        "",
        "The formatting string can contain literal text and one placeholder in curly braces {} for each value to be formatted. Each placeholder consists of the index of the required argument (beginning at 0) that will replace it, and an optional format specifier. The index represents the position of that argument in the function's argument list."
      ],
      "args": [
        {
          "name": "formatString",
          "desc": "Format string.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "arg0, arg1, ...",
          "desc": "Values to format.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "series bool",
            "simple bool",
            "input bool",
            "const bool",
            "series string",
            "simple string",
            "input string",
            "const string",
            "array<int>",
            "array<float>",
            "array<bool>",
            "array<string>"
          ],
          "displayType": "series int/float/bool/string/array<int/float/bool/string>"
        }
      ],
      "examples": [
        "//@version=6",
        "strategy(\"My strategy\", overlay = true, process_orders_on_close = true)",
        "bracketTickSizeInput = input.int(1000, \"Stoploss/Take-Profit distance (in ticks)\")",
        "",
        "longCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))",
        "if (longCondition)",
        "\tlimitLevel = close * 1.01",
        "\tlog.info(\"Long limit order has been placed at {0}\", limitLevel)",
        "\tstrategy.order(\"My Long Entry Id\", strategy.long, limit = limitLevel)",
        "",
        "\tlog.info(\"Exit orders have been placed: Take-profit at {0}, Stop-loss at {1}\", close, limitLevel)",
        "\tstrategy.exit(\"Exit\", \"My Long Entry Id\", profit = bracketTickSizeInput, loss = bracketTickSizeInput)",
        "",
        "if strategy.opentrades > 10",
        "\tlog.warning(\"{0} positions opened in the same direction in a row. Try adjusting `bracketTickSizeInput`\", strategy.opentrades)",
        "",
        "last10Perc = strategy.initial_capital / 10 > strategy.equity",
        "if (last10Perc and not last10Perc[1])",
        "\tlog.error(\"The strategy has lost 90% of the initial capital!\")"
      ],
      "returns": ["The formatted string."],
      "remarks": [
        "Any curly braces within an unquoted pattern must be balanced. For example, \"ab {0} de\" and \"ab '}' de\" are valid patterns, but \"ab {0'}' de\", \"ab } de\" and \"''{''\" are not.",
        "",
        "The function can apply additional formatting to some values inside of the `{}`. The list of additional formatting options can be found in the EXAMPLE section of the [str.format](#fun_str.format) article.",
        "",
        "The string used as the `formatString` argument can contain single quote characters ('). However, one must pair all single quotes in that string to avoid unexpected formatting results.",
        "",
        "The \"Pine logs...\" button is accessible from the \"More\" dropdown in the Pine Editor and from the \"More\" dropdown in the status line of any script that uses `log.*()` functions."
      ],
      "syntax": ["log.error(formatString, arg0, arg1, ...) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "map.new<type,type>",
      "desc": [
        "Creates a new map object: a collection that consists of key-value pairs, where all keys are of the `keyType`, and all values are of the `valueType`.",
        "`keyType` can be a primitive type or enum. For example: [int](#type_int), [float](#type_float), [bool](#type_bool), [string](#type_string), [color](#type_color).",
        "`valueType` can be of any type except `array<>`, `matrix<>`, and `map<>`. User-defined types are allowed, even if they have `array<>`, `matrix<>`, or `map<>` as one of their fields."
      ],
      "args": [],
      "returns": ["The ID of a map object which may be used in other map.*() functions."],
      "syntax": ["map.new<keyType, valueType>() → map<keyType, valueType>"],
      "examples": [
        "//@version=6",
        "indicator(\"map.new<string, int> example\")",
        "a = map.new<string, int>()",
        "a.put(\"example\", 1)",
        "label.new(bar_index, close, str.tostring(a.get(\"example\")))"
      ],
      "remarks": [
        "Each key is unique and can only appear once. When adding a new value with a key that the map already contains, that value replaces the old value associated with the key.",
        "Maps maintain insertion order. Note that the order does not change when inserting a pair with a `key` that's already in the map. The new pair replaces the existing pair with the `key` in such cases."
      ],
      "seeAlso": [
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.get](#fun_map.get)",
        "[array.new<type>](#fun_array.new<type>)"
      ],
      "template": true
    },
    {
      "name": "map.copy",
      "desc": ["Creates a copy of an existing map."],
      "returns": ["A copy of the `id` map."],
      "args": [
        {
          "name": "id",
          "desc": "A map object to copy.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "syntax": ["map.copy(id) → map<keyType, valueType>"],
      "examples": [
        "//@version=6",
        "indicator(\"map.copy example\")",
        "a = map.new<string, int>()",
        "a.put(\"example\", 1)",
        "b = map.copy(a)",
        "a := map.new<string, int>()",
        "a.put(\"example\", 2)",
        "plot(a.get(\"example\"))",
        "plot(b.get(\"example\"))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.get](#fun_map.get)",
        "[map.size](#fun_map.size)"
      ]
    },
    {
      "name": "map.size",
      "desc": ["Returns the number of key-value pairs in the `id` map."],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.size example\")",
        "a = map.new<int, int>()",
        "size = 10",
        "for i = 0 to size",
        "\ta.put(i, size-i)",
        "plot(map.size(a))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.get](#fun_map.get)"
      ],
      "syntax": ["map.size(id) → series int"],
      "returnedTypes": ["series int"]
    },
    {
      "name": "map.get",
      "desc": ["Returns the value associated with the specified `key` in the `id` map."],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        },
        {
          "name": "key",
          "desc": "The key of the value to retrieve.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.get example\")",
        "a = map.new<int, int>()",
        "size = 10",
        "for i = 0 to size",
        "\ta.put(i, size-i)",
        "plot(map.get(a, 1))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.contains](#fun_map.contains)"
      ],
      "syntax": ["map.get(id, key) → <value_type>"],
      "returnedTypes": []
    },
    {
      "name": "map.contains",
      "desc": [
        "Returns [true](#const_true) if the `key` was found in the `id` map, [false](#const_false) otherwise."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        },
        {
          "name": "key",
          "desc": "The key to search in the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.includes example\")",
        "a = map.new<string, float>()",
        "a.put(\"open\", open)",
        "p = close",
        "if map.contains(a, \"open\")",
        "\tp := a.get(\"open\")",
        "plot(p)"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.size](#fun_map.size)"
      ],
      "syntax": ["map.contains(id, key) → series bool"],
      "returnedTypes": ["series bool"]
    },
    {
      "name": "map.keys",
      "desc": [
        "Returns an array of all the keys in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.keys example\")",
        "a = map.new<string, float>()",
        "a.put(\"open\", open)",
        "a.put(\"high\", high)",
        "a.put(\"low\", low)",
        "a.put(\"close\", close)",
        "keys = map.keys(a)",
        "ohlc = 0.0",
        "for key in keys",
        "\tohlc += a.get(key)",
        "plot(ohlc/4)"
      ],
      "remarks": [
        "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order."
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.get](#fun_map.get)",
        "[map.values](#fun_map.values)",
        "[map.size](#fun_map.size)"
      ],
      "syntax": ["map.keys(id) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "map.values",
      "desc": [
        "Returns an array of all the values in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.values example\")",
        "a = map.new<string, float>()",
        "a.put(\"open\", open)",
        "a.put(\"high\", high)",
        "a.put(\"low\", low)",
        "a.put(\"close\", close)",
        "values = map.values(a)",
        "ohlc = 0.0",
        "for value in values",
        "\tohlc += value",
        "plot(ohlc/4)"
      ],
      "remarks": [
        "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order."
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.get](#fun_map.get)",
        "[map.keys](#fun_map.keys)",
        "[map.size](#fun_map.size)"
      ],
      "syntax": ["map.values(id) → array<type>"],
      "returnedTypes": ["array<>"]
    },
    {
      "name": "map.put",
      "desc": ["Puts a new key-value pair into the `id` map."],
      "returns": [
        "The previous value associated with `key` if the key was already present in the map, or [na](#var_na) if the key is new."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        },
        {
          "name": "key",
          "desc": "The key to put into the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        },
        {
          "name": "value",
          "desc": "The key value to put into the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.put example\")",
        "a = map.new<string, float>()",
        "map.put(a, \"first\", 10)",
        "map.put(a, \"second\", 15)",
        "prevFirst = map.put(a, \"first\", 20)",
        "currFirst = a.get(\"first\")",
        "plot(prevFirst)",
        "plot(currFirst)"
      ],
      "remarks": [
        "Maps maintain insertion order. Note that the order does not change when inserting a pair with a `key` that's already in the map. The new pair replaces the existing pair with the `key` in such cases."
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put_all](#fun_map.put_all)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.remove](#fun_map.remove)"
      ],
      "syntax": ["map.put(id, key, value) → <value_type>"],
      "returnedTypes": []
    },
    {
      "name": "map.put_all",
      "desc": ["Puts all key-value pairs from the `id2` map into the `id` map."],
      "args": [
        {
          "name": "id",
          "desc": "A map object to append to.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        },
        {
          "name": "id2",
          "desc": "A map object to be appended.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.put_all example\")",
        "a = map.new<string, float>()",
        "b = map.new<string, float>()",
        "a.put(\"first\", 10)",
        "a.put(\"second\", 15)",
        "b.put(\"third\", 20)",
        "map.put_all(a, b)",
        "plot(a.get(\"third\"))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.remove](#fun_map.remove)"
      ],
      "syntax": ["map.put_all(id, id2) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "map.remove",
      "desc": ["Removes a key-value pair from the `id` map."],
      "returns": [
        "The previous value associated with `key` if the key was present in the map, or [na](#var_na) if there was no such key."
      ],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        },
        {
          "name": "key",
          "desc": "The key of the pair to remove from the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.remove example\")",
        "a = map.new<string, color>()",
        "a.put(\"firstColor\", color.green)",
        "oldColorValue = map.remove(a, \"firstColor\")",
        "plot(close, color = oldColorValue)"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.clear](#fun_map.clear)"
      ],
      "syntax": ["map.remove(id, key) → <value_type>"],
      "returnedTypes": []
    },
    {
      "name": "map.clear",
      "desc": ["Clears the map, removing all key-value pairs from it."],
      "args": [
        {
          "name": "id",
          "desc": "A map object.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.clear example\")",
        "oddMap = map.new<int, bool>()",
        "oddMap.put(1, true)",
        "oddMap.put(2, false)",
        "oddMap.put(3, true)",
        "map.clear(oddMap)",
        "plot(oddMap.size())"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put_all](#fun_map.put_all)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.remove](#fun_map.remove)"
      ],
      "syntax": ["map.clear(id) → void"],
      "returnedTypes": ["void"]
    },
    {
      "name": "polyline.new",
      "seeAlso": ["[chart.point.new](#fun_chart.point.new)"],
      "desc": [
        "Creates a new [polyline](#type_polyline) instance and displays it on the chart, sequentially connecting all of the points in the `points` array with line segments. The segments in the drawing can be straight or curved depending on the `curved` parameter."
      ],
      "returns": [
        "The ID of a new polyline object that a script can use in other `polyline.*()` functions."
      ],
      "args": [
        {
          "name": "points",
          "desc": "An array of [chart.point](#type_chart.point) objects for the drawing to sequentially connect.",
          "required": true,
          "allowedTypeIDs": ["array<chart.point>"],
          "displayType": "array<chart.point>"
        },
        {
          "name": "curved",
          "desc": "If [true](#const_true), the drawing will connect all points from the `points` array using curved line segments. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "closed",
          "desc": "If [true](#const_true), the drawing will also connect the first point to the last point from the `points` array, resulting in a closed polyline. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        },
        {
          "name": "xloc",
          "desc": "Determines the field of the [chart.point](#type_chart.point) objects in the `points` array that the polyline will use for its x-coordinates. If [xloc.bar_index](#const_xloc.bar_index), the polyline will use the `index` field from each point. If [xloc.bar_time](#const_xloc.bar_time), it will use the `time` field. Optional. The default is [xloc.bar_index](#const_xloc.bar_index).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "line_color",
          "desc": "The color of the line segments. Optional. The default is [color.blue](#const_color.blue).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "fill_color",
          "desc": "The fill color of the polyline. Optional. The default is [na](#var_na).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "line_style",
          "desc": "The style of the polyline. Possible values: [line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed), [line.style_arrow_left](#const_line.style_arrow_left), [line.style_arrow_right](#const_line.style_arrow_right), [line.style_arrow_both](#const_line.style_arrow_both). Optional. The default is [line.style_solid](#const_line.style_solid).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "line_width",
          "desc": "The width of the line segments, expressed in pixels. Optional. The default is 1.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "force_overlay",
          "desc": "If [true](#const_true), the drawing will display on the main chart pane, even when the script occupies a separate pane. Optional. The default is [false](#const_false).",
          "allowedTypeIDs": ["const bool"],
          "displayType": "const bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Polylines example\", overlay = true)",
        "",
        "//@variable If `true`, connects all points in the polyline with curved line segments. ",
        "bool curvedInput = input.bool(false, \"Curve Polyline\")",
        "//@variable If `true`, connects the first point in the polyline to the last point.",
        "bool closedInput = input.bool(true, \"Close Polyline\")",
        "//@variable The color of the space filled by the polyline.",
        "color fillcolor = input.color(color.new(color.blue, 90), \"Fill Color\")",
        "",
        "// Time and price inputs for the polyline's points. ",
        "p1x = input.time(0,  \"p1\", confirm = true, inline = \"p1\")",
        "p1y = input.price(0, \"  \", confirm = true, inline = \"p1\")",
        "p2x = input.time(0,  \"p2\", confirm = true, inline = \"p2\")",
        "p2y = input.price(0, \"  \", confirm = true, inline = \"p2\")",
        "p3x = input.time(0,  \"p3\", confirm = true, inline = \"p3\")",
        "p3y = input.price(0, \"  \", confirm = true, inline = \"p3\")",
        "p4x = input.time(0,  \"p4\", confirm = true, inline = \"p4\")",
        "p4y = input.price(0, \"  \", confirm = true, inline = \"p4\")",
        "p5x = input.time(0,  \"p5\", confirm = true, inline = \"p5\")",
        "p5y = input.price(0, \"  \", confirm = true, inline = \"p5\")",
        "",
        "if barstate.islastconfirmedhistory",
        "\t//@variable An array of `chart.point` objects for the new polyline.",
        "\tvar points = array.new<chart.point>()",
        "\t// Push new `chart.point` instances into the `points` array.",
        "\tpoints.push(chart.point.from_time(p1x, p1y))",
        "\tpoints.push(chart.point.from_time(p2x, p2y))",
        "\tpoints.push(chart.point.from_time(p3x, p3y))",
        "\tpoints.push(chart.point.from_time(p4x, p4y))",
        "\tpoints.push(chart.point.from_time(p5x, p5y))",
        "\t// Add labels for each `chart.point` in `points`.",
        "\tl1p1 = label.new(points.get(0), text = \"p1\", xloc = xloc.bar_time, color = na)",
        "\tl1p2 = label.new(points.get(1), text = \"p2\", xloc = xloc.bar_time, color = na)",
        "\tl2p1 = label.new(points.get(2), text = \"p3\", xloc = xloc.bar_time, color = na)",
        "\tl2p2 = label.new(points.get(3), text = \"p4\", xloc = xloc.bar_time, color = na)",
        "\t// Create a new polyline that connects each `chart.point` in the `points` array, starting from the first.",
        "\tpolyline.new(points, curved = curvedInput, closed = closedInput, fill_color = fillcolor, xloc = xloc.bar_time)"
      ],
      "syntax": [
        "polyline.new(points, curved, closed, xloc, line_color, fill_color, line_style, line_width, force_overlay) → series polyline"
      ],
      "returnedTypes": ["series polyline"]
    },
    {
      "name": "polyline.delete",
      "desc": [
        "Deletes the specified [polyline](#type_polyline) object. It has no effect if the `id` doesn't exist."
      ],
      "args": [
        {
          "name": "id",
          "desc": "The polyline ID to delete.",
          "required": true,
          "allowedTypeIDs": ["series polyline"],
          "displayType": "series polyline"
        }
      ],
      "syntax": ["polyline.delete(id) → void"],
      "returnedTypes": ["void"]
    }
  ],
  "methods": [
    {
      "name": "copy",
      "desc": ["Clones the box object."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator('Last 50 bars price ranges', overlay = true)",
        "LOOKBACK = 50",
        "highest = ta.highest(LOOKBACK)",
        "lowest = ta.lowest(LOOKBACK)",
        "if barstate.islastconfirmedhistory",
        "\tvar BoxLast = box.new(bar_index[LOOKBACK], highest, bar_index, lowest, bgcolor = color.new(color.green, 80))",
        "\tvar BoxPrev = box.copy(BoxLast)",
        "\tbox.set_lefttop(BoxPrev, bar_index[LOOKBACK * 2], highest[50])",
        "\tbox.set_rightbottom(BoxPrev, bar_index[LOOKBACK], lowest[50])",
        "\tbox.set_bgcolor(BoxPrev, color.new(color.red, 80))"
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.delete](#fun_box.delete)"],
      "syntax": ["box.copy(id) → series box"],
      "returnedTypes": ["series box"],
      "originalName": "box.copy",
      "thisType": ["series box"]
    },
    {
      "name": "delete",
      "desc": ["Deletes the specified box object. If it has already been deleted, does nothing."],
      "args": [],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.delete(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.delete",
      "thisType": ["series box"]
    },
    {
      "name": "get_left",
      "desc": [
        "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the left border of the box."
      ],
      "args": [],
      "returns": ["A bar index or a UNIX timestamp (in milliseconds)."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_left](#fun_box.set_left)"],
      "syntax": ["box.get_left(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "box.get_left",
      "thisType": ["series box"]
    },
    {
      "name": "get_right",
      "desc": [
        "Returns the bar index or the UNIX time (depending on the last value used for 'xloc') of the right border of the box."
      ],
      "args": [],
      "returns": ["A bar index or a UNIX timestamp (in milliseconds)."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_right](#fun_box.set_right)"],
      "syntax": ["box.get_right(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "box.get_right",
      "thisType": ["series box"]
    },
    {
      "name": "get_top",
      "desc": ["Returns the price value of the top border of the box."],
      "args": [],
      "returns": ["The price value."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_top](#fun_box.set_top)"],
      "syntax": ["box.get_top(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "box.get_top",
      "thisType": ["series box"]
    },
    {
      "name": "get_bottom",
      "desc": ["Returns the price value of the bottom border of the box."],
      "args": [],
      "returns": ["The price value."],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.set_bottom](#fun_box.set_bottom)"],
      "syntax": ["box.get_bottom(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "box.get_bottom",
      "thisType": ["series box"]
    },
    {
      "name": "set_left",
      "desc": ["Sets the left coordinate of the box."],
      "args": [
        {
          "name": "left",
          "desc": "Bar index or bar time of the left border. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_left](#fun_box.get_left)"],
      "syntax": ["box.set_left(id, left) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_left",
      "thisType": ["series box"]
    },
    {
      "name": "set_lefttop",
      "desc": ["Sets the left and top coordinates of the box."],
      "args": [
        {
          "name": "left",
          "desc": "Bar index or bar time of the left border.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "top",
          "desc": "Price value of the top border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.get_left](#fun_box.get_left)",
        "[box.get_top](#fun_box.get_top)"
      ],
      "syntax": ["box.set_lefttop(id, left, top) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_lefttop",
      "thisType": ["series box"]
    },
    {
      "name": "set_right",
      "desc": ["Sets the right coordinate of the box."],
      "args": [
        {
          "name": "right",
          "desc": "Bar index or bar time of the right border. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_right](#fun_box.get_right)"],
      "syntax": ["box.set_right(id, right) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_right",
      "thisType": ["series box"]
    },
    {
      "name": "set_rightbottom",
      "desc": ["Sets the right and bottom coordinates of the box."],
      "args": [
        {
          "name": "right",
          "desc": "Bar index or bar time of the right border.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "bottom",
          "desc": "Price value of the bottom border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[box.get_right](#fun_box.get_right)",
        "[box.get_bottom](#fun_box.get_bottom)"
      ],
      "syntax": ["box.set_rightbottom(id, right, bottom) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_rightbottom",
      "thisType": ["series box"]
    },
    {
      "name": "set_top",
      "desc": ["Sets the top coordinate of the box."],
      "args": [
        {
          "name": "top",
          "desc": "Price value of the top border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_top](#fun_box.get_top)"],
      "syntax": ["box.set_top(id, top) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_top",
      "thisType": ["series box"]
    },
    {
      "name": "set_bottom",
      "desc": ["Sets the bottom coordinate of the box."],
      "args": [
        {
          "name": "bottom",
          "desc": "Price value of the bottom border.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)", "[box.get_bottom](#fun_box.get_bottom)"],
      "syntax": ["box.set_bottom(id, bottom) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_bottom",
      "thisType": ["series box"]
    },
    {
      "name": "set_border_color",
      "desc": ["Sets the border color of the box."],
      "args": [
        {
          "name": "color",
          "desc": "New border color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.set_border_color(id, color) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_border_color",
      "thisType": ["series box"]
    },
    {
      "name": "set_bgcolor",
      "desc": ["Sets the background color of the box."],
      "args": [
        {
          "name": "color",
          "desc": "New background color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.set_bgcolor(id, color) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_bgcolor",
      "thisType": ["series box"]
    },
    {
      "name": "set_border_width",
      "desc": ["Sets the border width of the box."],
      "args": [
        {
          "name": "width",
          "desc": "Width of the four borders, in pixels.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[box.new](#fun_box.new)"],
      "syntax": ["box.set_border_width(id, width) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_border_width",
      "thisType": ["series box"]
    },
    {
      "name": "set_border_style",
      "desc": ["Sets the border style of the box."],
      "args": [
        {
          "name": "style",
          "desc": "New border style.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[line.style_solid](#const_line.style_solid), [line.style_dotted](#const_line.style_dotted), [line.style_dashed](#const_line.style_dashed)"
      ],
      "syntax": ["box.set_border_style(id, style) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_border_style",
      "thisType": ["series box"]
    },
    {
      "name": "set_extend",
      "desc": [
        "Sets extending type of the border of this box object. When [extend.none](#const_extend.none) is used, the horizontal borders start at the left border and end at the right border. With [extend.left](#const_extend.left) or [extend.right](#const_extend.right), the horizontal borders are extended indefinitely to the left or right of the box, respectively. With [extend.both](#const_extend.both), the horizontal borders are extended on both sides."
      ],
      "args": [
        {
          "name": "extend",
          "desc": "New extending type.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[extend.none](#const_extend.none), [extend.right](#const_extend.right), [extend.left](#const_extend.left), [extend.both](#const_extend.both)"
      ],
      "syntax": ["box.set_extend(id, extend) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_extend",
      "thisType": ["series box"]
    },
    {
      "name": "set_text_font_family",
      "desc": ["The function sets the font family of the text inside the box."],
      "args": [
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Example of setting the box font\")",
        "if barstate.islastconfirmedhistory",
        "    b = box.new(bar_index, open-ta.tr, bar_index-50, open-ta.tr*5, text=\"monospace\")",
        "    box.set_text_font_family(b, font.family_monospace)"
      ],
      "seeAlso": [
        "[box.new](#fun_box.new)",
        "[font.family_default](#const_font.family_default)",
        "[font.family_monospace](#const_font.family_monospace)"
      ],
      "syntax": ["box.set_text_font_family(id, text_font_family) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_font_family",
      "thisType": ["series box"]
    },
    {
      "name": "set_text_halign",
      "desc": ["The function sets the horizontal alignment of the box's text."],
      "args": [
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of a box's text. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_color](#fun_box.set_text_color)"
      ],
      "syntax": ["box.set_text_halign(id, text_halign) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_halign",
      "thisType": ["series box"]
    },
    {
      "name": "set_text_valign",
      "desc": ["The function sets the vertical alignment of a box's text."],
      "args": [
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the box's text. Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_halign](#fun_box.set_text_halign)"
      ],
      "syntax": ["box.set_text_valign(id, text_valign) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_valign",
      "thisType": ["series box"]
    },
    {
      "name": "set_text_size",
      "desc": ["The function sets the size of the box's text."],
      "args": [
        {
          "name": "text_size",
          "desc": "Size of the box's text. The size can be any positive integer, or one of the `size.*` built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36).",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)"
      ],
      "syntax": ["box.set_text_size(id, text_size) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_size",
      "thisType": ["series box"]
    },
    {
      "name": "set_text",
      "desc": ["The function sets the text in the box."],
      "args": [
        {
          "name": "text",
          "desc": "The text to be displayed inside the box.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)",
        "[box.set_text_formatting](#fun_box.set_text_formatting)"
      ],
      "syntax": ["box.set_text(id, text) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text",
      "thisType": ["series box"]
    },
    {
      "name": "set_text_formatting",
      "desc": ["Sets the formatting attributes the drawing applies to displayed text."],
      "args": [
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic).",
          "required": true,
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "seeAlso": [
        "[box.set_text_color](#fun_box.set_text_color)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)",
        "[box.set_text](#fun_box.set_text)"
      ],
      "syntax": ["box.set_text_formatting(id, text_formatting) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_formatting",
      "thisType": ["series box"]
    },
    {
      "name": "set_text_color",
      "desc": ["The function sets the color of the text inside the box."],
      "args": [
        {
          "name": "text_color",
          "desc": "The color of the text.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)"
      ],
      "syntax": ["box.set_text_color(id, text_color) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_color",
      "thisType": ["series box"]
    },
    {
      "name": "copy",
      "desc": ["Clones the line object."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator('Last 100 bars price range', overlay = true)",
        "LOOKBACK = 100",
        "highest = ta.highest(LOOKBACK)",
        "lowest = ta.lowest(LOOKBACK)",
        "if barstate.islastconfirmedhistory",
        "\tvar lineTop = line.new(bar_index[LOOKBACK], highest, bar_index, highest, color = color.green)",
        "\tvar lineBottom = line.copy(lineTop)",
        "\tline.set_y1(lineBottom, lowest)",
        "\tline.set_y2(lineBottom, lowest)",
        "\tline.set_color(lineBottom, color.red)"
      ],
      "returns": [
        "New line ID object which may be passed to line.setXXX and line.getXXX functions."
      ],
      "seeAlso": ["[line.new](#fun_line.new)", "[line.delete](#fun_line.delete)"],
      "syntax": ["line.copy(id) → series line"],
      "returnedTypes": ["series line"],
      "originalName": "line.copy",
      "thisType": ["series line"]
    },
    {
      "name": "set_text_wrap",
      "desc": ["The function sets the mode of wrapping of the text inside the box."],
      "args": [
        {
          "name": "text_wrap",
          "desc": "Whether to wrap text. Wrapped text starts a new line when it reaches the side of the box. Wrapped text lower than the bottom of the box is not displayed. Unwrapped text stays on a single line and *is displayed* past the width of the box if it is too long. If the `text_size` is 0 or [text.wrap_auto](#const_text.wrap_auto), this setting has no effect. Possible values: [text.wrap_none](#const_text.wrap_none), [text.wrap_auto](#const_text.wrap_auto).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[box.set_text](#fun_box.set_text)",
        "[box.set_text_size](#fun_box.set_text_size)",
        "[box.set_text_valign](#fun_box.set_text_valign)",
        "[box.set_text_halign](#fun_box.set_text_halign)",
        "[box.set_text_color](#fun_box.set_text_color)"
      ],
      "syntax": ["box.set_text_wrap(id, text_wrap) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_text_wrap",
      "thisType": ["series box"]
    },
    {
      "name": "set_x1",
      "desc": ["Sets bar index or bar time (depending on the xloc) of the first point."],
      "args": [
        {
          "name": "x",
          "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_x1(id, x) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_x1",
      "thisType": ["series line"]
    },
    {
      "name": "set_y1",
      "desc": ["Sets price of the first point"],
      "args": [
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_y1(id, y) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_y1",
      "thisType": ["series line"]
    },
    {
      "name": "set_xy1",
      "desc": ["Sets bar index/time and price of the first point."],
      "args": [
        {
          "name": "x",
          "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_xy1(id, x, y) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_xy1",
      "thisType": ["series line"]
    },
    {
      "name": "set_x2",
      "desc": ["Sets bar index or bar time (depending on the xloc) of the second point."],
      "args": [
        {
          "name": "x",
          "desc": "Bar index or bar time. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_x2(id, x) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_x2",
      "thisType": ["series line"]
    },
    {
      "name": "set_y2",
      "desc": ["Sets price of the second point."],
      "args": [
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_y2(id, y) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_y2",
      "thisType": ["series line"]
    },
    {
      "name": "set_xy2",
      "desc": ["Sets bar index/time and price of the second point"],
      "args": [
        {
          "name": "x",
          "desc": "Bar index or bar time.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "Price.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_xy2(id, x, y) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_xy2",
      "thisType": ["series line"]
    },
    {
      "name": "set_xloc",
      "desc": ["Sets x-location and new bar index/time values."],
      "args": [
        {
          "name": "x1",
          "desc": "Bar index or bar time of the first point.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "x2",
          "desc": "Bar index or bar time of the second point.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "xloc",
          "desc": "New x-location value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[xloc.bar_index](#const_xloc.bar_index)",
        "[xloc.bar_time](#const_xloc.bar_time)",
        "[line.new](#fun_line.new)"
      ],
      "syntax": ["line.set_xloc(id, x1, x2, xloc) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_xloc",
      "thisType": ["series line"]
    },
    {
      "name": "set_extend",
      "desc": [
        "Sets extending type of this line object. If extend=[extend.none](#const_extend.none), draws segment starting at point (x1, y1) and ending at point (x2, y2). If extend is equal to [extend.right](#const_extend.right) or [extend.left](#const_extend.left), draws a ray starting at point (x1, y1) or (x2, y2), respectively. If extend=[extend.both](#const_extend.both), draws a straight line that goes through these points."
      ],
      "args": [
        {
          "name": "extend",
          "desc": "New extending type.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[extend.none](#const_extend.none)",
        "[extend.right](#const_extend.right)",
        "[extend.left](#const_extend.left)",
        "[extend.both](#const_extend.both)",
        "[line.new](#fun_line.new)"
      ],
      "syntax": ["line.set_extend(id, extend) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_extend",
      "thisType": ["series line"]
    },
    {
      "name": "set_color",
      "desc": ["Sets the line color"],
      "args": [
        {
          "name": "color",
          "desc": "New line color",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_color(id, color) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_color",
      "thisType": ["series line"]
    },
    {
      "name": "set_style",
      "desc": ["Sets the line style"],
      "args": [
        {
          "name": "style",
          "desc": "New line style.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[line.style_solid](#const_line.style_solid)",
        "[line.style_dotted](#const_line.style_dotted)",
        "[line.style_dashed](#const_line.style_dashed)",
        "[line.style_arrow_left](#const_line.style_arrow_left)",
        "[line.style_arrow_right](#const_line.style_arrow_right)",
        "[line.style_arrow_both](#const_line.style_arrow_both)",
        "[line.new](#fun_line.new)"
      ],
      "syntax": ["line.set_style(id, style) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_style",
      "thisType": ["series line"]
    },
    {
      "name": "set_width",
      "desc": ["Sets the line width."],
      "args": [
        {
          "name": "width",
          "desc": "New line width in pixels.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.set_width(id, width) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_width",
      "thisType": ["series line"]
    },
    {
      "name": "delete",
      "desc": ["Deletes the specified line object. If it has already been deleted, does nothing."],
      "args": [],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.delete(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.delete",
      "thisType": ["series line"]
    },
    {
      "name": "get_x1",
      "desc": [
        "Returns UNIX time or bar index (depending on the last xloc value set) of the first point of the line."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"line.get_x1\")",
        "my_line = line.new(time, open, time + 60 * 60 * 24, close, xloc=xloc.bar_time)",
        "a = line.get_x1(my_line)",
        "plot(time - line.get_x1(my_line)) //draws zero plot"
      ],
      "returns": ["UNIX timestamp (in milliseconds) or bar index."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_x1(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "line.get_x1",
      "thisType": ["series line"]
    },
    {
      "name": "get_y1",
      "desc": ["Returns price of the first point of the line."],
      "args": [],
      "returns": ["Price value."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_y1(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "line.get_y1",
      "thisType": ["series line"]
    },
    {
      "name": "get_x2",
      "desc": [
        "Returns UNIX time or bar index (depending on the last xloc value set) of the second point of the line."
      ],
      "args": [],
      "returns": ["UNIX timestamp (in milliseconds) or bar index."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_x2(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "line.get_x2",
      "thisType": ["series line"]
    },
    {
      "name": "get_y2",
      "desc": ["Returns price of the second point of the line."],
      "args": [],
      "returns": ["Price value."],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_y2(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "line.get_y2",
      "thisType": ["series line"]
    },
    {
      "name": "get_price",
      "desc": ["Returns the price level of a line at a given bar index."],
      "args": [
        {
          "name": "x",
          "desc": "Bar index for which price is required.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"GetPrice\", overlay=true)",
        "var line l = na",
        "if bar_index == 10",
        "    l := line.new(0, high[5], bar_index, high)",
        "plot(line.get_price(l, bar_index), color=color.green)"
      ],
      "returns": ["Price value of line 'id' at bar index 'x'."],
      "remarks": [
        "The line is considered to have been created using 'extend=extend.both'.",
        "This function can only be called for lines created using 'xloc.bar_index'. If you try to call it for a line created with 'xloc.bar_time', it will generate an error."
      ],
      "seeAlso": ["[line.new](#fun_line.new)"],
      "syntax": ["line.get_price(id, x) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "line.get_price",
      "thisType": ["series line"]
    },
    {
      "name": "copy",
      "desc": ["Clones the label object."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator('Last 100 bars highest/lowest', overlay = true)",
        "LOOKBACK = 100",
        "highest = ta.highest(LOOKBACK)",
        "highestBars = ta.highestbars(LOOKBACK)",
        "lowest = ta.lowest(LOOKBACK)",
        "lowestBars = ta.lowestbars(LOOKBACK)",
        "if barstate.islastconfirmedhistory",
        "\tvar labelHigh = label.new(bar_index + highestBars, highest, str.tostring(highest), color = color.green)",
        "\tvar labelLow = label.copy(labelHigh)",
        "\tlabel.set_xy(labelLow, bar_index + lowestBars, lowest)",
        "\tlabel.set_text(labelLow, str.tostring(lowest))",
        "\tlabel.set_color(labelLow, color.red)",
        "\tlabel.set_style(labelLow, label.style_label_up)"
      ],
      "returns": [
        "New label ID object which may be passed to label.setXXX and label.getXXX functions."
      ],
      "seeAlso": ["[label.new](#fun_label.new)", "[label.delete](#fun_label.delete)"],
      "syntax": ["label.copy(id) → series label"],
      "returnedTypes": ["series label"],
      "originalName": "label.copy",
      "thisType": ["series label"]
    },
    {
      "name": "delete",
      "desc": [
        "Deletes the specified linefill object. If it has already been deleted, does nothing."
      ],
      "args": [],
      "syntax": ["linefill.delete(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "linefill.delete",
      "thisType": ["series linefill"]
    },
    {
      "name": "set_color",
      "desc": ["The function sets the color of the linefill object passed to it."],
      "args": [
        {
          "name": "color",
          "desc": "The color of the linefill object.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "syntax": ["linefill.set_color(id, color) → void"],
      "returnedTypes": ["void"],
      "originalName": "linefill.set_color",
      "thisType": ["series linefill"]
    },
    {
      "name": "get_line1",
      "desc": ["Returns the ID of the first line used in the `id` linefill."],
      "args": [],
      "syntax": ["linefill.get_line1(id) → series line"],
      "returnedTypes": ["series line"],
      "originalName": "linefill.get_line1",
      "thisType": ["series linefill"]
    },
    {
      "name": "get_line2",
      "desc": ["Returns the ID of the second line used in the `id` linefill."],
      "args": [],
      "syntax": ["linefill.get_line2(id) → series line"],
      "returnedTypes": ["series line"],
      "originalName": "linefill.get_line2",
      "thisType": ["series linefill"]
    },
    {
      "name": "set_x",
      "desc": ["Sets bar index or bar time (depending on the xloc) of the label position."],
      "args": [
        {
          "name": "x",
          "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_x(id, x) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_x",
      "thisType": ["series label"]
    },
    {
      "name": "set_y",
      "desc": ["Sets price of the label position"],
      "args": [
        {
          "name": "y",
          "desc": "New price of the label position.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_y(id, y) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_y",
      "thisType": ["series label"]
    },
    {
      "name": "set_xy",
      "desc": ["Sets bar index/time and price of the label position."],
      "args": [
        {
          "name": "x",
          "desc": "New bar index or bar time of the label position. Note that objects positioned using [xloc.bar_index](#const_xloc.bar_index) cannot be drawn further than 500 bars into the future.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "y",
          "desc": "New price of the label position.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_xy(id, x, y) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_xy",
      "thisType": ["series label"]
    },
    {
      "name": "set_xloc",
      "desc": ["Sets x-location and new bar index/time value."],
      "args": [
        {
          "name": "x",
          "desc": "New bar index or bar time of the label position.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "xloc",
          "desc": "New x-location value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[xloc.bar_index](#const_xloc.bar_index)",
        "[xloc.bar_time](#const_xloc.bar_time)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_xloc(id, x, xloc) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_xloc",
      "thisType": ["series label"]
    },
    {
      "name": "set_yloc",
      "desc": ["Sets new y-location calculation algorithm."],
      "args": [
        {
          "name": "yloc",
          "desc": "New y-location value.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[yloc.price](#const_yloc.price)",
        "[yloc.abovebar](#const_yloc.abovebar)",
        "[yloc.belowbar](#const_yloc.belowbar)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_yloc(id, yloc) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_yloc",
      "thisType": ["series label"]
    },
    {
      "name": "set_text",
      "desc": ["Sets label text"],
      "args": [
        {
          "name": "text",
          "desc": "New label text.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[label.set_text_formatting](#fun_label.set_text_formatting)"
      ],
      "syntax": ["label.set_text(id, text) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_text",
      "thisType": ["series label"]
    },
    {
      "name": "set_text_formatting",
      "desc": ["Sets the formatting attributes the drawing applies to displayed text."],
      "args": [
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "required": true,
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)", "[label.set_text](#fun_label.set_text)"],
      "syntax": ["label.set_text_formatting(id, text_formatting) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_text_formatting",
      "thisType": ["series label"]
    },
    {
      "name": "set_text_font_family",
      "desc": ["The function sets the font family of the text inside the label."],
      "args": [
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Example of setting the label font\")",
        "if barstate.islastconfirmedhistory",
        "    l = label.new(bar_index, 0, \"monospace\", yloc=yloc.abovebar)",
        "    label.set_text_font_family(l, font.family_monospace)"
      ],
      "seeAlso": [
        "[label.new](#fun_label.new)",
        "[font.family_default](#const_font.family_default)",
        "[font.family_monospace](#const_font.family_monospace)"
      ],
      "syntax": ["label.set_text_font_family(id, text_font_family) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_text_font_family",
      "thisType": ["series label"]
    },
    {
      "name": "set_color",
      "desc": ["Sets label border and arrow color."],
      "args": [
        {
          "name": "color",
          "desc": "New label border and arrow color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_color(id, color) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_color",
      "thisType": ["series label"]
    },
    {
      "name": "set_style",
      "desc": ["Sets label style."],
      "args": [
        {
          "name": "style",
          "desc": "New label style. Possible values: [label.style_none](#const_label.style_none), [label.style_xcross](#const_label.style_xcross), [label.style_cross](#const_label.style_cross), [label.style_triangleup](#const_label.style_triangleup), [label.style_triangledown](#const_label.style_triangledown), [label.style_flag](#const_label.style_flag), [label.style_circle](#const_label.style_circle), [label.style_arrowup](#const_label.style_arrowup), [label.style_arrowdown](#const_label.style_arrowdown), [label.style_label_up](#const_label.style_label_up), [label.style_label_down](#const_label.style_label_down), [label.style_label_left](#const_label.style_label_left), [label.style_label_right](#const_label.style_label_right), [label.style_label_lower_left](#const_label.style_label_lower_left), [label.style_label_lower_right](#const_label.style_label_lower_right), [label.style_label_upper_left](#const_label.style_label_upper_left), [label.style_label_upper_right](#const_label.style_label_upper_right), [label.style_label_center](#const_label.style_label_center), [label.style_square](#const_label.style_square), [label.style_diamond](#const_label.style_diamond), [label.style_text_outline](#const_label.style_text_outline).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_style(id, style) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_style",
      "thisType": ["series label"]
    },
    {
      "name": "set_textcolor",
      "desc": ["Sets color of the label text."],
      "args": [
        {
          "name": "textcolor",
          "desc": "New text color.",
          "required": true,
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_textcolor(id, textcolor) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_textcolor",
      "thisType": ["series label"]
    },
    {
      "name": "set_size",
      "desc": ["Sets arrow and text size of the specified label object."],
      "args": [
        {
          "name": "size",
          "desc": "Size of the label. Accepts a positive [int](#type_int) value or one of the built-in `size.*` constants. The constants and their equivalent numeric sizes are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (\\~7), [size.small](#const_size.small) (\\~10), [size.normal](#const_size.normal) (12), [size.large](#const_size.large) (18), [size.huge](#const_size.huge) (24). The default value is [size.normal](#const_size.normal), which represents the numeric size of 12.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        }
      ],
      "seeAlso": [
        "[size.auto](#const_size.auto)",
        "[size.tiny](#const_size.tiny)",
        "[size.small](#const_size.small)",
        "[size.normal](#const_size.normal)",
        "[size.large](#const_size.large)",
        "[size.huge](#const_size.huge)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_size(id, size) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_size",
      "thisType": ["series label"]
    },
    {
      "name": "set_textalign",
      "desc": ["Sets the alignment for the label text."],
      "args": [
        {
          "name": "textalign",
          "desc": "Label text alignment. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[text.align_left](#const_text.align_left)",
        "[text.align_center](#const_text.align_center)",
        "[text.align_right](#const_text.align_right)",
        "[label.new](#fun_label.new)"
      ],
      "syntax": ["label.set_textalign(id, textalign) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_textalign",
      "thisType": ["series label"]
    },
    {
      "name": "set_tooltip",
      "desc": ["Sets the tooltip text."],
      "args": [
        {
          "name": "tooltip",
          "desc": "Tooltip text.",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.set_tooltip(id, tooltip) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_tooltip",
      "thisType": ["series label"]
    },
    {
      "name": "delete",
      "desc": ["Deletes the specified label object. If it has already been deleted, does nothing."],
      "args": [],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.delete(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.delete",
      "thisType": ["series label"]
    },
    {
      "name": "get_x",
      "desc": [
        "Returns UNIX time or bar index (depending on the last xloc value set) of this label's position."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"label.get_x\")",
        "my_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)",
        "a = label.get_x(my_label)",
        "plot(time - label.get_x(my_label)) //draws zero plot"
      ],
      "returns": ["UNIX timestamp (in milliseconds) or bar index."],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.get_x(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "label.get_x",
      "thisType": ["series label"]
    },
    {
      "name": "get_y",
      "desc": ["Returns price of this label's position."],
      "args": [],
      "returns": ["Floating point value representing price."],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.get_y(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "label.get_y",
      "thisType": ["series label"]
    },
    {
      "name": "get_text",
      "desc": ["Returns the text of this label object."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"label.get_text\")",
        "my_label = label.new(time, open, text=\"Open bar text\", xloc=xloc.bar_time)",
        "a = label.get_text(my_label)",
        "label.new(time, close, text = a + \" new\", xloc=xloc.bar_time)"
      ],
      "returns": ["String object containing the text of this label."],
      "seeAlso": ["[label.new](#fun_label.new)"],
      "syntax": ["label.get_text(id) → series string"],
      "returnedTypes": ["series string"],
      "originalName": "label.get_text",
      "thisType": ["series label"]
    },
    {
      "name": "copy",
      "desc": ["The function creates a copy of an existing array."],
      "syntax": ["array.copy(id) → array<type>"],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.copy example\")",
        "length = 5",
        "a = array.new_float(length, close)",
        "b = array.copy(a)",
        "a := array.new_float(length, open)",
        "plot(array.sum(a) / length)",
        "plot(array.sum(b) / length)"
      ],
      "returns": ["A copy of an array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "originalName": "array.copy",
      "thisType": ["array<>"]
    },
    {
      "name": "slice",
      "desc": [
        "The function creates a slice from an existing array. If an object from the slice changes, the changes are applied to both the new and the original arrays."
      ],
      "syntax": ["array.slice(id, index_from, index_to) → array<type>"],
      "args": [
        {
          "name": "index_from",
          "desc": "Zero-based index at which to begin extraction.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "index_to",
          "desc": "Zero-based index before which to end extraction. The function extracts up to but not including the element with this index.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.slice example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "// take elements from 0 to 4",
        "// *note that changes in slice also modify original array ",
        "slice = array.slice(a, 0, 5)",
        "plot(array.sum(a) / 10)",
        "plot(array.sum(slice) / 5)"
      ],
      "returns": ["A shallow copy of an array's slice."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "originalName": "array.slice",
      "thisType": ["array<>"]
    },
    {
      "name": "size",
      "desc": ["The function returns the number of elements in an array."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.size example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "// note that changes in slice also modify original array",
        "slice = array.slice(a, 0, 5)",
        "array.push(slice, open)",
        "// size was changed in slice and in original array",
        "plot(array.size(a))",
        "plot(array.size(slice))"
      ],
      "returns": ["The number of elements in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.sum](#fun_array.sum)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "syntax": ["array.size(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.size",
      "thisType": ["array<>"]
    },
    {
      "name": "first",
      "desc": ["Returns the array's first element. Throws a runtime error if the array is empty."],
      "syntax": ["array.first(id) → series <type>"],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.first example\")",
        "arr = array.new_int(3, 10)",
        "plot(array.first(arr))"
      ],
      "seeAlso": ["[array.last](#fun_array.last)", "[array.get](#fun_array.get)"],
      "originalName": "array.first",
      "thisType": ["array<>"]
    },
    {
      "name": "last",
      "desc": ["Returns the array's last element. Throws a runtime error if the array is empty."],
      "syntax": ["array.last(id) → series <type>"],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.last example\")",
        "arr = array.new_int(3, 10)",
        "plot(array.last(arr))"
      ],
      "seeAlso": ["[array.first](#fun_array.first)", "[array.get](#fun_array.get)"],
      "originalName": "array.last",
      "thisType": ["array<>"]
    },
    {
      "name": "every",
      "desc": [
        "Returns [true](#const_true) if all elements of the `id` array are [true](#const_true), [false](#const_false) otherwise."
      ],
      "args": [],
      "remarks": [
        "This function also works with arrays of [int](#type_int) and [float](#type_float) types, in which case zero values are considered [false](#const_false), and all others [true](#const_true)."
      ],
      "seeAlso": ["[array.some](#fun_array.some)", "[array.get](#fun_array.get)"],
      "syntax": ["array.every(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "array.every",
      "thisType": ["array<bool>"]
    },
    {
      "name": "some",
      "desc": [
        "Returns [true](#const_true) if at least one element of the `id` array is [true](#const_true), [false](#const_false) otherwise."
      ],
      "args": [],
      "remarks": [
        "This function also works with arrays of [int](#type_int) and [float](#type_float) types, in which case zero values are considered [false](#const_false), and all others [true](#const_true)."
      ],
      "seeAlso": ["[array.every](#fun_array.every)", "[array.get](#fun_array.get)"],
      "syntax": ["array.some(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "array.some",
      "thisType": ["array<bool>"]
    },
    {
      "name": "get",
      "desc": ["The function returns the value of the element at the specified index."],
      "syntax": ["array.get(id, index) → series <type>"],
      "args": [
        {
          "name": "index",
          "desc": "The index of the element whose value is to be returned.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.get example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i] - open[i])",
        "plot(array.get(a, 9))"
      ],
      "returns": ["The array element's value."],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.slice](#fun_array.slice)",
        "[array.sort](#fun_array.sort)"
      ],
      "originalName": "array.get",
      "thisType": ["array<>"]
    },
    {
      "name": "min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.min",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.min",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [
        {
          "name": "nth",
          "desc": "The nth smallest value to return, where zero is the smallest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id, nth) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.min",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "min",
      "desc": [
        "The function returns the smallest value, or the nth smallest value in a given array."
      ],
      "args": [
        {
          "name": "nth",
          "desc": "The nth smallest value to return, where zero is the smallest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.min\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "secondLowest = array.min(a, 1) // 0",
        "plot(secondLowest)"
      ],
      "returns": ["The smallest or the nth smallest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.min(id, nth) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.min",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.max",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.max",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [
        {
          "name": "nth",
          "desc": "The nth greatest value to return, where zero is the greatest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id, nth) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.max",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "max",
      "desc": [
        "The function returns the greatest value, or the nth greatest value in a given array."
      ],
      "args": [
        {
          "name": "nth",
          "desc": "The nth greatest value to return, where zero is the greatest. Optional. The default is zero.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.max\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "thirdHighest = array.max(a, 2) // 1",
        "plot(thirdHighest)"
      ],
      "returns": ["The greatest or the nth greatest value in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.max(id, nth) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.max",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "range",
      "desc": [
        "The function returns the difference between the min and max values from a given array."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.range example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.range(a))"
      ],
      "returns": ["The difference between the min and max values in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.range(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.range",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "range",
      "desc": [
        "The function returns the difference between the min and max values from a given array."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.range example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.range(a))"
      ],
      "returns": ["The difference between the min and max values in the array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.min](#fun_array.min)",
        "[array.max](#fun_array.max)",
        "[array.sum](#fun_array.sum)"
      ],
      "syntax": ["array.range(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.range",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "sum",
      "desc": ["The function returns the sum of an array's elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.sum example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.sum(a))"
      ],
      "returns": ["The sum of the array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.sum(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.sum",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "sum",
      "desc": ["The function returns the sum of an array's elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.sum example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.sum(a))"
      ],
      "returns": ["The sum of the array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.sum(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.sum",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "set",
      "desc": ["The function sets the value of the element at the specified index."],
      "args": [
        {
          "name": "index",
          "desc": "The index of the element to be modified.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "value",
          "desc": "The new value to be set.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.set example\")",
        "a = array.new_float(10)",
        "for i = 0 to 9",
        "\tarray.set(a, i, close[i])",
        "plot(array.sum(a) / 10)"
      ],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.get](#fun_array.get)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.set(id, index, value) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.set",
      "thisType": ["array<>"]
    },
    {
      "name": "fill",
      "desc": [
        "The function sets elements of an array to a single value. If no index is specified, all elements are set. If only a start index (default 0) is supplied, the elements starting at that index are set. If both index parameters are used, the elements from the starting index up to but not including the end index (default na) are set."
      ],
      "args": [
        {
          "name": "value",
          "desc": "Value to fill the array with.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        },
        {
          "name": "index_from",
          "desc": "Start index, default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "index_to",
          "desc": "End index, default is na. Must be one greater than the index of the last element to set.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.fill example\")",
        "a = array.new_float(10)",
        "array.fill(a, close)",
        "plot(array.sum(a))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.slice](#fun_array.slice)"
      ],
      "syntax": ["array.fill(id, value, index_from, index_to) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.fill",
      "thisType": ["array<>"]
    },
    {
      "name": "insert",
      "desc": ["The function changes the contents of an array by adding new elements in place."],
      "args": [
        {
          "name": "index",
          "desc": "The index at which to insert the value.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "value",
          "desc": "The value to add to the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.insert example\")",
        "a = array.new_float(5, close)",
        "array.insert(a, 0, open)",
        "plot(array.get(a, 5))"
      ],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)",
        "[array.unshift](#fun_array.unshift)"
      ],
      "syntax": ["array.insert(id, index, value) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.insert",
      "thisType": ["array<>"]
    },
    {
      "name": "join",
      "desc": [
        "The function creates and returns a new string by concatenating all the elements of an array, separated by the specified separator string."
      ],
      "args": [
        {
          "name": "separator",
          "desc": "The string used to separate each array element.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.join example\")",
        "a = array.new_float(5, 5)",
        "label.new(bar_index, close, array.join(a, \",\"))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.insert](#fun_array.insert)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)",
        "[array.unshift](#fun_array.unshift)"
      ],
      "syntax": ["array.join(id, separator) → series string"],
      "returnedTypes": ["series string"],
      "originalName": "array.join",
      "thisType": ["array<float>", "array<int>", "array<string>"]
    },
    {
      "name": "push",
      "desc": ["The function appends a value to an array."],
      "args": [
        {
          "name": "value",
          "desc": "The value of the element added to the end of the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.push example\")",
        "a = array.new_float(5, 0)",
        "array.push(a, open)",
        "plot(array.get(a, 5))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.insert](#fun_array.insert)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)",
        "[array.unshift](#fun_array.unshift)"
      ],
      "syntax": ["array.push(id, value) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.push",
      "thisType": ["array<>"]
    },
    {
      "name": "remove",
      "desc": [
        "The function changes the contents of an array by removing the element with the specified index."
      ],
      "syntax": ["array.remove(id, index) → series <type>"],
      "args": [
        {
          "name": "index",
          "desc": "The index of the element to remove.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.remove example\")",
        "a = array.new_float(5,high)",
        "removedEl = array.remove(a, 0)",
        "plot(array.size(a))",
        "plot(removedEl)"
      ],
      "returns": ["The value of the removed element."],
      "remarks": [
        "If the index is positive, the function counts forwards from the beginning of the array to the end. The index of the first element is 0, and the index of the last element is `array.size() - 1`. If the index is negative, the function counts backwards from the end of the array to the beginning. In this case, the index of the last element is -1, and the index of the first element is negative `array.size()`. For example, for an array that contains three elements, all of the following are valid arguments for the `index` parameter: 0, 1, 2, -1, -2, -3."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.insert](#fun_array.insert)",
        "[array.pop](#fun_array.pop)",
        "[array.shift](#fun_array.shift)"
      ],
      "originalName": "array.remove",
      "thisType": ["array<>"]
    },
    {
      "name": "pop",
      "desc": ["The function removes the last element from an array and returns its value."],
      "syntax": ["array.pop(id) → series <type>"],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.pop example\")",
        "a = array.new_float(5,high)",
        "removedEl = array.pop(a)",
        "plot(array.size(a))",
        "plot(removedEl)"
      ],
      "returns": ["The value of the removed element."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)",
        "[array.shift](#fun_array.shift)"
      ],
      "originalName": "array.pop",
      "thisType": ["array<>"]
    },
    {
      "name": "clear",
      "desc": ["The function removes all elements from an array."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.clear example\")",
        "a = array.new_float(5,high)",
        "array.clear(a)",
        "array.push(a, close)",
        "plot(array.get(a,0))",
        "plot(array.size(a))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.pop](#fun_array.pop)"
      ],
      "syntax": ["array.clear(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.clear",
      "thisType": ["array<>"]
    },
    {
      "name": "sort",
      "desc": ["The function sorts the elements of an array."],
      "args": [
        {
          "name": "order",
          "desc": "The sort order: order.ascending (default) or order.descending.",
          "allowedTypeIDs": [
            "series sort_order",
            "simple sort_order",
            "input sort_order",
            "const sort_order"
          ],
          "displayType": "series sort_order"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.sort example\")",
        "a = array.new_float(0,0)",
        "for i = 0 to 5",
        "\tarray.push(a, high[i])",
        "array.sort(a, order.descending)",
        "if barstate.islast",
        "\tlabel.new(bar_index, close, str.tostring(a))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.sort(id, order) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.sort",
      "thisType": ["array<float>", "array<int>", "array<string>"]
    },
    {
      "name": "sort_indices",
      "desc": [
        "Returns an array of indices which, when used to index the original array, will access its elements in their sorted order. It does not modify the original array."
      ],
      "args": [
        {
          "name": "order",
          "desc": "The sort order: order.ascending or order.descending. Optional. The default is order.ascending.",
          "allowedTypeIDs": [
            "series sort_order",
            "simple sort_order",
            "input sort_order",
            "const sort_order"
          ],
          "displayType": "series sort_order"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.sort_indices\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "sortedIndices = array.sort_indices(a) // [1, 2, 4, 0, 3]",
        "indexOfSmallestValue = array.get(sortedIndices, 0) // 1",
        "smallestValue = array.get(a, indexOfSmallestValue) // -2",
        "plot(smallestValue)"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.sort_indices(id, order) → array<int>"],
      "returnedTypes": ["array<int>"],
      "originalName": "array.sort_indices",
      "thisType": ["array<float>", "array<int>", "array<string>"]
    },
    {
      "name": "percentrank",
      "desc": ["Returns the percentile rank of the element at the specified `index`."],
      "args": [
        {
          "name": "index",
          "desc": "The index of the element for which the percentile rank should be calculated.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "remarks": [
        "Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentrank(id, index) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.percentrank",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "percentrank",
      "desc": ["Returns the percentile rank of the element at the specified `index`."],
      "args": [
        {
          "name": "index",
          "desc": "The index of the element for which the percentile rank should be calculated.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "remarks": [
        "Percentile rank is the percentage of how many elements in the array are less than or equal to the reference value."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentrank(id, index) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.percentrank",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "percentile_nearest_rank",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method."
      ],
      "args": [
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_nearest_rank(id, percentage) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.percentile_nearest_rank",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "percentile_nearest_rank",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using the nearest-rank method."
      ],
      "args": [
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_nearest_rank(id, percentage) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.percentile_nearest_rank",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "percentile_linear_interpolation",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation."
      ],
      "args": [
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring. Linear interpolation estimates the value between two ranks."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_linear_interpolation(id, percentage) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.percentile_linear_interpolation",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "percentile_linear_interpolation",
      "desc": [
        "Returns the value for which the specified percentage of array values (percentile) are less than or equal to it, using linear interpolation."
      ],
      "args": [
        {
          "name": "percentage",
          "desc": "The percentage of values that must be equal or less than the returned value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "remarks": [
        "In statistics, the percentile is the percent of ranking items that appear at or below a certain score. This measurement shows the percentage of scores within a standard frequency distribution that is lower than the percentile rank you're measuring. Linear interpolation estimates the value between two ranks."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.percentile_linear_interpolation(id, percentage) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.percentile_linear_interpolation",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "abs",
      "desc": [
        "Returns an array containing the absolute value of each element in the original array."
      ],
      "args": [],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.abs(id) → array<float>"],
      "returnedTypes": ["array<float>"],
      "originalName": "array.abs",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "abs",
      "desc": [
        "Returns an array containing the absolute value of each element in the original array."
      ],
      "args": [],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.abs(id) → array<int>"],
      "returnedTypes": ["array<int>"],
      "originalName": "array.abs",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "binary_search",
      "desc": [
        "The function returns the index of the value, or -1 if the value is not found. The array to search must be sorted in ascending order."
      ],
      "args": [
        {
          "name": "val",
          "desc": "The value to search for in the array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.binary_search\")",
        "a = array.from(5, -2, 0, 9, 1)",
        "array.sort(a) // [-2, 0, 1, 5, 9]",
        "position = array.binary_search(a, 0) // 1",
        "plot(position)"
      ],
      "remarks": [
        "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.binary_search(id, val) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.binary_search",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "binary_search_leftmost",
      "desc": [
        "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the next smallest element to the left of where the value would lie if it was in the array. The array to search must be sorted in ascending order."
      ],
      "args": [
        {
          "name": "val",
          "desc": "The value to search for in the array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_leftmost\")",
            "a = array.from(5, -2, 0, 9, 1)",
            "array.sort(a) // [-2, 0, 1, 5, 9]",
            "position = array.binary_search_leftmost(a, 3) // 2",
            "plot(position)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_leftmost, repetitive elements\")",
            "a = array.from(4, 5, 5, 5)",
            "// Returns the index of the first instance.",
            "position = array.binary_search_leftmost(a, 5) ",
            "plot(position) // Plots 1"
          ]
        }
      ],
      "remarks": [
        "A binary search works on arrays pre-sorted in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.binary_search_leftmost(id, val) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.binary_search_leftmost",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "binary_search_rightmost",
      "desc": [
        "The function returns the index of the value if it is found. When the value is not found, the function returns the index of the element to the right of where the value would lie if it was in the array. The array must be sorted in ascending order."
      ],
      "args": [
        {
          "name": "val",
          "desc": "The value to search for in the array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "detailedDesc": [
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_rightmost\")",
            "a = array.from(5, -2, 0, 9, 1)",
            "array.sort(a) // [-2, 0, 1, 5, 9]",
            "position = array.binary_search_rightmost(a, 3) // 3",
            "plot(position)"
          ]
        },
        {
          "desc": [],
          "examples": [
            "//@version=6",
            "indicator(\"array.binary_search_rightmost, repetitive elements\")",
            "a = array.from(4, 5, 5, 5)",
            "// Returns the index of the last instance.",
            "position = array.binary_search_rightmost(a, 5) ",
            "plot(position) // Plots 3"
          ]
        }
      ],
      "remarks": [
        "A binary search works on sorted arrays in ascending order. It begins by comparing an element in the middle of the array with the target value. If the element matches the target value, its position in the array is returned. If the element's value is greater than the target value, the search continues in the lower half of the array. If the element's value is less than the target value, the search continues in the upper half of the array. By doing this recursively, the algorithm progressively eliminates smaller and smaller portions of the array in which the target value cannot lie."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice)",
        "[array.reverse](#fun_array.reverse)",
        "[order.ascending](#const_order.ascending)",
        "[order.descending](#const_order.descending)"
      ],
      "syntax": ["array.binary_search_rightmost(id, val) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.binary_search_rightmost",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "concat",
      "desc": [
        "The function is used to merge two arrays. It pushes all elements from the second array to the first array, and returns the first array."
      ],
      "syntax": ["array.concat(id1, id2) → array<type>"],
      "args": [
        {
          "name": "id2",
          "desc": "The second array object.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.concat example\")",
        "a = array.new_float(0,0)",
        "b = array.new_float(0,0)",
        "for i = 0 to 4",
        "    array.push(a, high[i])",
        "    array.push(b, low[i])",
        "c = array.concat(a,b)",
        "plot(array.size(a))",
        "plot(array.size(b))",
        "plot(array.size(c))"
      ],
      "returns": ["The first array with merged elements from the second array."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.insert](#fun_array.insert)",
        "[array.slice](#fun_array.slice),"
      ],
      "originalName": "array.concat",
      "thisType": ["array<>"]
    },
    {
      "name": "avg",
      "desc": ["The function returns the mean of an array's elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.avg example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.avg(a))"
      ],
      "returns": ["Mean of array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.avg(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.avg",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "avg",
      "desc": ["The function returns the mean of an array's elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.avg example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.avg(a))"
      ],
      "returns": ["Mean of array's elements."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.avg(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.avg",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "stdev",
      "desc": ["The function returns the standard deviation of an array's elements."],
      "args": [
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.stdev example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.stdev(a))"
      ],
      "returns": ["The standard deviation of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)"
      ],
      "syntax": ["array.stdev(id, biased) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.stdev",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "stdev",
      "desc": ["The function returns the standard deviation of an array's elements."],
      "args": [
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.stdev example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.stdev(a))"
      ],
      "returns": ["The standard deviation of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)"
      ],
      "syntax": ["array.stdev(id, biased) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.stdev",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "variance",
      "desc": ["The function returns the variance of an array's elements."],
      "args": [
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.variance example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.variance(a))"
      ],
      "returns": ["The variance of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.stdev](#fun_array.stdev)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)",
        "[array.covariance](#fun_array.covariance)"
      ],
      "syntax": ["array.variance(id, biased) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.variance",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "variance",
      "desc": ["The function returns the variance of an array's elements."],
      "args": [
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.variance example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.variance(a))"
      ],
      "returns": ["The variance of the array's elements."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.stdev](#fun_array.stdev)",
        "[array.min](#fun_array.min)",
        "[array.avg](#fun_array.avg)",
        "[array.covariance](#fun_array.covariance)"
      ],
      "syntax": ["array.variance(id, biased) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.variance",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "covariance",
      "desc": ["The function returns the covariance of two arrays."],
      "args": [
        {
          "name": "id2",
          "desc": "An array object.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        },
        {
          "name": "biased",
          "desc": "Determines which estimate should be used. Optional. The default is true.",
          "allowedTypeIDs": ["series bool", "simple bool", "input bool", "const bool"],
          "displayType": "series bool"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.covariance example\")",
        "a = array.new_float(0)",
        "b = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "\tarray.push(b, open[i])",
        "plot(array.covariance(a, b))"
      ],
      "returns": ["The covariance of two arrays."],
      "remarks": [
        "If `biased` is true, function will calculate using a biased estimate of the entire population, if false - unbiased estimate of a sample."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.max](#fun_array.max)",
        "[array.stdev](#fun_array.stdev)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)"
      ],
      "syntax": ["array.covariance(id1, id2, biased) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.covariance",
      "thisType": ["array<int>", "array<float>"]
    },
    {
      "name": "mode",
      "desc": [
        "The function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.mode example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.mode(a))"
      ],
      "returns": [
        "The most frequently occurring value from the `id` array. If none exists, returns the smallest value instead."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[ta.mode](#fun_ta.mode)",
        "[matrix.mode](#fun_matrix.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.mode(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.mode",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "mode",
      "desc": [
        "The function returns the mode of an array's elements. If there are several values with the same frequency, it returns the smallest value."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.mode example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.mode(a))"
      ],
      "returns": [
        "The most frequently occurring value from the `id` array. If none exists, returns the smallest value instead."
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[ta.mode](#fun_ta.mode)",
        "[matrix.mode](#fun_matrix.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.mode(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.mode",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "median",
      "desc": ["The function returns the median of an array's elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.median example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.median(a))"
      ],
      "returns": ["The median of the array's elements."],
      "seeAlso": [
        "[array.median](#fun_array.median)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.median(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "array.median",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "median",
      "desc": ["The function returns the median of an array's elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.median example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.median(a))"
      ],
      "returns": ["The median of the array's elements."],
      "seeAlso": [
        "[array.median](#fun_array.median)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.min](#fun_array.min)"
      ],
      "syntax": ["array.median(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.median",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "standardize",
      "desc": ["The function returns the array of standardized elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.standardize example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "b = array.standardize(a)",
        "plot(array.min(b))",
        "plot(array.max(b))"
      ],
      "returns": ["The array of standardized elements."],
      "seeAlso": [
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.mode](#fun_array.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.standardize(id) → array<float>"],
      "returnedTypes": ["array<float>"],
      "originalName": "array.standardize",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "standardize",
      "desc": ["The function returns the array of standardized elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.standardize example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "b = array.standardize(a)",
        "plot(array.min(b))",
        "plot(array.max(b))"
      ],
      "returns": ["The array of standardized elements."],
      "seeAlso": [
        "[array.max](#fun_array.max)",
        "[array.min](#fun_array.min)",
        "[array.mode](#fun_array.mode)",
        "[array.avg](#fun_array.avg)",
        "[array.variance](#fun_array.variance)",
        "[array.stdev](#fun_array.stdev)"
      ],
      "syntax": ["array.standardize(id) → array<int>"],
      "returnedTypes": ["array<int>"],
      "originalName": "array.standardize",
      "thisType": ["array<float>", "array<int>"]
    },
    {
      "name": "indexof",
      "desc": [
        "The function returns the index of the first occurrence of the value, or -1 if the value is not found."
      ],
      "args": [
        {
          "name": "value",
          "desc": "The value to search in the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.indexof example\")",
        "a = array.new_float(5,high)",
        "index = array.indexof(a, high)",
        "plot(index)"
      ],
      "returns": ["The index of an element."],
      "seeAlso": [
        "[array.lastindexof](#fun_array.lastindexof)",
        "[array.get](#fun_array.get)",
        "[array.lastindexof](#fun_array.lastindexof)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)"
      ],
      "syntax": ["array.indexof(id, value) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.indexof",
      "thisType": ["array<>"]
    },
    {
      "name": "lastindexof",
      "desc": [
        "The function returns the index of the last occurrence of the value, or -1 if the value is not found."
      ],
      "args": [
        {
          "name": "value",
          "desc": "The value to search in the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.lastindexof example\")",
        "a = array.new_float(5,high)",
        "index = array.lastindexof(a, high)",
        "plot(index)"
      ],
      "returns": ["The index of an element."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)"
      ],
      "syntax": ["array.lastindexof(id, value) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "array.lastindexof",
      "thisType": ["array<>"]
    },
    {
      "name": "includes",
      "desc": ["The function returns true if the value was found in an array, false otherwise."],
      "args": [
        {
          "name": "value",
          "desc": "The value to search in the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.includes example\")",
        "a = array.new_float(5,high)",
        "p = close",
        "if array.includes(a, high)",
        "\tp := open",
        "plot(p)"
      ],
      "returns": ["True if the value was found in the array, false otherwise."],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.indexof](#fun_array.indexof)",
        "[array.shift](#fun_array.shift)",
        "[array.remove](#fun_array.remove)",
        "[array.insert](#fun_array.insert)"
      ],
      "syntax": ["array.includes(id, value) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "array.includes",
      "thisType": ["array<>"]
    },
    {
      "name": "shift",
      "desc": ["The function removes an array's first element and returns its value."],
      "syntax": ["array.shift(id) → series <type>"],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.shift example\")",
        "a = array.new_float(5,high)",
        "removedEl = array.shift(a)",
        "plot(array.size(a))",
        "plot(removedEl)"
      ],
      "returns": ["The value of the removed element."],
      "seeAlso": [
        "[array.unshift](#fun_array.unshift)",
        "[array.set](#fun_array.set)",
        "[array.push](#fun_array.push)",
        "[array.remove](#fun_array.remove)",
        "[array.includes](#fun_array.includes)"
      ],
      "originalName": "array.shift",
      "thisType": ["array<>"]
    },
    {
      "name": "unshift",
      "desc": ["The function inserts the value at the beginning of the array."],
      "args": [
        {
          "name": "value",
          "desc": "The value to add to the start of the array.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the array's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"array.unshift example\")",
        "a = array.new_float(5, 0)",
        "array.unshift(a, open)",
        "plot(array.get(a, 0))"
      ],
      "seeAlso": [
        "[array.shift](#fun_array.shift)",
        "[array.set](#fun_array.set)",
        "[array.insert](#fun_array.insert)",
        "[array.remove](#fun_array.remove)",
        "[array.indexof](#fun_array.indexof)"
      ],
      "syntax": ["array.unshift(id, value) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.unshift",
      "thisType": ["array<>"]
    },
    {
      "name": "reverse",
      "desc": [
        "The function reverses an array. The first array element becomes the last, and the last array element becomes the first."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"array.reverse example\")",
        "a = array.new_float(0)",
        "for i = 0 to 9",
        "\tarray.push(a, close[i])",
        "plot(array.get(a, 0))",
        "array.reverse(a)",
        "plot(array.get(a, 0))"
      ],
      "seeAlso": [
        "[array.new_float](#fun_array.new_float)",
        "[array.sort](#fun_array.sort)",
        "[array.push](#fun_array.push)",
        "[array.set](#fun_array.set)",
        "[array.avg](#fun_array.avg)"
      ],
      "syntax": ["array.reverse(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "array.reverse",
      "thisType": ["array<>"]
    },
    {
      "name": "delete",
      "desc": ["The function deletes a table."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"table.delete example\")",
        "var testTable = table.new(position = position.top_right, columns = 2, rows = 1, bgcolor = color.yellow, border_width = 1)",
        "if barstate.islast",
        "    table.cell(table_id = testTable, column = 0, row = 0, text = \"Open is \" + str.tostring(open))",
        "    table.cell(table_id = testTable, column = 1, row = 0, text = \"Close is \" + str.tostring(close), bgcolor=color.teal)",
        "if barstate.isrealtime",
        "    table.delete(testTable)"
      ],
      "seeAlso": ["[table.new](#fun_table.new)", "[table.clear](#fun_table.clear)"],
      "syntax": ["table.delete(table_id) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.delete",
      "thisType": ["series table"]
    },
    {
      "name": "set_position",
      "desc": ["The function sets the position of a table."],
      "args": [
        {
          "name": "position",
          "desc": "Position of the table. Possible values are: [position.top_left](#const_position.top_left), [position.top_center](#const_position.top_center), [position.top_right](#const_position.top_right), [position.middle_left](#const_position.middle_left), [position.middle_center](#const_position.middle_center), [position.middle_right](#const_position.middle_right), [position.bottom_left](#const_position.bottom_left), [position.bottom_center](#const_position.bottom_center), [position.bottom_right](#const_position.bottom_right).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)"
      ],
      "syntax": ["table.set_position(table_id, position) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.set_position",
      "thisType": ["series table"]
    },
    {
      "name": "set_bgcolor",
      "desc": ["The function sets the background color of a table."],
      "args": [
        {
          "name": "bgcolor",
          "desc": "The background color of the table. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_bgcolor(table_id, bgcolor) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.set_bgcolor",
      "thisType": ["series table"]
    },
    {
      "name": "set_frame_color",
      "desc": ["The function sets the color of the outer frame of a table."],
      "args": [
        {
          "name": "frame_color",
          "desc": "The color of the frame of the table. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_frame_color(table_id, frame_color) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.set_frame_color",
      "thisType": ["series table"]
    },
    {
      "name": "set_border_color",
      "desc": [
        "The function sets the color of the borders (excluding the outer frame) of the table's cells."
      ],
      "args": [
        {
          "name": "border_color",
          "desc": "The color of the borders. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_border_color(table_id, border_color) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.set_border_color",
      "thisType": ["series table"]
    },
    {
      "name": "set_frame_width",
      "desc": ["The function set the width of the outer frame of a table."],
      "args": [
        {
          "name": "frame_width",
          "desc": "The width of the outer frame of the table. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_border_width](#fun_table.set_border_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_frame_width(table_id, frame_width) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.set_frame_width",
      "thisType": ["series table"]
    },
    {
      "name": "set_border_width",
      "desc": [
        "The function sets the width of the borders (excluding the outer frame) of the table's cells."
      ],
      "args": [
        {
          "name": "border_width",
          "desc": "The width of the borders. Optional. The default is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "seeAlso": [
        "[table.clear](#fun_table.clear)",
        "[table.delete](#fun_table.delete)",
        "[table.new](#fun_table.new)",
        "[table.set_frame_color](#fun_table.set_frame_color)",
        "[table.set_frame_width](#fun_table.set_frame_width)",
        "[table.set_bgcolor](#fun_table.set_bgcolor)",
        "[table.set_border_color](#fun_table.set_border_color)",
        "[table.set_position](#fun_table.set_position)"
      ],
      "syntax": ["table.set_border_width(table_id, border_width) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.set_border_width",
      "thisType": ["series table"]
    },
    {
      "name": "cell",
      "desc": ["The function defines a cell in the table and sets its attributes."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the cell. Optional. The default is empty string.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "width",
          "desc": "The width of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the width based on the text inside the cell. Value 0 has the same effect.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "height",
          "desc": "The height of the cell as a % of the indicator's visual space. Optional. By default, auto-adjusts the height based on the text inside of the cell. Value 0 has the same effect.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        },
        {
          "name": "text_color",
          "desc": "The color of the text. Optional. The default is [color.black](#const_color.black).",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of the cell's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the cell's text. Optional. The default value is [text.align_center](#const_text.align_center). Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_size",
          "desc": "Size of the object. The size can be any positive integer, or one of the size.* built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36). The default value is [size.normal](#const_size.normal) or 14.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        },
        {
          "name": "bgcolor",
          "desc": "The background color of the text. Optional. The default is no color.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        },
        {
          "name": "tooltip",
          "desc": "The tooltip to be displayed inside the cell. Optional.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Optional. The default value is [font.family_default](#const_font.family_default). Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "remarks": [
        "This function does not create the table itself, but defines the table’s cells. To use it, you first need to create a table object with [table.new](#fun_table.new).",
        "Each [table.cell](#fun_table.cell) call overwrites all previously defined properties of a cell. If you call [table.cell](#fun_table.cell) twice in a row, e.g., the first time with text='Test Text', and the second time with text_color=[color.red](#const_color.red) but without a new text argument, the default value of the 'text' being an empty string, it will overwrite 'Test Text', and your cell will display an empty string. If you want, instead, to modify any of the cell's properties, use the table.cell_set_*() functions.",
        "A single script can only display one table in each of the possible locations. If [table.cell](#fun_table.cell) is used on several bars to change the same attribute of a cell (e.g. change the background color of the cell to red on the first bar, then to yellow on the second bar), only the last change will be reflected in the table, i.e., the cell’s background will be yellow. Avoid unnecessary setting of cell properties by enclosing function calls in an [if](#kw_if) [barstate.islast](#var_barstate.islast) block whenever possible, to restrict their execution to the last bar of the series."
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_formatting](#fun_table.cell_set_text_formatting)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": [
        "table.cell(table_id, column, row, text, width, height, text_color, text_halign, text_valign, text_size, bgcolor, tooltip, text_font_family, text_formatting) → void"
      ],
      "returnedTypes": ["void"],
      "originalName": "table.cell",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text",
      "desc": ["The function sets the text in the specified cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text",
          "desc": "The text to be displayed inside the cell.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"TABLE example\")",
        "var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)",
        "table.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)",
        "table.cell_set_text(tLog, row = 0, column = 0, text = \"sometext\")"
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)",
        "[table.cell_set_text_formatting](#fun_table.cell_set_text_formatting)"
      ],
      "syntax": ["table.cell_set_text(table_id, column, row, text) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text_formatting",
      "desc": ["Sets the formatting attributes the drawing applies to displayed text."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_formatting",
          "desc": "The formatting of the displayed text. Formatting options support addition. For example, `text.format_bold + text.format_italic` will make the text both bold and italicized. Possible values: [text.format_none](#var_text.format_none), [text.format_bold](#var_text.format_bold), [text.format_italic](#var_text.format_italic). Optional. The default is [text.format_none](#var_text.format_none).",
          "required": true,
          "allowedTypeIDs": ["const text_format"],
          "displayType": "const text_format"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)",
        "[table.cell_set_text](#fun_table.cell_set_text)"
      ],
      "syntax": ["table.cell_set_text_formatting(table_id, column, row, text_formatting) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text_formatting",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text_font_family",
      "desc": ["The function sets the font family of the text inside the cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_font_family",
          "desc": "The font family of the text. Possible values: [font.family_default](#const_font.family_default), [font.family_monospace](#const_font.family_monospace).",
          "required": true,
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"Example of setting the table cell font\")",
        "var t = table.new(position.top_left, rows = 1, columns = 1)",
        "table.cell(t, 0, 0, \"monospace\", text_color = color.blue)",
        "table.cell_set_text_font_family(t, 0, 0, font.family_monospace)"
      ],
      "seeAlso": [
        "[table.new](#fun_table.new)",
        "[font.family_default](#const_font.family_default)",
        "[font.family_monospace](#const_font.family_monospace)"
      ],
      "syntax": ["table.cell_set_text_font_family(table_id, column, row, text_font_family) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text_font_family",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_tooltip",
      "desc": ["The function sets the tooltip in the specified cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "tooltip",
          "desc": "The tooltip to be displayed inside the cell.",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"TABLE example\")",
        "var tLog = table.new(position = position.top_left, rows = 1, columns = 2, bgcolor = color.yellow, border_width=1)",
        "table.cell(tLog, row = 0, column = 0, text = \"sometext\", text_color = color.blue)",
        "table.cell_set_tooltip(tLog, row = 0, column = 0, tooltip = \"sometext\")"
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_text](#fun_table.cell_set_text)"
      ],
      "syntax": ["table.cell_set_tooltip(table_id, column, row, tooltip) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_tooltip",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_width",
      "desc": ["The function sets the width of the cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "width",
          "desc": "The width of the cell as a % of the chart window. Passing 0 auto-adjusts the width based on the text inside of the cell.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_width(table_id, column, row, width) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_width",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_height",
      "desc": ["The function sets the height of cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "height",
          "desc": "The height of the cell as a % of the chart window. Passing 0 auto-adjusts the height based on the text inside of the cell.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float"
          ],
          "displayType": "series int/float"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_height(table_id, column, row, height) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_height",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text_color",
      "desc": ["The function sets the color of the text inside the cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_color",
          "desc": "The color of the text.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_color(table_id, column, row, text_color) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text_color",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text_halign",
      "desc": ["The function sets the horizontal alignment of the cell's text."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_halign",
          "desc": "The horizontal alignment of a cell's text. Possible values: [text.align_left](#const_text.align_left), [text.align_center](#const_text.align_center), [text.align_right](#const_text.align_right).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_halign(table_id, column, row, text_halign) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text_halign",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text_valign",
      "desc": ["The function sets the vertical alignment of a cell's text."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_valign",
          "desc": "The vertical alignment of the cell's text. Possible values: [text.align_top](#const_text.align_top), [text.align_center](#const_text.align_center), [text.align_bottom](#const_text.align_bottom).",
          "allowedTypeIDs": ["series string", "simple string", "input string", "const string"],
          "displayType": "series string"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_valign(table_id, column, row, text_valign) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text_valign",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_text_size",
      "desc": ["The function sets the size of the cell's text."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "text_size",
          "desc": "Size of the object. The size can be any positive integer, or one of the size.* built-in constant strings. The constant strings and their equivalent integer values are: [size.auto](#const_size.auto) (0), [size.tiny](#const_size.tiny) (8), [size.small](#const_size.small) (10), [size.normal](#const_size.normal) (14), [size.large](#const_size.large) (20), [size.huge](#const_size.huge) (36). The default value is [size.normal](#const_size.normal) or 14.",
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series string",
            "simple string",
            "input string",
            "const string"
          ],
          "displayType": "series int/string"
        }
      ],
      "seeAlso": [
        "[table.cell_set_bgcolor](#fun_table.cell_set_bgcolor)",
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_text_size(table_id, column, row, text_size) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_text_size",
      "thisType": ["series table"]
    },
    {
      "name": "cell_set_bgcolor",
      "desc": ["The function sets the background color of the cell."],
      "args": [
        {
          "name": "column",
          "desc": "The index of the cell's column. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row",
          "desc": "The index of the cell's row. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "bgcolor",
          "desc": "The background color of the cell.",
          "allowedTypeIDs": ["series color", "simple color", "input color", "const color"],
          "displayType": "series color"
        }
      ],
      "seeAlso": [
        "[table.cell_set_height](#fun_table.cell_set_height)",
        "[table.cell_set_text](#fun_table.cell_set_text)",
        "[table.cell_set_text_color](#fun_table.cell_set_text_color)",
        "[table.cell_set_text_halign](#fun_table.cell_set_text_halign)",
        "[table.cell_set_text_size](#fun_table.cell_set_text_size)",
        "[table.cell_set_text_valign](#fun_table.cell_set_text_valign)",
        "[table.cell_set_width](#fun_table.cell_set_width)",
        "[table.cell_set_tooltip](#fun_table.cell_set_tooltip)"
      ],
      "syntax": ["table.cell_set_bgcolor(table_id, column, row, bgcolor) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.cell_set_bgcolor",
      "thisType": ["series table"]
    },
    {
      "name": "clear",
      "desc": [
        "The function removes a cell or a sequence of cells from the table. The cells are removed in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner."
      ],
      "args": [
        {
          "name": "start_column",
          "desc": "The index of the column of the first cell to delete. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "start_row",
          "desc": "The index of the row of the first cell to delete. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_column",
          "desc": "The index of the column of the last cell to delete. Optional. The default is the argument used for start_column. Numbering starts at 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_row",
          "desc": "The index of the row of the last cell to delete. Optional. The default is the argument used for start_row. Numbering starts at 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"A donut\", overlay=true)",
        "if barstate.islast",
        "    colNum = 8, rowNum = 8",
        "    padding = \"◯\"",
        "    donutTable = table.new(position.middle_right, colNum, rowNum)",
        "    for c = 0 to colNum - 1",
        "        for r = 0 to rowNum - 1",
        "            table.cell(donutTable, c, r, text=padding, bgcolor=#face6e, text_color=color.new(color.black, 100))",
        "    table.clear(donutTable, 2, 2, 5, 5)"
      ],
      "seeAlso": ["[table.delete](#fun_table.delete)", "[table.new](#fun_table.new)"],
      "syntax": ["table.clear(table_id, start_column, start_row, end_column, end_row) → void"],
      "returnedTypes": ["void"],
      "originalName": "table.clear",
      "thisType": ["series table"]
    },
    {
      "name": "row",
      "desc": ["The function creates a one-dimensional array from the elements of a matrix row."],
      "args": [
        {
          "name": "row",
          "desc": "Index of the required row.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.row()` Example\", \"\", true)",
        "",
        "// Create a 2x3 \"float\" matrix from `hlc3` values.",
        "m = matrix.new<float>(2, 3, hlc3)",
        "",
        "// Return an array with the values of the first row of the matrix.",
        "a = matrix.row(m, 0)",
        "",
        "// Plot the first value from the array `a`.",
        "plot(array.get(a, 0))"
      ],
      "returns": ["An array ID containing the `row` values of the `id` matrix."],
      "remarks": ["Indexing of rows starts at 0."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[array.get](#fun_array.get)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.row(id, row) → array<type>"],
      "returnedTypes": ["array<>"],
      "originalName": "matrix.row",
      "thisType": ["matrix<>"]
    },
    {
      "name": "col",
      "desc": [
        "The function creates a one-dimensional array from the elements of a matrix column."
      ],
      "args": [
        {
          "name": "column",
          "desc": "Index of the required column.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.col()` Example\", \"\", true)",
        "",
        "// Create a 2x3 \"float\" matrix from `hlc3` values.",
        "m = matrix.new<float>(2, 3, hlc3)",
        "",
        "// Return an array with the values of the first column of matrix `m`.",
        "a = matrix.col(m, 0)",
        "",
        "// Plot the first value from the array `a`.",
        "plot(array.get(a, 0))"
      ],
      "returns": ["An array ID containing the `column` values of the `id` matrix."],
      "remarks": ["Indexing of rows starts at 0."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[array.get](#fun_array.get)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.columns](#fun_matrix.columns)"
      ],
      "syntax": ["matrix.col(id, column) → array<type>"],
      "returnedTypes": ["array<>"],
      "originalName": "matrix.col",
      "thisType": ["matrix<>"]
    },
    {
      "name": "reshape",
      "desc": ["The function rebuilds the `id` matrix to `rows` x `cols` dimensions."],
      "args": [
        {
          "name": "rows",
          "desc": "The number of rows of the reshaped matrix.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "columns",
          "desc": "The number of columns of the reshaped matrix.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.reshape()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x3 matrix.",
        "\tvar m1 = matrix.new<float>(2, 3)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 0, 2, 3)",
        "\tmatrix.set(m1, 1, 0, 4)",
        "\tmatrix.set(m1, 1, 1, 5)",
        "\tmatrix.set(m1, 1, 2, 6)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Reshape the copy to a 3x2.",
        "\tmatrix.reshape(m2, 3, 2)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Reshaped matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.add_row](#fun_matrix.add_row)",
        "[matrix.add_col](#fun_matrix.add_col)"
      ],
      "syntax": ["matrix.reshape(id, rows, columns) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.reshape",
      "thisType": ["matrix<>"]
    },
    {
      "name": "get",
      "desc": ["The function returns the element with the specified index of the matrix."],
      "args": [
        {
          "name": "row",
          "desc": "Index of the required row.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "column",
          "desc": "Index of the required column.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.get()` Example\", \"\", true)",
        "",
        "// Create a 2x3 \"float\" matrix from the `hl2` values.",
        "m = matrix.new<float>(2, 3, hl2)",
        "",
        "// Return the value of the element at index [0, 0] of matrix `m`.",
        "x = matrix.get(m, 0, 0)",
        "",
        "plot(x)"
      ],
      "returns": ["The value of the element at the `row` and `column` index of the `id` matrix."],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.get(id, row, column) → <matrix_type>"],
      "returnedTypes": [],
      "originalName": "matrix.get",
      "thisType": ["matrix<>"]
    },
    {
      "name": "set",
      "desc": [
        "The function assigns `value` to the element at the `row` and `column` of the `id` matrix."
      ],
      "args": [
        {
          "name": "row",
          "desc": "The row index of the element to be modified.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "column",
          "desc": "The column index of the element to be modified.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "value",
          "desc": "The new value to be set.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the matrix's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.set()` Example\")",
        "",
        "// Create a 2x3 \"int\" matrix containing values `4`.",
        "m = matrix.new<int>(2, 3, 4)",
        "",
        "// Replace the value of element at row 1 and column 2 with value `3`.",
        "matrix.set(m, 0, 1, 3)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, str.tostring(m))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.set(id, row, column, value) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.set",
      "thisType": ["matrix<>"]
    },
    {
      "name": "add_row",
      "desc": [
        "The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "row",
          "desc": "The index of the row after which the new row will be inserted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a row with `na` values to the matrix.",
            "matrix.add_row(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `2`.",
            "\tvar a = array.from(1, 2)",
            "\t",
            "\t// Add the `a` array as the first row of the empty matrix.",
            "\tmatrix.add_row(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_col](#fun_matrix.add_col)"
      ],
      "syntax": ["matrix.add_row(id, row) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.add_row",
      "thisType": ["matrix<>"]
    },
    {
      "name": "add_row",
      "desc": [
        "The function adds a row at the `row` index of the `id` matrix. The row can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "row",
          "desc": "The index of the row after which the new row will be inserted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "array_id",
          "desc": "An array to be inserted. Optional.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a row with `na` values to the matrix.",
            "matrix.add_row(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a row to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_row()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `2`.",
            "\tvar a = array.from(1, 2)",
            "\t",
            "\t// Add the `a` array as the first row of the empty matrix.",
            "\tmatrix.add_row(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Indexing of rows and columns starts at zero. Rather than add rows to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_col](#fun_matrix.add_col)"
      ],
      "syntax": ["matrix.add_row(id, row, array_id) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.add_row",
      "thisType": ["matrix<>"]
    },
    {
      "name": "add_col",
      "desc": [
        "The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "column",
          "desc": "The index of the column after which the new column will be inserted. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a column with `na` values to the matrix.",
            "matrix.add_col(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `3`.",
            "\tvar a = array.from(1, 3)",
            "\t",
            "\t// Add the `a` array as the first column of the empty matrix.",
            "\tmatrix.add_col(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values. Adding a column is also much slower than adding a row with the [matrix.add_row](#fun_matrix.add_row) function."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_row](#fun_matrix.add_row)"
      ],
      "syntax": ["matrix.add_col(id, column) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.add_col",
      "thisType": ["matrix<>"]
    },
    {
      "name": "add_col",
      "desc": [
        "The function adds a column at the `column` index of the `id` matrix. The column can consist of `na` values, or an array can be used to provide values."
      ],
      "args": [
        {
          "name": "column",
          "desc": "The index of the column after which the new column will be inserted. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "array_id",
          "desc": "An array to be inserted. Optional.",
          "required": true,
          "allowedTypeIDs": ["array<>"],
          "displayType": "any array type"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Adding a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 1\")",
            "",
            "// Create a 2x3 \"int\" matrix containing values `0`.",
            "m = matrix.new<int>(2, 3, 0)",
            "",
            "// Add a column with `na` values to the matrix.",
            "matrix.add_col(m)",
            "",
            "// Display matrix elements.",
            "if barstate.islastconfirmedhistory",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        },
        {
          "desc": ["Adding an array as a column to the matrix"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.add_col()` Example 2\")",
            "",
            "if barstate.islastconfirmedhistory",
            "\t// Create an empty matrix object. ",
            "\tvar m = matrix.new<int>()",
            "\t",
            "\t// Create an array with values `1` and `3`.",
            "\tvar a = array.from(1, 3)",
            "\t",
            "\t// Add the `a` array as the first column of the empty matrix.",
            "\tmatrix.add_col(m, 0, a)",
            "\t",
            "\t// Display matrix elements.",
            "\tvar t = table.new(position.top_right, 2, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m))"
          ]
        }
      ],
      "remarks": [
        "Rather than add columns to an empty matrix, it is far more efficient to declare a matrix with explicit dimensions and fill it with values. Adding a column is also much slower than adding a row with the [matrix.add_row](#fun_matrix.add_row) function."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.add_row](#fun_matrix.add_row)"
      ],
      "syntax": ["matrix.add_col(id, column, array_id) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.add_col",
      "thisType": ["matrix<>"]
    },
    {
      "name": "remove_row",
      "desc": [
        "The function removes the row at `row` index of the `id` matrix and returns an array containing the removed row's values."
      ],
      "args": [
        {
          "name": "row",
          "desc": "The index of the row to be deleted. Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"matrix_remove_row\", overlay = true)",
        "",
        "// Create a 2x2 \"int\" matrix containing values `1`.",
        "var matrixOrig = matrix.new<int>(2, 2, 1)",
        "",
        "// Set values to the 'matrixOrig' matrix.",
        "matrix.set(matrixOrig, 0, 1, 2)",
        "matrix.set(matrixOrig, 1, 0, 3)",
        "matrix.set(matrixOrig, 1, 1, 4)",
        "",
        "// Create a copy of the 'matrixOrig' matrix.",
        "matrixCopy = matrix.copy(matrixOrig)",
        "",
        "// Remove the first row from the matrix `matrixCopy`.",
        "arr = matrix.remove_row(matrixCopy, 0)",
        "",
        "// Display matrix elements.",
        "if barstate.islastconfirmedhistory",
        "\tvar t = table.new(position.top_right, 3, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(matrixOrig))",
        "\ttable.cell(t, 1, 0, \"Removed Elements:\")",
        "\ttable.cell(t, 1, 1, str.tostring(arr))",
        "\ttable.cell(t, 2, 0, \"Result Matrix:\")",
        "\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
      ],
      "returns": ["An array containing the elements of the row removed from the `id` matrix."],
      "remarks": [
        "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing rows."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.copy](#fun_matrix.copy)",
        "[matrix.remove_col](#fun_matrix.remove_col)"
      ],
      "syntax": ["matrix.remove_row(id, row) → array<type>"],
      "returnedTypes": ["array<>"],
      "originalName": "matrix.remove_row",
      "thisType": ["matrix<>"]
    },
    {
      "name": "remove_col",
      "desc": [
        "The function removes the column at `column` index of the `id` matrix and returns an array containing the removed column's values."
      ],
      "args": [
        {
          "name": "column",
          "desc": "The index of the column to be removed. Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"matrix_remove_col\", overlay = true)",
        "",
        "// Create a 2x2 matrix with ones.",
        "var matrixOrig = matrix.new<int>(2, 2, 1)",
        "",
        "// Set values to the 'matrixOrig' matrix.",
        "matrix.set(matrixOrig, 0, 1, 2)",
        "matrix.set(matrixOrig, 1, 0, 3)",
        "matrix.set(matrixOrig, 1, 1, 4)",
        "",
        "",
        "// Create a copy of the 'matrixOrig' matrix.",
        "matrixCopy = matrix.copy(matrixOrig)",
        "",
        "// Remove the first column from the `matrixCopy` matrix.",
        "arr = matrix.remove_col(matrixCopy, 0)",
        "",
        "// Display matrix elements.",
        "if barstate.islastconfirmedhistory",
        "\tvar t = table.new(position.top_right, 3, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(matrixOrig))",
        "\ttable.cell(t, 1, 0, \"Removed Elements:\")",
        "\ttable.cell(t, 1, 1, str.tostring(arr))",
        "\ttable.cell(t, 2, 0, \"Result Matrix:\")",
        "\ttable.cell(t, 2, 1, str.tostring(matrixCopy))"
      ],
      "returns": ["An array containing the elements of the column removed from the `id` matrix."],
      "remarks": [
        "Indexing of rows and columns starts at zero. It is far more efficient to declare matrices with explicit dimensions than to build them by adding or removing columns. Deleting a column is also much slower than deleting a row with the [matrix.remove_row](#fun_matrix.remove_row) function."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.copy](#fun_matrix.copy)",
        "[matrix.remove_row](#fun_matrix.remove_row)"
      ],
      "syntax": ["matrix.remove_col(id, column) → array<type>"],
      "returnedTypes": ["array<>"],
      "originalName": "matrix.remove_col",
      "thisType": ["matrix<>"]
    },
    {
      "name": "fill",
      "desc": [
        "The function fills a rectangular area of the `id` matrix defined by the indices `from_column` to `to_column` (not including it) and `from_row` to `to_row`(not including it) with the `value`."
      ],
      "args": [
        {
          "name": "value",
          "desc": "The value to fill with.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the matrix's elements>"
        },
        {
          "name": "from_row",
          "desc": "Row index from which the fill will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_row",
          "desc": "Row index where the fill will end (not inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "from_column",
          "desc": "Column index from which the fill will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_column",
          "desc": "Column index where the fill will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.fill()` Example\")",
        "",
        "// Create a 4x5 \"int\" matrix containing values `0`.",
        "m = matrix.new<float>(4, 5, 0)",
        "",
        "// Fill the intersection of rows 1 to 2 and columns 2 to 3 of the matrix with `hl2` values.",
        "matrix.fill(m, hl2, 0, 2, 1, 3)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, str.tostring(m))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.fill(id, value, from_row, to_row, from_column, to_column) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.fill",
      "thisType": ["matrix<>"]
    },
    {
      "name": "submatrix",
      "desc": [
        "The function extracts a submatrix of the `id` matrix within the specified indices."
      ],
      "args": [
        {
          "name": "from_row",
          "desc": "Index of the row from which the extraction will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_row",
          "desc": "Index of the row where the extraction will end (non inclusive). Optional. The default value is [matrix.rows](#fun_matrix.rows).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "from_column",
          "desc": "Index of the column from which the extraction will begin (inclusive). Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "to_column",
          "desc": "Index of the column where the extraction will end (non inclusive). Optional. The default value is [matrix.columns](#fun_matrix.columns).",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.submatrix()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x3 matrix matrix with values `0`.",
        "\tvar m1 = matrix.new<int>(2, 3, 0)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 0, 2, 3)",
        "\tmatrix.set(m1, 1, 0, 4)",
        "\tmatrix.set(m1, 1, 1, 5)",
        "\tmatrix.set(m1, 1, 2, 6)",
        "\t",
        "\t// Create a 2x2 submatrix of the `m1` matrix.",
        "\tvar m2 = matrix.submatrix(m1, 0, 2, 1, 3)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Submatrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": [
        "A new matrix object containing the submatrix of the `id` matrix defined by the `from_row`, `to_row`, `from_column` and `to_column` indices."
      ],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.row](#fun_matrix.row)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.reshape](#fun_matrix.reshape)"
      ],
      "syntax": ["matrix.submatrix(id, from_row, to_row, from_column, to_column) → matrix<type>"],
      "returnedTypes": ["matrix<>"],
      "originalName": "matrix.submatrix",
      "thisType": ["matrix<>"]
    },
    {
      "name": "copy",
      "desc": ["The function creates a new matrix which is a copy of the original."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.copy()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x3 \"float\" matrix with `1` values.",
        "\tvar m1 = matrix.new<float>(2, 3, 1)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\t// Note that unlike what `matrix.copy()` does, ",
        "\t// the simple assignment operation `m2 = m1`",
        "\t// would NOT create a new copy of the `m1` matrix.",
        "\t// It would merely create a copy of its ID referencing the same matrix.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 5, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix Copy:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix object of the copied `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.copy(id) → matrix<type>"],
      "returnedTypes": ["matrix<>"],
      "originalName": "matrix.copy",
      "thisType": ["matrix<>"]
    },
    {
      "name": "columns",
      "desc": ["The function returns the number of columns in the matrix."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.columns()` Example\")",
        "",
        "// Create a 2x6 matrix with values `0`.",
        "var m = matrix.new<int>(2, 6, 0)",
        "",
        "// Get the quantity of columns in matrix `m`.",
        "var x = matrix.columns(m)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, \"Columns: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
      ],
      "returns": ["The number of columns in the matrix `id`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.col](#fun_matrix.col)",
        "[matrix.row](#fun_matrix.row)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.columns(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.columns",
      "thisType": ["matrix<>"]
    },
    {
      "name": "rows",
      "desc": ["The function returns the number of rows in the matrix."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.rows()` Example\")",
        "",
        "// Create a 2x6 matrix with values `0`.",
        "var m = matrix.new<int>(2, 6, 0)",
        "",
        "// Get the quantity of rows in the matrix.",
        "var x = matrix.rows(m)",
        "",
        "// Display using a label.",
        "if barstate.islastconfirmedhistory",
        "\tlabel.new(bar_index, high, \"Rows: \" + str.tostring(x) + \"\\n\" + str.tostring(m))"
      ],
      "returns": ["The number of rows in the matrix `id`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.row](#fun_matrix.row)"
      ],
      "syntax": ["matrix.rows(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.rows",
      "thisType": ["matrix<>"]
    },
    {
      "name": "elements_count",
      "desc": ["The function returns the total number of all matrix elements."],
      "args": [],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.elements_count(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.elements_count",
      "thisType": ["matrix<>"]
    },
    {
      "name": "concat",
      "desc": ["The function appends the `m2` matrix to the `m1` matrix."],
      "args": [
        {
          "name": "id2",
          "desc": "Matrix object whose elements will be appended to `id1`.",
          "required": true,
          "allowedTypeIDs": ["matrix<>"],
          "displayType": "any matrix type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.concat()` Example\")",
        "",
        "// Create a 2x4 \"int\" matrix containing values `0`.",
        "m1 = matrix.new<int>(2, 4, 0)",
        "// Create a 2x4 \"int\" matrix containing values `1`.",
        "m2 = matrix.new<int>(2, 4, 1)",
        "",
        "// Append matrix `m2` to `m1`.",
        "matrix.concat(m1, m2)",
        "",
        "// Display matrix elements.",
        "if barstate.islastconfirmedhistory",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix Elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))"
      ],
      "returns": ["Returns the `id1` matrix concatenated with the `id2` matrix."],
      "remarks": ["The number of columns in both matrices must be identical."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.concat(id1, id2) → matrix<type>"],
      "returnedTypes": ["matrix<>"],
      "originalName": "matrix.concat",
      "thisType": ["matrix<>"]
    },
    {
      "name": "swap_rows",
      "desc": ["The function swaps the rows at the index `row1` and `row2` in the `id` matrix."],
      "args": [
        {
          "name": "row1",
          "desc": "Index of the first row to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "row2",
          "desc": "Index of the second row to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.swap_rows()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 3x2 matrix with ‘na’ values.",
        "\tvar m1 = matrix.new<int>(3, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\tmatrix.set(m1, 2, 0, 5)",
        "\tmatrix.set(m1, 2, 1, 6)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Swap the first and second rows of the matrix copy.",
        "\tmatrix.swap_rows(m2, 0, 1)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Swapped rows in copy:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.swap_columns](#fun_matrix.swap_columns)"
      ],
      "syntax": ["matrix.swap_rows(id, row1, row2) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.swap_rows",
      "thisType": ["matrix<>"]
    },
    {
      "name": "swap_columns",
      "desc": [
        "The function swaps the columns at the index `column1` and `column2` in the `id` matrix."
      ],
      "args": [
        {
          "name": "column1",
          "desc": "Index of the first column to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "column2",
          "desc": "Index of the second column to be swapped.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.swap_columns()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix with ‘na’ values.",
        "\tvar m1 = matrix.new<int>(2, 2, na)    ",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Swap the first and second columns of the matrix copy.",
        "\tmatrix.swap_columns(m2, 0, 1)",
        "",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Swapped columns in copy:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "remarks": ["Indexing of the rows and columns starts at zero."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.swap_columns(id, column1, column2) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.swap_columns",
      "thisType": ["matrix<>"]
    },
    {
      "name": "reverse",
      "desc": [
        "The function reverses the order of rows and columns in the matrix `id`. The first row and first column become the last, and the last become the first."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.reverse()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Copy the matrix to a new one.",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Copy matrix elements to a new matrix.",
        "\tvar m2 = matrix.copy(m1)",
        "\t",
        "\t// Reverse the `m2` copy of the original matrix. ",
        "\tmatrix.reverse(m2)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Reversed matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.reshape](#fun_matrix.reshape)"
      ],
      "syntax": ["matrix.reverse(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.reverse",
      "thisType": ["matrix<>"]
    },
    {
      "name": "sort",
      "desc": [
        "The function rearranges the rows in the `id` matrix following the sorted order of the values in the `column`."
      ],
      "args": [
        {
          "name": "column",
          "desc": "Index of the column whose sorted values determine the new order of rows. Optional. The default value is 0.",
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "order",
          "desc": "The sort order. Possible values: [order.ascending](#const_order.ascending) (default), [order.descending](#const_order.descending).",
          "allowedTypeIDs": [
            "series sort_order",
            "simple sort_order",
            "input sort_order",
            "const sort_order"
          ],
          "displayType": "series sort_order"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.sort()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<float>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 3)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 1)",
        "\tmatrix.set(m1, 1, 1, 2)",
        "\t",
        "\t// Copy the matrix to a new one.",
        "\tvar m2 = matrix.copy(m1)",
        "\t// Sort the rows of `m2` using the default arguments (first column and ascending order).",
        "\tmatrix.sort(m2)",
        "\t",
        "\t// Display using a table.",
        "\tif barstate.islastconfirmedhistory",
        "\t\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\t\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\t\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\t\ttable.cell(t, 1, 0, \"Sorted matrix:\")",
        "\t\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.max](#fun_matrix.max)",
        "[matrix.min](#fun_matrix.min)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.sort(id, column, order) → void"],
      "returnedTypes": ["void"],
      "originalName": "matrix.sort",
      "thisType": ["matrix<int>", "matrix<float>", "matrix<string>"]
    },
    {
      "name": "det",
      "desc": [
        "The function returns the [determinant](https://en.wikipedia.org/wiki/Determinant) of a square matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.det` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<float>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0,  3)",
        "matrix.set(m, 0, 1,  7)",
        "matrix.set(m, 1, 0,  1)",
        "matrix.set(m, 1, 1, -4)",
        "",
        "// Get the determinant of the matrix. ",
        "var x = matrix.det(m)",
        "",
        "plot(x, 'Matrix determinant')"
      ],
      "returns": ["The determinant value of the `id` matrix."],
      "remarks": [
        "Function calculation based on the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.det(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.det",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "det",
      "desc": [
        "The function returns the [determinant](https://en.wikipedia.org/wiki/Determinant) of a square matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.det` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<float>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0,  3)",
        "matrix.set(m, 0, 1,  7)",
        "matrix.set(m, 1, 0,  1)",
        "matrix.set(m, 1, 1, -4)",
        "",
        "// Get the determinant of the matrix. ",
        "var x = matrix.det(m)",
        "",
        "plot(x, 'Matrix determinant')"
      ],
      "returns": ["The determinant value of the `id` matrix."],
      "remarks": [
        "Function calculation based on the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.det(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.det",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "min",
      "desc": ["The function returns the smallest value from the matrix elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.min()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the minimum value from the matrix.",
        "var x = matrix.min(m)",
        "",
        "plot(x, 'Matrix minimum value')"
      ],
      "returns": ["The smallest value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.max](#fun_matrix.max)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.min(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.min",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "min",
      "desc": ["The function returns the smallest value from the matrix elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.min()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the minimum value from the matrix.",
        "var x = matrix.min(m)",
        "",
        "plot(x, 'Matrix minimum value')"
      ],
      "returns": ["The smallest value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.max](#fun_matrix.max)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.min(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.min",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "max",
      "desc": ["The function returns the largest value from the matrix elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.max()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the maximum value in the matrix.",
        "var x = matrix.max(m)",
        "",
        "plot(x, 'Matrix maximum value')"
      ],
      "returns": ["The maximum value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.min](#fun_matrix.min)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.max(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.max",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "max",
      "desc": ["The function returns the largest value from the matrix elements."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.max()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the maximum value in the matrix.",
        "var x = matrix.max(m)",
        "",
        "plot(x, 'Matrix maximum value')"
      ],
      "returns": ["The maximum value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.min](#fun_matrix.min)",
        "[matrix.avg](#fun_matrix.avg)",
        "[matrix.sort](#fun_matrix.sort)"
      ],
      "syntax": ["matrix.max(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.max",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "avg",
      "desc": ["The function calculates the average of all elements in the matrix."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.avg()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the average value of the matrix.",
        "var x = matrix.avg(m)",
        "",
        "plot(x, 'Matrix average value')"
      ],
      "returns": ["The average value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.avg(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.avg",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "avg",
      "desc": ["The function calculates the average of all elements in the matrix."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.avg()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the average value of the matrix.",
        "var x = matrix.avg(m)",
        "",
        "plot(x, 'Matrix average value')"
      ],
      "returns": ["The average value from the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.avg(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.avg",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "median",
      "desc": [
        "The function calculates the [median](https://en.wikipedia.org/wiki/Median) (\"the middle\" value) of matrix elements."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.median()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the median of the matrix.",
        "x = matrix.median(m)",
        "",
        "plot(x, 'Median of the matrix')"
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the median."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mode](#fun_matrix.mode)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.median(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.median",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "median",
      "desc": [
        "The function calculates the [median](https://en.wikipedia.org/wiki/Median) (\"the middle\" value) of matrix elements."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.median()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 1)",
        "matrix.set(m, 0, 1, 2)",
        "matrix.set(m, 1, 0, 3)",
        "matrix.set(m, 1, 1, 4)",
        "",
        "// Get the median of the matrix.",
        "x = matrix.median(m)",
        "",
        "plot(x, 'Median of the matrix')"
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the median."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mode](#fun_matrix.mode)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.median(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.median",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "mode",
      "desc": [
        "The function calculates the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.mode()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 0)",
        "matrix.set(m, 0, 1, 0)",
        "matrix.set(m, 1, 0, 1)",
        "matrix.set(m, 1, 1, 1)",
        "",
        "// Get the mode of the matrix.",
        "var x = matrix.mode(m)",
        "",
        "plot(x, 'Mode of the matrix')"
      ],
      "returns": [
        "The most frequently occurring value from the `id` matrix. If none exists, returns the smallest value instead."
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the mode."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.median](#fun_matrix.median)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.mode(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.mode",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "mode",
      "desc": [
        "The function calculates the [mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of the matrix, which is the most frequently occurring value from the matrix elements. When there are multiple values occurring equally frequently, the function returns the smallest of those values."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.mode()` Example\")",
        "",
        "// Create a 2x2 matrix.",
        "var m = matrix.new<int>(2, 2, na)",
        "// Fill the matrix with values.",
        "matrix.set(m, 0, 0, 0)",
        "matrix.set(m, 0, 1, 0)",
        "matrix.set(m, 1, 0, 1)",
        "matrix.set(m, 1, 1, 1)",
        "",
        "// Get the mode of the matrix.",
        "var x = matrix.mode(m)",
        "",
        "plot(x, 'Mode of the matrix')"
      ],
      "returns": [
        "The most frequently occurring value from the `id` matrix. If none exists, returns the smallest value instead."
      ],
      "remarks": [
        "Note that [na](#var_na) elements of the matrix are not considered when calculating the mode."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.median](#fun_matrix.median)",
        "[matrix.sort](#fun_matrix.sort)",
        "[matrix.avg](#fun_matrix.avg)"
      ],
      "syntax": ["matrix.mode(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.mode",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "transpose",
      "desc": [
        "The function creates a new, [transposed](https://en.wikipedia.org/wiki/Transpose#Transpose_of_a_matrix) version of the `id`. This interchanges the row and column index of each element."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.transpose()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<float>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Create a transpose of the matrix.",
        "\tvar m2 = matrix.transpose(m1)",
        "\t",
        "\t// Display using a table.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Transposed matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the transposed version of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)",
        "[matrix.reshape](#fun_matrix.reshape)",
        "[matrix.reverse](#fun_matrix.reverse)"
      ],
      "syntax": ["matrix.transpose(id) → matrix<type>"],
      "returnedTypes": ["matrix<>"],
      "originalName": "matrix.transpose",
      "thisType": ["matrix<>"]
    },
    {
      "name": "sum",
      "desc": [
        "The function returns a new matrix resulting from the [sum](https://en.wikipedia.org/wiki/Matrix_addition) of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object, or scalar value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>"
          ],
          "displayType": "series int/float/matrix<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Sum of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix that sums matrices `m1` and `m2`.",
            "\tvar m3 = matrix.sum(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Sum of a matrix and scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.",
            "\tvar m2 = matrix.sum(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the sum of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.sum(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.sum",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "sum",
      "desc": [
        "The function returns a new matrix resulting from the [sum](https://en.wikipedia.org/wiki/Matrix_addition) of two matrices `id1` and `id2`, or of an `id1` matrix and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object, or scalar value.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/matrix<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Sum of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix that sums matrices `m1` and `m2`.",
            "\tvar m3 = matrix.sum(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Sum of a matrix and scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.sum()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the sum of the `m1` matrix with the \"int\" value `1`.",
            "\tvar m2 = matrix.sum(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Sum of a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the sum of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.sum(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.sum",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "diff",
      "desc": [
        "The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Matrix object or a scalar value to be subtracted.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>"
          ],
          "displayType": "series int/float/matrix<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Difference between two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix containing the difference between matrices `m1` and `m2`.",
            "\tvar m3 = matrix.diff(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Difference between a matrix and a scalar value"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.",
            "\tvar m2 = matrix.diff(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the difference between `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.diff(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.diff",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "diff",
      "desc": [
        "The function returns a new matrix resulting from the subtraction between matrices `id1` and `id2`, or of matrix `id1` and an `id2` scalar (a numerical value)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Matrix object or a scalar value to be subtracted.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/matrix<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Difference between two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(2, 3, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix containing the difference between matrices `m1` and `m2`.",
            "\tvar m3 = matrix.diff(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Difference between a matrix and a scalar value"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.diff()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix with values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4)",
            "\t",
            "\t// Create a new matrix containing the difference between the `m1` matrix and the \"int\" value `1`.",
            "\tvar m2 = matrix.diff(m1, 1)",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Difference between a matrix and a scalar:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m2))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the difference between `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.diff(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.diff",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>"
          ],
          "displayType": "series int/float/matrix<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.mult",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": [
            "series int",
            "simple int",
            "input int",
            "const int",
            "series float",
            "simple float",
            "input float",
            "const float",
            "matrix<int>",
            "matrix<float>"
          ],
          "displayType": "series int/float/matrix<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.mult",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": ["array<int>"],
          "displayType": "array<int>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → array<int>"],
      "returnedTypes": ["array<int>"],
      "originalName": "matrix.mult",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "mult",
      "desc": [
        "The function returns a new matrix resulting from the [product](https://en.wikipedia.org/wiki/Matrix_multiplication) between the matrices `id1` and `id2`, or between an `id1` matrix and an `id2` scalar (a numerical value), or between an `id1` matrix and an `id2` vector (an array of values)."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object, value or array.",
          "required": true,
          "allowedTypeIDs": ["array<int>", "array<float>"],
          "displayType": "array<int/float>"
        }
      ],
      "detailedDesc": [
        {
          "desc": ["Product of two matrices"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 1\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 6x2 matrix containing values `5`.",
            "\tvar m1 = matrix.new<float>(6, 2, 5) ",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\t// Note that it must have the same quantity of rows as there are columns in the first matrix.",
            "\tvar m2 = matrix.new<float>(2, 3, 4) ",
            "\t// Create a new matrix from the multiplication of the two matrices.",
            "\tvar m3 = matrix.mult(m1, m2) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 1, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Product of two matrices:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m3))"
          ]
        },
        {
          "desc": ["Product of a matrix and a scalar"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 2\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<float>(2, 3, 4) ",
            "\t",
            "\t// Create a new matrix from the product of the two matrices.",
            "\tscalar = 5",
            "\tvar m2 = matrix.mult(m1, scalar) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Scalar:\")",
            "\ttable.cell(t, 2, 1, str.tostring(scalar))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 2:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m2))"
          ]
        },
        {
          "desc": ["Product of a matrix and an array vector"],
          "examples": [
            "//@version=6",
            "indicator(\"`matrix.mult()` Example 3\")",
            "",
            "// For efficiency, execute this code only once.",
            "if barstate.islastconfirmedhistory",
            "\t// Create a 2x3 matrix containing values `4`.",
            "\tvar m1 = matrix.new<int>(2, 3, 4)",
            "\t",
            "\t// Create an array of three elements.",
            "\tvar int[] a = array.from(1, 1, 1)",
            "\t",
            "\t// Create a new matrix containing the product of the `m1` matrix and the `a` array.",
            "\tvar m3 = matrix.mult(m1, a) ",
            "\t",
            "\t// Display using a table.",
            "\tvar t = table.new(position.top_right, 5, 2, color.green)",
            "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
            "\ttable.cell(t, 0, 1, str.tostring(m1))",
            "\ttable.cell(t, 1, 1, \"x\")",
            "\ttable.cell(t, 2, 0, \"Value:\")",
            "\ttable.cell(t, 2, 1, str.tostring(a, \" \"))",
            "\ttable.cell(t, 3, 1, \"=\")",
            "\ttable.cell(t, 4, 0, \"Matrix 3:\")",
            "\ttable.cell(t, 4, 1, str.tostring(m3))"
          ]
        }
      ],
      "returns": ["A new matrix object containing the product of `id2` and `id1`."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.sum](#fun_matrix.sum)",
        "[matrix.diff](#fun_matrix.diff)"
      ],
      "syntax": ["matrix.mult(id1, id2) → array<float>"],
      "returnedTypes": ["array<float>"],
      "originalName": "matrix.mult",
      "thisType": ["matrix<int>", "matrix<float>"]
    },
    {
      "name": "pinv",
      "desc": [
        "The function returns the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse) of a matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pinv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Pseudoinverse of the matrix.",
        "\tvar m2 = matrix.pinv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the pseudoinverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using a [Moore–Penrose](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition) inverse formula based on singular-value decomposition of a matrix. For non-singular square matrices this function returns the result of [matrix.inv](#fun_matrix.inv)."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.inv](#fun_matrix.inv)"
      ],
      "syntax": ["matrix.pinv(id) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.pinv",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "pinv",
      "desc": [
        "The function returns the [pseudoinverse](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse) of a matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pinv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Pseudoinverse of the matrix.",
        "\tvar m2 = matrix.pinv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Pseudoinverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the pseudoinverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using a [Moore–Penrose](https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse#Definition) inverse formula based on singular-value decomposition of a matrix. For non-singular square matrices this function returns the result of [matrix.inv](#fun_matrix.inv)."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.inv](#fun_matrix.inv)"
      ],
      "syntax": ["matrix.pinv(id) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.pinv",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "inv",
      "desc": [
        "The function returns the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of a square matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.inv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Inverse of the matrix.",
        "\tvar m2 = matrix.inv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Inverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix, which is the inverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.pinv](#fun_matrix.pinv)",
        "[matrix.copy](#fun_matrix.copy)",
        "[str.tostring](#fun_str.tostring)"
      ],
      "syntax": ["matrix.inv(id) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.inv",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "inv",
      "desc": [
        "The function returns the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of a square matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.inv()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Inverse of the matrix.",
        "\tvar m2 = matrix.inv(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Inverse matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix, which is the inverse of the `id` matrix."],
      "remarks": [
        "The function is calculated using the [LU decomposition](https://en.wikipedia.org/wiki/LU_decomposition) algorithm."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.pinv](#fun_matrix.pinv)",
        "[matrix.copy](#fun_matrix.copy)",
        "[str.tostring](#fun_str.tostring)"
      ],
      "syntax": ["matrix.inv(id) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.inv",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "rank",
      "desc": [
        "The function calculates the [rank](https://en.wikipedia.org/wiki/Rank_(linear_algebra)) of the matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.rank()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Get the rank of the matrix. ",
        "\tr = matrix.rank(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Rank of the matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(r))"
      ],
      "returns": ["The rank of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[str.tostring](#fun_str.tostring)"
      ],
      "syntax": ["matrix.rank(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.rank",
      "thisType": ["matrix<>"]
    },
    {
      "name": "trace",
      "desc": [
        "The function calculates the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a matrix (the sum of the main diagonal's elements)."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.trace()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Get the trace of the matrix.",
        "\ttr = matrix.trace(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Trace of the matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["The trace of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.trace(id) → series float"],
      "returnedTypes": ["series float"],
      "originalName": "matrix.trace",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "trace",
      "desc": [
        "The function calculates the [trace](https://en.wikipedia.org/wiki/Trace_(linear_algebra)) of a matrix (the sum of the main diagonal's elements)."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.trace()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 1)",
        "\tmatrix.set(m1, 0, 1, 2)",
        "\tmatrix.set(m1, 1, 0, 3)",
        "\tmatrix.set(m1, 1, 1, 4)",
        "\t",
        "\t// Get the trace of the matrix.",
        "\ttr = matrix.trace(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Trace of the matrix:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["The trace of the `id` matrix."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.trace(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "matrix.trace",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "eigenvalues",
      "desc": [
        "The function returns an array containing the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors) of a square matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvalues()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvalues of the matrix.",
        "\ttr = matrix.eigenvalues(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["An array containing the eigenvalues of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvectors](#fun_matrix.eigenvectors)"
      ],
      "syntax": ["matrix.eigenvalues(id) → array<float>"],
      "returnedTypes": ["array<float>"],
      "originalName": "matrix.eigenvalues",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "eigenvalues",
      "desc": [
        "The function returns an array containing the [eigenvalues](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors) of a square matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvalues()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, na)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvalues of the matrix.",
        "\ttr = matrix.eigenvalues(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Array of Eigenvalues:\")",
        "\ttable.cell(t, 1, 1, str.tostring(tr))"
      ],
      "returns": ["An array containing the eigenvalues of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvectors](#fun_matrix.eigenvectors)"
      ],
      "syntax": ["matrix.eigenvalues(id) → array<int>"],
      "returnedTypes": ["array<int>"],
      "originalName": "matrix.eigenvalues",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "eigenvectors",
      "desc": [
        "Returns a matrix of [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors), in which each column is an eigenvector of the `id` matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvectors()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix ",
        "\tvar m1 = matrix.new<int>(2, 2, 1)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvectors of the matrix.",
        "\tm2 = matrix.eigenvectors(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix Elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the eigenvectors of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvalues](#fun_matrix.eigenvalues)"
      ],
      "syntax": ["matrix.eigenvectors(id) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.eigenvectors",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "eigenvectors",
      "desc": [
        "Returns a matrix of [eigenvectors](https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors), in which each column is an eigenvector of the `id` matrix."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.eigenvectors()` Example\")",
        "",
        "// For efficiency, execute this code only once.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix ",
        "\tvar m1 = matrix.new<int>(2, 2, 1)",
        "\t// Fill the matrix with values.",
        "\tmatrix.set(m1, 0, 0, 2)",
        "\tmatrix.set(m1, 0, 1, 4)",
        "\tmatrix.set(m1, 1, 0, 6)",
        "\tmatrix.set(m1, 1, 1, 8)",
        "\t",
        "\t// Get the eigenvectors of the matrix.",
        "\tm2 = matrix.eigenvectors(m1)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix Elements:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix Eigenvectors:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["A new matrix containing the eigenvectors of the `id` matrix."],
      "remarks": ["The function is calculated using \"The Implicit QL Algorithm\"."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.eigenvalues](#fun_matrix.eigenvalues)"
      ],
      "syntax": ["matrix.eigenvectors(id) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.eigenvectors",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "kron",
      "desc": [
        "The function returns the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) for the `id1` and `id2` matrices."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>", "matrix<float>"],
          "displayType": "matrix<int/float>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.kron()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create two matrices with default values `1` and `2`. ",
        "\tvar m1 = matrix.new<float>(2, 2, 1) ",
        "\tvar m2 = matrix.new<float>(2, 2, 2) ",
        "\t",
        "\t// Calculate the Kronecker product of the matrices.",
        "\tvar m3 = matrix.kron(m1, m2) ",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 5, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 1, \"⊗\")",
        "\ttable.cell(t, 2, 0, \"Matrix 2:\")",
        "\ttable.cell(t, 2, 1, str.tostring(m2))",
        "\ttable.cell(t, 3, 1, \"=\")",
        "\ttable.cell(t, 4, 0, \"Kronecker product:\")",
        "\ttable.cell(t, 4, 1, str.tostring(m3))"
      ],
      "returns": [
        "A new matrix containing the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) of `id1` and `id2`."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mult](#fun_matrix.mult)",
        "[str.tostring](#fun_str.tostring)",
        "[table.new](#fun_table.new)"
      ],
      "syntax": ["matrix.kron(id1, id2) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.kron",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "kron",
      "desc": [
        "The function returns the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) for the `id1` and `id2` matrices."
      ],
      "args": [
        {
          "name": "id2",
          "desc": "Second matrix object.",
          "required": true,
          "allowedTypeIDs": ["matrix<int>"],
          "displayType": "matrix<int>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.kron()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create two matrices with default values `1` and `2`. ",
        "\tvar m1 = matrix.new<float>(2, 2, 1) ",
        "\tvar m2 = matrix.new<float>(2, 2, 2) ",
        "\t",
        "\t// Calculate the Kronecker product of the matrices.",
        "\tvar m3 = matrix.kron(m1, m2) ",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 5, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Matrix 1:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 1, \"⊗\")",
        "\ttable.cell(t, 2, 0, \"Matrix 2:\")",
        "\ttable.cell(t, 2, 1, str.tostring(m2))",
        "\ttable.cell(t, 3, 1, \"=\")",
        "\ttable.cell(t, 4, 0, \"Kronecker product:\")",
        "\ttable.cell(t, 4, 1, str.tostring(m3))"
      ],
      "returns": [
        "A new matrix containing the [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product) of `id1` and `id2`."
      ],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.mult](#fun_matrix.mult)",
        "[str.tostring](#fun_str.tostring)",
        "[table.new](#fun_table.new)"
      ],
      "syntax": ["matrix.kron(id1, id2) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.kron",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "pow",
      "desc": ["The function calculates the product of the matrix by itself `power` times."],
      "args": [
        {
          "name": "power",
          "desc": "The number of times the matrix will be multiplied by itself.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pow()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, 2)",
        "\t// Calculate the power of three of the matrix.",
        "\tvar m2 = matrix.pow(m1, 3)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix³:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["The product of the `id` matrix by itself `power` times."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.mult](#fun_matrix.mult)"
      ],
      "syntax": ["matrix.pow(id, power) → matrix<float>"],
      "returnedTypes": ["matrix<float>"],
      "originalName": "matrix.pow",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "pow",
      "desc": ["The function calculates the product of the matrix by itself `power` times."],
      "args": [
        {
          "name": "power",
          "desc": "The number of times the matrix will be multiplied by itself.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"`matrix.pow()` Example\")",
        "",
        "// Display using a table.",
        "if barstate.islastconfirmedhistory",
        "\t// Create a 2x2 matrix. ",
        "\tvar m1 = matrix.new<int>(2, 2, 2)",
        "\t// Calculate the power of three of the matrix.",
        "\tvar m2 = matrix.pow(m1, 3)",
        "\t",
        "\t// Display matrix elements.",
        "\tvar t = table.new(position.top_right, 2, 2, color.green)",
        "\ttable.cell(t, 0, 0, \"Original Matrix:\")",
        "\ttable.cell(t, 0, 1, str.tostring(m1))",
        "\ttable.cell(t, 1, 0, \"Matrix³:\")",
        "\ttable.cell(t, 1, 1, str.tostring(m2))"
      ],
      "returns": ["The product of the `id` matrix by itself `power` times."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.mult](#fun_matrix.mult)"
      ],
      "syntax": ["matrix.pow(id, power) → matrix<int>"],
      "returnedTypes": ["matrix<int>"],
      "originalName": "matrix.pow",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_zero",
      "desc": ["The function determines if all elements of the matrix are zero."],
      "args": [],
      "returns": ["Returns true if all elements of the `id` matrix are zero, false otherwise."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)"
      ],
      "syntax": ["matrix.is_zero(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_zero",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_identity",
      "desc": [
        "The function determines if a matrix is an [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix) (elements with ones on the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) and zeros elsewhere)."
      ],
      "args": [],
      "returns": ["Returns true if `id` is an identity matrix, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.is_square](#fun_matrix.is_square)",
        "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
      ],
      "syntax": ["matrix.is_identity(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_identity",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_binary",
      "desc": [
        "The function determines if the matrix is [binary](https://en.wikipedia.org/wiki/Logical_matrix) (when all elements of the matrix are 0 or 1)."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is binary, false otherwise."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)"
      ],
      "syntax": ["matrix.is_binary(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_binary",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_symmetric",
      "desc": [
        "The function determines if a [square matrix](https://en.wikipedia.org/wiki/Square_matrix) is [symmetric](https://en.wikipedia.org/wiki/Symmetric_matrix) (elements are symmetric with respect to the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal))."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is symmetric, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.is_symmetric(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_symmetric",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_antisymmetric",
      "desc": [
        "The function determines if a matrix is [antisymmetric](https://en.wikipedia.org/wiki/Skew-symmetric_matrix) (its [transpose](https://en.wikipedia.org/wiki/Transpose) equals its negative)."
      ],
      "args": [],
      "returns": ["Returns true, if the `id` matrix is antisymmetric, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.is_antisymmetric(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_antisymmetric",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_diagonal",
      "desc": [
        "The function determines if the matrix is [diagonal](https://en.wikipedia.org/wiki/Diagonal_matrix) (all elements outside the main diagonal are zero)."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is diagonal, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)",
        "[matrix.is_identity](#fun_matrix.is_identity)",
        "[matrix.is_antidiagonal](#fun_matrix.is_antidiagonal)"
      ],
      "syntax": ["matrix.is_diagonal(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_diagonal",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_antidiagonal",
      "desc": [
        "The function determines if the matrix is [anti-diagonal](https://en.wikipedia.org/wiki/Anti-diagonal_matrix) (all elements outside the secondary diagonal are zero)."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is ​​anti-diagonal, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)",
        "[matrix.is_identity](#fun_matrix.is_identity)",
        "[matrix.is_diagonal](#fun_matrix.is_diagonal)"
      ],
      "syntax": ["matrix.is_antidiagonal(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_antidiagonal",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_triangular",
      "desc": [
        "The function determines if the matrix is [triangular](https://en.wikipedia.org/wiki/Triangular_matrix) (if all elements above or below the [main diagonal](https://en.wikipedia.org/wiki/Main_diagonal) are zero)."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is triangular, false otherwise."],
      "remarks": ["Returns false with non-square matrices."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.is_square](#fun_matrix.is_square)"
      ],
      "syntax": ["matrix.is_triangular(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_triangular",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_stochastic",
      "desc": [
        "The function determines if the matrix is [stochastic](https://en.wikipedia.org/wiki/Stochastic_matrix)."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is stochastic, false otherwise."],
      "seeAlso": ["[matrix.new<type>](#fun_matrix.new<type>)", "[matrix.set](#fun_matrix.set)"],
      "syntax": ["matrix.is_stochastic(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_stochastic",
      "thisType": ["matrix<float>", "matrix<int>"]
    },
    {
      "name": "is_square",
      "desc": [
        "The function determines if the matrix is [square](https://en.wikipedia.org/wiki/Square_matrix) (it has the same number of rows and columns)."
      ],
      "args": [],
      "returns": ["Returns true if the `id` matrix is square, false otherwise."],
      "seeAlso": [
        "[matrix.new<type>](#fun_matrix.new<type>)",
        "[matrix.get](#fun_matrix.get)",
        "[matrix.set](#fun_matrix.set)",
        "[matrix.columns](#fun_matrix.columns)",
        "[matrix.rows](#fun_matrix.rows)"
      ],
      "syntax": ["matrix.is_square(id) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "matrix.is_square",
      "thisType": ["matrix<>"]
    },
    {
      "name": "merge_cells",
      "desc": [
        "The function merges a sequence of cells in the table into one cell. The cells are merged in a rectangle shape where the start_column and start_row specify the top-left corner, and end_column and end_row specify the bottom-right corner."
      ],
      "args": [
        {
          "name": "start_column",
          "desc": "The index of the column of the first cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "start_row",
          "desc": "The index of the row of the first cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_column",
          "desc": "The index of the column of the last cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        },
        {
          "name": "end_row",
          "desc": "The index of the row of the last cell to merge. Numbering starts at 0.",
          "required": true,
          "allowedTypeIDs": ["series int", "simple int", "input int", "const int"],
          "displayType": "series int"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"table.merge_cells example\")",
        "SMA50  = ta.sma(close, 50)",
        "SMA100 = ta.sma(close, 100)",
        "SMA200 = ta.sma(close, 200)",
        "if barstate.islast",
        "\tmaTable = table.new(position.bottom_right, 3, 3, bgcolor = color.gray, border_width = 1, border_color = color.black)",
        "\t// Header",
        "\ttable.cell(maTable, 0, 0, text = \"SMA Table\")",
        "\ttable.merge_cells(maTable, 0, 0, 2, 0)",
        "\t// Cell Titles",
        "\ttable.cell(maTable, 0, 1, text = \"SMA 50\")",
        "\ttable.cell(maTable, 1, 1, text = \"SMA 100\")",
        "\ttable.cell(maTable, 2, 1, text = \"SMA 200\")",
        "\t// Values",
        "\ttable.cell(maTable, 0, 2, bgcolor = color.white, text = str.tostring(SMA50))",
        "\ttable.cell(maTable, 1, 2, bgcolor = color.white, text = str.tostring(SMA100))",
        "\ttable.cell(maTable, 2, 2, bgcolor = color.white, text = str.tostring(SMA200))"
      ],
      "remarks": [
        "This function will merge cells, even if their properties are not yet defined with [table.cell](#fun_table.cell).",
        "The resulting merged cell inherits all of its values from the cell located at `start_column`:`start_row`, except width and height. The width and height of the resulting merged cell are based on the width/height of other cells in the neighboring columns/rows and cannot be set manually.",
        "To modify the merged cell with any of the `table.cell_set_*` functions, target the cell at the `start_column`:`start_row` coordinates.",
        "An attempt to merge a cell that has already been merged will result in an error."
      ],
      "seeAlso": ["[table.delete](#fun_table.delete)", "[table.new](#fun_table.new)"],
      "syntax": [
        "table.merge_cells(table_id, start_column, start_row, end_column, end_row) → void"
      ],
      "returnedTypes": ["void"],
      "originalName": "table.merge_cells",
      "thisType": ["series table"]
    },
    {
      "name": "copy",
      "desc": [
        "Creates a copy of a [chart.point](#type_chart.point) object with the specified `id`."
      ],
      "args": [],
      "syntax": ["chart.point.copy(id) → chart.point"],
      "returnedTypes": ["chart.point"],
      "originalName": "chart.point.copy",
      "thisType": ["chart.point"]
    },
    {
      "name": "set_first_point",
      "desc": ["Sets the first point of the `id` line to `point`."],
      "args": [
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["line.set_first_point(id, point) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_first_point",
      "thisType": ["series line"]
    },
    {
      "name": "set_second_point",
      "desc": ["Sets the second point of the `id` line to `point`."],
      "args": [
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["line.set_second_point(id, point) → void"],
      "returnedTypes": ["void"],
      "originalName": "line.set_second_point",
      "thisType": ["series line"]
    },
    {
      "name": "set_point",
      "desc": ["Sets the location of the `id` label to `point`."],
      "args": [
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["label.set_point(id, point) → void"],
      "returnedTypes": ["void"],
      "originalName": "label.set_point",
      "thisType": ["series label"]
    },
    {
      "name": "set_top_left_point",
      "desc": ["Sets the top-left corner location of the `id` box to `point`."],
      "args": [
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["box.set_top_left_point(id, point) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_top_left_point",
      "thisType": ["series box"]
    },
    {
      "name": "set_bottom_right_point",
      "desc": ["Sets the bottom-right corner location of the `id` box to `point`."],
      "args": [
        {
          "name": "point",
          "desc": "A [chart.point](#type_chart.point) object.",
          "required": true,
          "allowedTypeIDs": ["chart.point"],
          "displayType": "chart.point"
        }
      ],
      "syntax": ["box.set_bottom_right_point(id, point) → void"],
      "returnedTypes": ["void"],
      "originalName": "box.set_bottom_right_point",
      "thisType": ["series box"]
    },
    {
      "name": "copy",
      "desc": ["Creates a copy of an existing map."],
      "returns": ["A copy of the `id` map."],
      "args": [],
      "syntax": ["map.copy(id) → map<keyType, valueType>"],
      "examples": [
        "//@version=6",
        "indicator(\"map.copy example\")",
        "a = map.new<string, int>()",
        "a.put(\"example\", 1)",
        "b = map.copy(a)",
        "a := map.new<string, int>()",
        "a.put(\"example\", 2)",
        "plot(a.get(\"example\"))",
        "plot(b.get(\"example\"))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.get](#fun_map.get)",
        "[map.size](#fun_map.size)"
      ],
      "originalName": "map.copy",
      "thisType": ["map<>"]
    },
    {
      "name": "size",
      "desc": ["Returns the number of key-value pairs in the `id` map."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"map.size example\")",
        "a = map.new<int, int>()",
        "size = 10",
        "for i = 0 to size",
        "\ta.put(i, size-i)",
        "plot(map.size(a))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.get](#fun_map.get)"
      ],
      "syntax": ["map.size(id) → series int"],
      "returnedTypes": ["series int"],
      "originalName": "map.size",
      "thisType": ["map<>"]
    },
    {
      "name": "get",
      "desc": ["Returns the value associated with the specified `key` in the `id` map."],
      "args": [
        {
          "name": "key",
          "desc": "The key of the value to retrieve.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.get example\")",
        "a = map.new<int, int>()",
        "size = 10",
        "for i = 0 to size",
        "\ta.put(i, size-i)",
        "plot(map.get(a, 1))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.contains](#fun_map.contains)"
      ],
      "syntax": ["map.get(id, key) → <value_type>"],
      "returnedTypes": [],
      "originalName": "map.get",
      "thisType": ["map<>"]
    },
    {
      "name": "contains",
      "desc": [
        "Returns [true](#const_true) if the `key` was found in the `id` map, [false](#const_false) otherwise."
      ],
      "args": [
        {
          "name": "key",
          "desc": "The key to search in the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.includes example\")",
        "a = map.new<string, float>()",
        "a.put(\"open\", open)",
        "p = close",
        "if map.contains(a, \"open\")",
        "\tp := a.get(\"open\")",
        "plot(p)"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.size](#fun_map.size)"
      ],
      "syntax": ["map.contains(id, key) → series bool"],
      "returnedTypes": ["series bool"],
      "originalName": "map.contains",
      "thisType": ["map<>"]
    },
    {
      "name": "keys",
      "desc": [
        "Returns an array of all the keys in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"map.keys example\")",
        "a = map.new<string, float>()",
        "a.put(\"open\", open)",
        "a.put(\"high\", high)",
        "a.put(\"low\", low)",
        "a.put(\"close\", close)",
        "keys = map.keys(a)",
        "ohlc = 0.0",
        "for key in keys",
        "\tohlc += a.get(key)",
        "plot(ohlc/4)"
      ],
      "remarks": [
        "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order."
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.get](#fun_map.get)",
        "[map.values](#fun_map.values)",
        "[map.size](#fun_map.size)"
      ],
      "syntax": ["map.keys(id) → array<type>"],
      "returnedTypes": ["array<>"],
      "originalName": "map.keys",
      "thisType": ["map<>"]
    },
    {
      "name": "values",
      "desc": [
        "Returns an array of all the values in the `id` map. The resulting array is a copy and any changes to it are not reflected in the original map."
      ],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"map.values example\")",
        "a = map.new<string, float>()",
        "a.put(\"open\", open)",
        "a.put(\"high\", high)",
        "a.put(\"low\", low)",
        "a.put(\"close\", close)",
        "values = map.values(a)",
        "ohlc = 0.0",
        "for value in values",
        "\tohlc += value",
        "plot(ohlc/4)"
      ],
      "remarks": [
        "Maps maintain insertion order. The elements within the array returned by this function will also be in the insertion order."
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.get](#fun_map.get)",
        "[map.keys](#fun_map.keys)",
        "[map.size](#fun_map.size)"
      ],
      "syntax": ["map.values(id) → array<type>"],
      "returnedTypes": ["array<>"],
      "originalName": "map.values",
      "thisType": ["map<>"]
    },
    {
      "name": "put",
      "desc": ["Puts a new key-value pair into the `id` map."],
      "returns": [
        "The previous value associated with `key` if the key was already present in the map, or [na](#var_na) if the key is new."
      ],
      "args": [
        {
          "name": "key",
          "desc": "The key to put into the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        },
        {
          "name": "value",
          "desc": "The key value to put into the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.put example\")",
        "a = map.new<string, float>()",
        "map.put(a, \"first\", 10)",
        "map.put(a, \"second\", 15)",
        "prevFirst = map.put(a, \"first\", 20)",
        "currFirst = a.get(\"first\")",
        "plot(prevFirst)",
        "plot(currFirst)"
      ],
      "remarks": [
        "Maps maintain insertion order. Note that the order does not change when inserting a pair with a `key` that's already in the map. The new pair replaces the existing pair with the `key` in such cases."
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put_all](#fun_map.put_all)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.remove](#fun_map.remove)"
      ],
      "syntax": ["map.put(id, key, value) → <value_type>"],
      "returnedTypes": [],
      "originalName": "map.put",
      "thisType": ["map<>"]
    },
    {
      "name": "put_all",
      "desc": ["Puts all key-value pairs from the `id2` map into the `id` map."],
      "args": [
        {
          "name": "id2",
          "desc": "A map object to be appended.",
          "required": true,
          "allowedTypeIDs": ["map<>"],
          "displayType": "any map type"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.put_all example\")",
        "a = map.new<string, float>()",
        "b = map.new<string, float>()",
        "a.put(\"first\", 10)",
        "a.put(\"second\", 15)",
        "b.put(\"third\", 20)",
        "map.put_all(a, b)",
        "plot(a.get(\"third\"))"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.remove](#fun_map.remove)"
      ],
      "syntax": ["map.put_all(id, id2) → void"],
      "returnedTypes": ["void"],
      "originalName": "map.put_all",
      "thisType": ["map<>"]
    },
    {
      "name": "remove",
      "desc": ["Removes a key-value pair from the `id` map."],
      "returns": [
        "The previous value associated with `key` if the key was present in the map, or [na](#var_na) if there was no such key."
      ],
      "args": [
        {
          "name": "key",
          "desc": "The key of the pair to remove from the map.",
          "required": true,
          "allowedTypeIDs": [],
          "displayType": "series <type of the map's elements>"
        }
      ],
      "examples": [
        "//@version=6",
        "indicator(\"map.remove example\")",
        "a = map.new<string, color>()",
        "a.put(\"firstColor\", color.green)",
        "oldColorValue = map.remove(a, \"firstColor\")",
        "plot(close, color = oldColorValue)"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put](#fun_map.put)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.clear](#fun_map.clear)"
      ],
      "syntax": ["map.remove(id, key) → <value_type>"],
      "returnedTypes": [],
      "originalName": "map.remove",
      "thisType": ["map<>"]
    },
    {
      "name": "clear",
      "desc": ["Clears the map, removing all key-value pairs from it."],
      "args": [],
      "examples": [
        "//@version=6",
        "indicator(\"map.clear example\")",
        "oddMap = map.new<int, bool>()",
        "oddMap.put(1, true)",
        "oddMap.put(2, false)",
        "oddMap.put(3, true)",
        "map.clear(oddMap)",
        "plot(oddMap.size())"
      ],
      "seeAlso": [
        "[map.new<type,type>](#fun_map.new<type,type>)",
        "[map.put_all](#fun_map.put_all)",
        "[map.keys](#fun_map.keys)",
        "[map.values](#fun_map.values)",
        "[map.remove](#fun_map.remove)"
      ],
      "syntax": ["map.clear(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "map.clear",
      "thisType": ["map<>"]
    },
    {
      "name": "delete",
      "desc": [
        "Deletes the specified [polyline](#type_polyline) object. It has no effect if the `id` doesn't exist."
      ],
      "args": [],
      "syntax": ["polyline.delete(id) → void"],
      "returnedTypes": ["void"],
      "originalName": "polyline.delete",
      "thisType": ["series polyline"]
    }
  ]
}
